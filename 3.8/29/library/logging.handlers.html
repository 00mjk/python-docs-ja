
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>logging.handlers --- ロギングハンドラ &#8212; Python 3.8.3rc1 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.8.3rc1 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="next" title="getpass --- 可搬性のあるパスワード入力機構" href="getpass.html" />
    <link rel="prev" title="logging.config --- ロギングの環境設定" href="logging.config.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/logging.handlers.html" />
    
      
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="getpass.html" title="getpass --- 可搬性のあるパスワード入力機構"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="logging.config.html" title="logging.config --- ロギングの環境設定"
             accesskey="P">前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3rc1 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">汎用オペレーティングシステムサービス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-logging.handlers">
<span id="logging-handlers-logging-handlers"></span><h1><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> --- ロギングハンドラ<a class="headerlink" href="#module-logging.handlers" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><strong>ソースコード:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/logging/handlers.py">Lib/logging/handlers.py</a></p>
<div class="sidebar">
<p class="first sidebar-title">Important</p>
<p>このページには、リファレンス情報だけが含まれています。チュートリアルは、以下のページを参照してください</p>
<ul class="last simple">
<li><a class="reference internal" href="../howto/logging.html#logging-basic-tutorial"><span class="std std-ref">基本チュートリアル</span></a></li>
<li><a class="reference internal" href="../howto/logging.html#logging-advanced-tutorial"><span class="std std-ref">上級チュートリアル</span></a></li>
<li><a class="reference internal" href="../howto/logging-cookbook.html#logging-cookbook"><span class="std std-ref">ロギングクックブック</span></a></li>
</ul>
</div>
<hr class="docutils" />
<p>このパッケージでは、以下の便利なハンドラが提供されています。なお、これらのハンドラのうち、3 つ (<a class="reference internal" href="#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a>, <a class="reference internal" href="#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a> および <a class="reference internal" href="#logging.NullHandler" title="logging.NullHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">NullHandler</span></code></a>) は、実際には <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> モジュール自身で定義されていますが、他のハンドラと一緒にここでドキュメント化します。</p>
<div class="section" id="streamhandler">
<span id="stream-handler"></span><h2>StreamHandler<a class="headerlink" href="#streamhandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> コアパッケージに含まれる <a class="reference internal" href="#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a> クラスは、ログ出力を <em>sys.stdout</em>, <em>sys.stderr</em> あるいは何らかのファイル風 (file-like) オブジェクト (あるいは、より正確に言えば <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> および <code class="xref py py-meth docutils literal notranslate"><span class="pre">flush()</span></code> メソッドをサポートする何らかのオブジェクト) といったストリームに送信します。</p>
<dl class="class">
<dt id="logging.StreamHandler">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">StreamHandler</code><span class="sig-paren">(</span><em>stream=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.StreamHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a> クラスの新たなインスタンスを返します。 <em>stream</em> が指定された場合、インスタンスはログ出力先として指定されたストリームを使います; そうでない場合、 <em>sys.stderr</em> が使われます。</p>
<dl class="method">
<dt id="logging.StreamHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.StreamHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>フォーマッタが指定されていれば、フォーマッタを使ってレコードを書式化します。 次に、レコードが終端記号とともにストリームに書き込まれます。 例外情報が存在する場合、 <a class="reference internal" href="traceback.html#traceback.print_exception" title="traceback.print_exception"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.print_exception()</span></code></a> を使って書式化され、 ストリームの末尾につけられます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.StreamHandler.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.StreamHandler.flush" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ストリームの <a class="reference internal" href="#logging.StreamHandler.flush" title="logging.StreamHandler.flush"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flush()</span></code></a> メソッドを呼び出してバッファをフラッシュします。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> メソッドは <a class="reference internal" href="logging.html#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a> から継承しているため何も出力を行わないので、 <a class="reference internal" href="#logging.StreamHandler.flush" title="logging.StreamHandler.flush"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flush()</span></code></a> 呼び出しを明示的に行う必要があるかもしれません。</p>
</dd></dl>

<dl class="method">
<dt id="logging.StreamHandler.setStream">
<code class="descname">setStream</code><span class="sig-paren">(</span><em>stream</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.StreamHandler.setStream" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このインスタンスの stream と指定された値が異なる場合、指定された値に設定します。
新しい stream を設定する前に、古い stream はフラッシュされます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><strong>stream</strong> -- ハンドラがこれから使う stream 。</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body">stream が変更された場合は古い stream 、そうでない場合は <em>None</em> 。</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><code class="docutils literal notranslate"><span class="pre">StreamHandler</span></code> クラスに <code class="docutils literal notranslate"><span class="pre">terminator</span></code> 属性が追加されました (デフォルト値は <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>)。これは、書式化されたレコードをストリームに書き込むときの終端記号として使用されます。このような改行による終端を望まなければ、ハンドラ・インスタンスの <code class="docutils literal notranslate"><span class="pre">terminator</span></code> 属性を空の文字列に設定することができます。初期のバージョンでは、終端記号は <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> としてハードコードされていました。</p>
</div>
</div>
<div class="section" id="filehandler">
<span id="file-handler"></span><h2>FileHandler<a class="headerlink" href="#filehandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> コアパッケージに含まれる <a class="reference internal" href="#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a> クラスは、ログ出力をディスク上のファイルに送信します。このクラスは出力機能を <a class="reference internal" href="#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a> から継承しています。</p>
<dl class="class">
<dt id="logging.FileHandler">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">FileHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>mode='a'</em>, <em>encoding=None</em>, <em>delay=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.FileHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a> クラスの新たなインスタンスを返します。
指定されたファイルが開かれ、ログ記録のためのストリームとして使われます。
<em>mode</em> が指定されなかった場合、 <code class="xref py py-const docutils literal notranslate"><span class="pre">'a'</span></code> が使われます。
<em>encoding</em> が <code class="docutils literal notranslate"><span class="pre">None</span></code> でない場合、その値はファイルを開くときのエンコーディングとして使われます。
<em>delay</em> が真ならば、ファイルを開くのは最初の <a class="reference internal" href="#logging.FileHandler.emit" title="logging.FileHandler.emit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code></a> 呼び出しまで遅らせられます。
デフォルトでは、ファイルは無制限に大きくなりつづけます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>文字列値に加え、 <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> オブジェクトも <em>filename</em> 引数が受け取るようになりました。</p>
</div>
<dl class="method">
<dt id="logging.FileHandler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.FileHandler.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルを閉じます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.FileHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.FileHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>record</em> をファイルに出力します。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="nullhandler">
<span id="null-handler"></span><h2>NullHandler<a class="headerlink" href="#nullhandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.1 で追加.</span></p>
</div>
<p><a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> コアパッケージに含まれる <a class="reference internal" href="#logging.NullHandler" title="logging.NullHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">NullHandler</span></code></a> クラスは、いかなる書式化も出力も行いません。これは本質的には、ライブラリ開発者に使われる 'no-op' ハンドラです。</p>
<dl class="class">
<dt id="logging.NullHandler">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">NullHandler</code><a class="headerlink" href="#logging.NullHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.NullHandler" title="logging.NullHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">NullHandler</span></code></a> クラスの新しいインスタンスを返します。</p>
<dl class="method">
<dt id="logging.NullHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.NullHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは何もしません。</p>
</dd></dl>

<dl class="method">
<dt id="logging.NullHandler.handle">
<code class="descname">handle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.NullHandler.handle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは何もしません。</p>
</dd></dl>

<dl class="method">
<dt id="logging.NullHandler.createLock">
<code class="descname">createLock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.NullHandler.createLock" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>アクセスが特殊化される必要がある I/O が下にないので、このメソッドはロックに対して <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。</p>
</dd></dl>

</dd></dl>

<p><a class="reference internal" href="#logging.NullHandler" title="logging.NullHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">NullHandler</span></code></a> の使い方の詳しい情報は、 <a class="reference internal" href="../howto/logging.html#library-config"><span class="std std-ref">ライブラリのためのロギングの設定</span></a> を参照してください。</p>
</div>
<div class="section" id="watchedfilehandler">
<span id="watched-file-handler"></span><h2>WatchedFileHandler<a class="headerlink" href="#watchedfilehandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.WatchedFileHandler" title="logging.handlers.WatchedFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">WatchedFileHandler</span></code></a> クラスは、ログ記録先のファイルを監視する <code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code> の一種です。ファイルが変更された場合、ファイルを閉じてからファイル名を使って開き直します。</p>
<p>ファイルはログファイルをローテーションさせる <em>newsyslog</em> や <em>logrotate</em> のようなプログラムを使うことで変更されることがあります。このハンドラは、 Unix/Linux で使われることを意図していますが、ファイルが最後にログを出力してから変わったかどうかを監視します。 (ファイルはデバイスや inode が変わることで変わったと判断します。) ファイルが変わったら古いファイルのストリームは閉じて、現在のファイルを新しいストリームを取得するために開きます。</p>
<p>このハンドラを Windows で使うことは適切ではありません。というのも Windows では開いているログファイルを移動したり削除したりできないからです - logging はファイルを排他的ロックを掛けて開きます - そのためこうしたハンドラは必要ないのです。さらに、 Windows では <em>ST_INO</em> がサポートされていません; <a class="reference internal" href="os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">stat()</span></code></a> はこの値として常に 0 を返します。</p>
<dl class="class">
<dt id="logging.handlers.WatchedFileHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">WatchedFileHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>mode='a'</em>, <em>encoding=None</em>, <em>delay=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.WatchedFileHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.WatchedFileHandler" title="logging.handlers.WatchedFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">WatchedFileHandler</span></code></a> クラスの新たなインスタンスを返します。
指定されたファイルが開かれ、ログ記録のためのストリームとして使われます。
<em>mode</em> が指定されなかった場合、 <code class="xref py py-const docutils literal notranslate"><span class="pre">'a'</span></code> が使われます。
<em>encoding</em> が <code class="docutils literal notranslate"><span class="pre">None</span></code> でない場合、その値はファイルを開くときのエンコーディングとして使われます。
<em>delay</em> が真ならば、ファイルを開くのは最初の <a class="reference internal" href="#logging.handlers.WatchedFileHandler.emit" title="logging.handlers.WatchedFileHandler.emit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code></a> 呼び出しまで遅らせられます。
デフォルトでは、ファイルは無制限に大きくなりつづけます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>文字列値に加え、 <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> オブジェクトも <em>filename</em> 引数が受け取るようになりました。</p>
</div>
<dl class="method">
<dt id="logging.handlers.WatchedFileHandler.reopenIfNeeded">
<code class="descname">reopenIfNeeded</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.WatchedFileHandler.reopenIfNeeded" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルが変更されていないかチェックします。
もし変更されていれば、手始めにレコードをファイルに出力し、既存のストリームはフラッシュして閉じられ、ファイルが再度開かれます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.WatchedFileHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.WatchedFileHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードをファイルに出力しますが、最初に <a class="reference internal" href="#logging.handlers.WatchedFileHandler.reopenIfNeeded" title="logging.handlers.WatchedFileHandler.reopenIfNeeded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reopenIfNeeded()</span></code></a> を呼び出して、変更があった場合はファイルを再度開きます。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="baserotatinghandler">
<span id="base-rotating-handler"></span><h2>BaseRotatingHandler<a class="headerlink" href="#baserotatinghandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> モジュールに存在する <a class="reference internal" href="#logging.handlers.BaseRotatingHandler" title="logging.handlers.BaseRotatingHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseRotatingHandler</span></code></a> クラスは、ローテートを行うファイルハンドラ <a class="reference internal" href="#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatingFileHandler</span></code></a> と <a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler" title="logging.handlers.TimedRotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimedRotatingFileHandler</span></code></a> のベースクラスです。このクラスをインスタンス化する必要はありませんが、オーバーライドすることになるかもしれない属性とメソッドを持っています。</p>
<dl class="class">
<dt id="logging.handlers.BaseRotatingHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">BaseRotatingHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>mode</em>, <em>encoding=None</em>, <em>delay=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BaseRotatingHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>パラメータは <code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code> と同じです。属性は次の通りです:</p>
<dl class="attribute">
<dt id="logging.handlers.BaseRotatingHandler.namer">
<code class="descname">namer</code><a class="headerlink" href="#logging.handlers.BaseRotatingHandler.namer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この属性に callable がセットされた場合、 <a class="reference internal" href="#logging.handlers.BaseRotatingHandler.rotation_filename" title="logging.handlers.BaseRotatingHandler.rotation_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotation_filename()</span></code></a> メソッドはこの callable に委譲されます。 callable に渡されるパラメータは <a class="reference internal" href="#logging.handlers.BaseRotatingHandler.rotation_filename" title="logging.handlers.BaseRotatingHandler.rotation_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotation_filename()</span></code></a> に渡されたものです。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">namer 関数はロールオーバー中にかなりの回数呼ばれます。そのため、できるだけ単純で、速くあるべきです。さらに、それは与えられた入力に対しては常に同じ出力を返すべきです。そうでなければ、ロールオーバーの振る舞いは期待通りに動かないかもしれません。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="logging.handlers.BaseRotatingHandler.rotator">
<code class="descname">rotator</code><a class="headerlink" href="#logging.handlers.BaseRotatingHandler.rotator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この属性に callable がセットされた場合、 <a class="reference internal" href="#logging.handlers.BaseRotatingHandler.rotate" title="logging.handlers.BaseRotatingHandler.rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate()</span></code></a> メソッドはこの callable に委譲されます。 callable に渡されるパラメータは <a class="reference internal" href="#logging.handlers.BaseRotatingHandler.rotate" title="logging.handlers.BaseRotatingHandler.rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate()</span></code></a> に渡されたものです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.BaseRotatingHandler.rotation_filename">
<code class="descname">rotation_filename</code><span class="sig-paren">(</span><em>default_name</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BaseRotatingHandler.rotation_filename" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ローテートを行う際にログファイルのファイル名を変更します。</p>
<p>このメソッドは、ファイル名をカスタマイズするために提供されます。</p>
<p>デフォルト実装は、ハンドラの 'namer' 属性が callable だった場合、その callable を呼んでデフォルト名を渡します。属性が callable でない場合 (デフォルトは <code class="docutils literal notranslate"><span class="pre">None</span></code> です)、名前は変更せずに返されます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><strong>default_name</strong> -- ログファイルのデフォルトのファイル名。</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.BaseRotatingHandler.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>source</em>, <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BaseRotatingHandler.rotate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ローテートが行われる時、現在のログをローテートします。</p>
<p>デフォルト実装は、 ハンドラの 'rotator' 属性が callable だった場合、その callable を呼んで source と dest 引数を渡します。属性が callable でない場合 (デフォルトは <code class="docutils literal notranslate"><span class="pre">None</span></code> です)、単に source が destination に改名されます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><strong>source</strong> -- ソースファイル名。これは通常ベースファイル名 、例えば 'test.log' となります。</li>
<li><strong>dest</strong> -- 変更先ファイル名。これは通常ソースファイルをローテートしたもの (例えば 'test.log.1') です。</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

</dd></dl>

<p>これらの属性が存在する理由は、サブクラス化を省略できるようにするためです。 <a class="reference internal" href="#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatingFileHandler</span></code></a> と <a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler" title="logging.handlers.TimedRotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimedRotatingFileHandler</span></code></a> のインスタンスに対して同じ callable が使えます。もし namer や rotator callable が例外を上げれば、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code> 呼び出しで発生した他の例外と同じ方法で、つまりハンドラの <code class="xref py py-meth docutils literal notranslate"><span class="pre">handleError()</span></code> メソッドによって扱われます。</p>
<p>ローテート処理に大幅な変更を加える必要があれば、メソッドをオーバーライドすることができます。</p>
<p>例えば、 <a class="reference internal" href="../howto/logging-cookbook.html#cookbook-rotator-namer"><span class="std std-ref">rotator と namer を使ってログローテートをカスタマイズする</span></a> を参照してください。</p>
</div>
<div class="section" id="rotatingfilehandler">
<span id="rotating-file-handler"></span><h2>RotatingFileHandler<a class="headerlink" href="#rotatingfilehandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatingFileHandler</span></code></a> クラスは、ディスク上のログファイルに対するローテーション処理をサポートします。</p>
<dl class="class">
<dt id="logging.handlers.RotatingFileHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">RotatingFileHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>mode='a'</em>, <em>maxBytes=0</em>, <em>backupCount=0</em>, <em>encoding=None</em>, <em>delay=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.RotatingFileHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatingFileHandler</span></code></a> クラスの新たなインスタンスを返します。
指定されたファイルが開かれ、ログ記録のためのストリームとして使われます。
<em>mode</em> が指定されなかった場合、 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> が使われます。
<em>encoding</em> が <code class="docutils literal notranslate"><span class="pre">None</span></code> でない場合、その値はファイルを開くときのエンコーディングとして使われます。
<em>delay</em> が真ならば、ファイルを開くのは最初の <a class="reference internal" href="#logging.handlers.RotatingFileHandler.emit" title="logging.handlers.RotatingFileHandler.emit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code></a> 呼び出しまで遅らせられます。
デフォルトでは、ファイルは無制限に大きくなりつづけます。</p>
<p><em>maxBytes</em> および <em>backupCount</em> 値を指定することで、あらかじめ決められたサイズでファイルをロールオーバ (<em class="dfn">rollover</em>) させることができます。
指定サイズを超えそうになると、ファイルは閉じられ、暗黙のうちに新たなファイルが開かれます。
ロールオーバは現在のログファイルの長さが <em>maxBytes</em> に近くなると常に起きますが、 <em>maxBytes</em> または <em>backupCount</em> がゼロならロールオーバは起きなくなってしまうので、一般的には <em>backupCount</em> を少なくとも 1 に設定し <em>maxBytes</em> を非ゼロにするのが良いでしょう。
<em>backupCount</em> が非ゼロのとき、システムは古いログファイルをファイル名に &quot;.1&quot;, &quot;.2&quot; といった拡張子を追加して保存します。
例えば、 <em>backupCount</em> が 5 で、基本のファイル名が <code class="file docutils literal notranslate"><span class="pre">app.log</span></code> なら、 <code class="file docutils literal notranslate"><span class="pre">app.log</span></code>, <code class="file docutils literal notranslate"><span class="pre">app.log.1</span></code>, <code class="file docutils literal notranslate"><span class="pre">app.log.2</span></code> ... と続き、 <code class="file docutils literal notranslate"><span class="pre">app.log.5</span></code> までを得ることになります。
ログの書き込み対象になるファイルは常に <code class="file docutils literal notranslate"><span class="pre">app.log</span></code> です。このファイルが満杯になると、ファイルは閉じられ、 <code class="file docutils literal notranslate"><span class="pre">app.log.1</span></code> に名前が変更されます。
<code class="file docutils literal notranslate"><span class="pre">app.log.1</span></code>, <code class="file docutils literal notranslate"><span class="pre">app.log.2</span></code> などが存在する場合、それらのファイルはそれぞれ <code class="file docutils literal notranslate"><span class="pre">app.log.2</span></code>, <code class="file docutils literal notranslate"><span class="pre">app.log.3</span></code> といった具合に名前が変更されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>文字列値に加え、 <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> オブジェクトも <em>filename</em> 引数が受け取るようになりました。</p>
</div>
<dl class="method">
<dt id="logging.handlers.RotatingFileHandler.doRollover">
<code class="descname">doRollover</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.RotatingFileHandler.doRollover" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>上述のような方法でロールオーバを行います。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.RotatingFileHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.RotatingFileHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>上述のようなロールオーバを行いながら、レコードをファイルに出力します。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="timedrotatingfilehandler">
<span id="timed-rotating-file-handler"></span><h2>TimedRotatingFileHandler<a class="headerlink" href="#timedrotatingfilehandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler" title="logging.handlers.TimedRotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimedRotatingFileHandler</span></code></a> クラスは、特定の時間間隔でのログローテーションをサポートしています。</p>
<dl class="class">
<dt id="logging.handlers.TimedRotatingFileHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">TimedRotatingFileHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>when='h'</em>, <em>interval=1</em>, <em>backupCount=0</em>, <em>encoding=None</em>, <em>delay=False</em>, <em>utc=False</em>, <em>atTime=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.TimedRotatingFileHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler" title="logging.handlers.TimedRotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimedRotatingFileHandler</span></code></a> クラスの新たなインスタンスを返します。 <em>filename</em> に指定したファイルを開き、ログ出力先のストリームとして使います。ログファイルのローテーション時には、ファイル名に拡張子 (suffix) をつけます。ログファイルのローテーションは <em>when</em> および <em>interval</em> の積に基づいて行います。</p>
<p><em>when</em> は <em>interval</em> の単位を指定するために使います。使える値は下表の通りです。大小文字の区別は行いません。</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="41%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">値</th>
<th class="head"><em>interval</em> の単位</th>
<th class="head"><em>atTime</em> の使用有無/使用方法</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'S'</span></code></td>
<td>秒</td>
<td>無視</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'M'</span></code></td>
<td>分</td>
<td>無視</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'H'</span></code></td>
<td>時間</td>
<td>無視</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'D'</span></code></td>
<td>日</td>
<td>無視</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'W0'-'W6'</span></code></td>
<td>曜日 (0=月曜)</td>
<td>初期のロールオーバー時刻の算出に使用</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'midnight'</span></code></td>
<td><em>atTime</em> が指定されなかった場合は深夜に、そうでない場合は <em>atTime</em> の時刻にロールオーバーされます</td>
<td>初期のロールオーバー時刻の算出に使用</td>
</tr>
</tbody>
</table>
<p>曜日ベースのローテーションを使う場合は、月曜として 'W0' を、火曜として 'W1' を、…、日曜として 'W6' を指定します。このケースの場合は、 <em>interval</em> は使われません。</p>
<p>古いログファイルの保存時、ロギングシステムによりファイル名に拡張子が付けられます。 ロールオーバ間隔によって、strftime の <code class="docutils literal notranslate"><span class="pre">%Y-%m-%d_%H-%M-%S</span></code> 形式またはその前方の一部を使って、日付と時間に基づいた拡張子が付けられます。</p>
<p>最初に次のロールオーバー時間を計算するとき (ハンドラが生成されるとき)、次のローテーションがいつ起こるかを計算するために、既存のログファイルの最終変更時刻または現在の時間が使用されます。</p>
<p><em>utc</em> 引数が true の場合時刻は UTC になり、それ以外では現地時間が使われます。</p>
<p><em>backupCount</em> がゼロでない場合、保存されるファイル数は高々 <em>backupCount</em> 個で、それ以上のファイルがロールオーバされる時に作られるならば、一番古いものが削除されます。削除のロジックは interval で決まるファイルを削除するので、 interval を変えると古いファイルが残ったままになることもあります。</p>
<p><em>delay</em> が true なら、ファイルを開くのは <a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler.emit" title="logging.handlers.TimedRotatingFileHandler.emit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code></a> の最初の呼び出しまで延期されます。</p>
<p>If <em>atTime</em> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, it must be a <code class="docutils literal notranslate"><span class="pre">datetime.time</span></code> instance which
specifies the time of day when rollover occurs, for the cases where rollover
is set to happen &quot;at midnight&quot; or &quot;on a particular weekday&quot;. Note that in
these cases, the <em>atTime</em> value is effectively used to compute the <em>initial</em>
rollover, and subsequent rollovers would be calculated via the normal
interval calculation.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Calculation of the initial rollover time is done when the handler
is initialised. Calculation of subsequent rollover times is done only
when rollover occurs, and rollover occurs only when emitting output. If
this is not kept in mind, it might lead to some confusion. For example,
if an interval of &quot;every minute&quot; is set, that does not mean you will
always see log files with times (in the filename) separated by a minute;
if, during application execution, logging output is generated more
frequently than once a minute, <em>then</em> you can expect to see log files
with times separated by a minute. If, on the other hand, logging messages
are only output once every five minutes (say), then there will be gaps in
the file times corresponding to the minutes where no output (and hence no
rollover) occurred.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><em>atTime</em> パラメータが追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>文字列値に加え、 <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> オブジェクトも <em>filename</em> 引数が受け取るようになりました。</p>
</div>
<dl class="method">
<dt id="logging.handlers.TimedRotatingFileHandler.doRollover">
<code class="descname">doRollover</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.TimedRotatingFileHandler.doRollover" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>上述のような方法でロールオーバを行います。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.TimedRotatingFileHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.TimedRotatingFileHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>上で説明した方法でロールオーバを行いながら、レコードをファイルに出力します。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sockethandler">
<span id="socket-handler"></span><h2>SocketHandler<a class="headerlink" href="#sockethandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketHandler</span></code></a> クラスは、ログ出力をネットワークソケットに送信します。基底クラスでは TCP ソケットを用います。</p>
<dl class="class">
<dt id="logging.handlers.SocketHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">SocketHandler</code><span class="sig-paren">(</span><em>host</em>, <em>port</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>アドレスが <em>host</em> および <em>port</em> で与えられた遠隔のマシンと通信するようにした <a class="reference internal" href="#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketHandler</span></code></a> クラスのインスタンスを生成して返します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><code class="docutils literal notranslate"><span class="pre">port</span></code> に <code class="docutils literal notranslate"><span class="pre">None</span></code> を指定すると、Unix ドメインソケットが <code class="docutils literal notranslate"><span class="pre">host</span></code> 値を用いて作られます - そうでない場合は TCP ソケットが作られます。</p>
</div>
<dl class="method">
<dt id="logging.handlers.SocketHandler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットを閉じます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードの属性辞書を pickle して、バイナリ形式でソケットに書き込みます。ソケット操作でエラーが生じた場合、暗黙のうちにパケットは捨てられます。事前に接続が失われていた場合、接続を再度確立します。受信端でレコードを unpickle して <a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> にするには、 <a class="reference internal" href="logging.html#logging.makeLogRecord" title="logging.makeLogRecord"><code class="xref py py-func docutils literal notranslate"><span class="pre">makeLogRecord()</span></code></a> 関数を使ってください。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.handleError">
<code class="descname">handleError</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.handleError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.SocketHandler.emit" title="logging.handlers.SocketHandler.emit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code></a> の処理中に発生したエラーを処理します。よくある原因は接続の消失です。次のイベント発生時に再試行できるようにソケットを閉じます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.makeSocket">
<code class="descname">makeSocket</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.makeSocket" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サブクラスで必要なソケット形式を詳細に定義できるようにするためのファクトリメソッドです。デフォルトの実装では、 TCP ソケット (<a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_STREAM</span></code></a>) を生成します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.makePickle">
<code class="descname">makePickle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.makePickle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードの属性辞書をバイナリ形式に pickle したものの先頭に長さ情報を付け、ソケットを介して送信できるようにして返します。
この操作の詳細は次のコードと同等です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">record_attr_dict</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">datalen</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&gt;L&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="k">return</span> <span class="n">datalen</span> <span class="o">+</span> <span class="n">data</span>
</pre></div>
</div>
<p>pickle が完全に安全というわけではないことに注意してください。セキュリティに関して心配なら、より安全なメカニズムを実装するためにこのメソッドをオーバーライドすると良いでしょう。例えば、 HMAC を使って pickle に署名して、受け取る側ではそれを検証することができます。あるいはまた、受け取る側でグローバルなオブジェクトの unpickle を無効にすることができます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.send">
<code class="descname">send</code><span class="sig-paren">(</span><em>packet</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.send" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>pickle したバイト文字列 <em>packet</em> をソケットに送信します。
送信するバイト文字列のフォーマットは、 <a class="reference internal" href="#logging.handlers.SocketHandler.makePickle" title="logging.handlers.SocketHandler.makePickle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makePickle()</span></code></a> のドキュメントで解説されています。</p>
<p>この関数はネットワークがビジーの時に発生する部分的送信に対応しています。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.createSocket">
<code class="descname">createSocket</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.createSocket" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットの生成を試みます。失敗時には、指数的な減速アルゴリズムを使います。最初の失敗時には、ハンドラは送ろうとしていたメッセージを落とします。続くメッセージが同じインスタンスで扱われたとき、幾らかの時間が経過するまで接続を試みません。デフォルトのパラメタは、最初の遅延時間が 1 秒で、その遅延時間の後でそれでも接続が確保できないなら、遅延時間は 2 倍づつになり、最大で 30 秒になります。</p>
<p>この働きは、以下のハンドラ属性で制御されます:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">retryStart</span></code> (最初の遅延時間、デフォルトは 1.0 秒)。</li>
<li><code class="docutils literal notranslate"><span class="pre">retryFactor</span></code> (乗数、デフォルトは 2.0)。</li>
<li><code class="docutils literal notranslate"><span class="pre">retryMax</span></code> (最大遅延時間、デフォルトは 30.0 秒)。</li>
</ul>
<p>つまり、ハンドラが使われた <em>後に</em> リモートリスナが起動した場合、メッセージが失われてしまうことがあります (ハンドラは、遅延時間が経過するまで接続を試みようとさえせず、その遅延時間中に通知なくメッセージを捨てるので)。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="datagramhandler">
<span id="datagram-handler"></span><h2>DatagramHandler<a class="headerlink" href="#datagramhandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.DatagramHandler" title="logging.handlers.DatagramHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">DatagramHandler</span></code></a> クラスは、 <a class="reference internal" href="#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketHandler</span></code></a> を継承しており、 UDP ソケットを介したログ記録メッセージの送信をサポートしています。</p>
<dl class="class">
<dt id="logging.handlers.DatagramHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">DatagramHandler</code><span class="sig-paren">(</span><em>host</em>, <em>port</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.DatagramHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>アドレスが <em>host</em> および <em>port</em> で与えられた遠隔のマシンと通信するようにした <a class="reference internal" href="#logging.handlers.DatagramHandler" title="logging.handlers.DatagramHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">DatagramHandler</span></code></a> クラスのインスタンスを生成して返します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><code class="docutils literal notranslate"><span class="pre">port</span></code> に <code class="docutils literal notranslate"><span class="pre">None</span></code> を指定すると、Unix ドメインソケットが <code class="docutils literal notranslate"><span class="pre">host</span></code> 値を用いて作られます - そうでない場合は UDP ソケットが作られます。</p>
</div>
<dl class="method">
<dt id="logging.handlers.DatagramHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.DatagramHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードの属性辞書を pickle して、バイナリ形式でソケットに書き込みます。ソケット操作でエラーが生じた場合、暗黙のうちにパケットは捨てられます。事前に接続が失われていた場合、接続を再度確立します。受信端でレコードを unpickle して <a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> にするには、 <a class="reference internal" href="logging.html#logging.makeLogRecord" title="logging.makeLogRecord"><code class="xref py py-func docutils literal notranslate"><span class="pre">makeLogRecord()</span></code></a> 関数を使ってください。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.DatagramHandler.makeSocket">
<code class="descname">makeSocket</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.DatagramHandler.makeSocket" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ここで <a class="reference internal" href="#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketHandler</span></code></a> のファクトリメソッドをオーバライドして、 UDP ソケット (<a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_DGRAM</span></code></a>) を生成しています。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.DatagramHandler.send">
<code class="descname">send</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.DatagramHandler.send" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>pickle したバイト文字列をソケットに送信します。
送信するバイト文字列のフォーマットは、 <a class="reference internal" href="#logging.handlers.SocketHandler.makePickle" title="logging.handlers.SocketHandler.makePickle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SocketHandler.makePickle()</span></code></a> のドキュメントで解説されています。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sysloghandler">
<span id="syslog-handler"></span><h2>SysLogHandler<a class="headerlink" href="#sysloghandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SysLogHandler</span></code></a> クラスは、ログ記録メッセージを遠隔またはローカルの Unix syslog に送信する機能をサポートしています。</p>
<dl class="class">
<dt id="logging.handlers.SysLogHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">SysLogHandler</code><span class="sig-paren">(</span><em>address=('localhost'</em>, <em>SYSLOG_UDP_PORT)</em>, <em>facility=LOG_USER</em>, <em>socktype=socket.SOCK_DGRAM</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SysLogHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>遠隔の Unix マシンと通信するための、 <a class="reference internal" href="#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SysLogHandler</span></code></a> クラスの新たなインスタンスを返します。マシンのアドレスは <code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">port)</span></code> のタプル形式をとる <em>address</em> で与えられます。 <em>address</em> が指定されない場合、 <code class="docutils literal notranslate"><span class="pre">('localhost',</span> <span class="pre">514)</span></code> が使われます。アドレスは UDP ソケットを使って開かれます。 <code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">port)</span></code> のタプル形式の代わりに文字列で &quot;/dev/log&quot; のように与えることもできます。この場合、 Unix ドメインソケットが syslog にメッセージを送るのに使われます。 <em>facility</em> が指定されない場合、 <code class="xref py py-const docutils literal notranslate"><span class="pre">LOG_USER</span></code> が使われます。開かれるソケットの型は、 <em>socktype</em> 引数に依り、デフォルトは <a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_DGRAM</span></code></a> で、UDP ソケットを開きます。 (rsyslog のような新しい syslog デーモンと使うために) TCP ソケットを開くには、 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_STREAM</span></code></a> の値を指定してください。</p>
<p>使用中のサーバが UDP ポート 514 を待機していない場合、 <a class="reference internal" href="#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SysLogHandler</span></code></a> が正常に動作していないように見える場合があります。その場合、ドメインソケットに使うべきアドレスを調べてください。そのアドレスはシステムによって異なります。例えば、Linux システムでは通常 '/dev/log' ですが、 OS X では '/var/run/syslog' です。プラットフォームを確認し、適切なアドレスを使う必要があります (アプリケーションを複数のプラットフォーム上で動作させる必要がある場合、実行時に確認する必要があるかもしれません)。Windows では、多くの場合、UDP オプションを使用する必要があります。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><em>socktype</em> が追加されました。</p>
</div>
<dl class="method">
<dt id="logging.handlers.SysLogHandler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SysLogHandler.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>遠隔ホストへのソケットを閉じます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SysLogHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SysLogHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードは書式化された後、 syslog サーバに送信されます。例外情報が存在しても、サーバには <em>送信されません</em> 。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2.1 で変更: </span>(参照: <a class="reference external" href="https://bugs.python.org/issue12168">bpo-12168</a>) 初期のバージョンでは、 syslog デーモンに送られるメッセージは常に NUL バイトで終端していました。初期のバージョンの syslog デーモンが NUL 終端されたメッセージを期待していたからです - たとえ、それが適切な仕様 (<span class="target" id="index-2"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5424.html"><strong>RFC 5424</strong></a>) にはなかったとしても。 syslog デーモンの新しいバージョンは NUL バイトを期待せず、代わりにもしそれがある場合は削除します。さらに、より最近のデーモン (RFC 5424 により忠実なバージョン) は、メッセージの一部として NUL バイトを通します。</p>
<p>このような異なるデーモンの振る舞いすべてに対して syslog メッセージの取り扱いをより容易にするため、 NUL バイトの追加はクラスレベル属性 <code class="docutils literal notranslate"><span class="pre">append_nul</span></code> を使用して設定できるようになりました。これはデフォルトで <code class="docutils literal notranslate"><span class="pre">True</span></code> (既存の振る舞いを保持) ですが、 <code class="docutils literal notranslate"><span class="pre">SysLogHandler</span></code> インスタンスが NUL 終端文字を追加 <em>しない</em> ように <code class="docutils literal notranslate"><span class="pre">False</span></code> にセットすることができます。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>(参照: <a class="reference external" href="https://bugs.python.org/issue12419">bpo-12419</a>) 以前のバージョンでは、メッセージソースを識別するための &quot;ident&quot; あるいは &quot;tag&quot; プリフィックス機能はありませんでした。これは、今ではクラスレベル属性を使用して指定することができるようになりました。デフォルトでは既存の振る舞いを保持するために <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> ですが、特定の <code class="docutils literal notranslate"><span class="pre">SysLogHandler</span></code> インスタンスが扱うすべてのメッセージに識別子を前置するようにそれをオーバーライドすることができます。識別子はバイトではなくテキストでなければならず、正確にそのままメッセージに前置されることに注意してください。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SysLogHandler.encodePriority">
<code class="descname">encodePriority</code><span class="sig-paren">(</span><em>facility</em>, <em>priority</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SysLogHandler.encodePriority" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファシリティおよび優先度を整数に符号化します。値は文字列でも整数でも渡すことができます。文字列が渡された場合、内部の対応付け辞書が使われ、整数に変換されます。</p>
<p>シンボリックな <code class="docutils literal notranslate"><span class="pre">LOG_</span></code> 値は <a class="reference internal" href="#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SysLogHandler</span></code></a> で定義されています。これは <code class="docutils literal notranslate"><span class="pre">sys/syslog.h</span></code> ヘッダーファイルで定義された値を反映しています。</p>
<p><strong>優先度</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="37%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">名前 (文字列)</th>
<th class="head">シンボル値</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">alert</span></code></td>
<td>LOG_ALERT</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">crit</span></code> or <code class="docutils literal notranslate"><span class="pre">critical</span></code></td>
<td>LOG_CRIT</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">debug</span></code></td>
<td>LOG_DEBUG</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">emerg</span></code> or <code class="docutils literal notranslate"><span class="pre">panic</span></code></td>
<td>LOG_EMERG</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">err</span></code> or <code class="docutils literal notranslate"><span class="pre">error</span></code></td>
<td>LOG_ERR</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">info</span></code></td>
<td>LOG_INFO</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">notice</span></code></td>
<td>LOG_NOTICE</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">warn</span></code> or <code class="docutils literal notranslate"><span class="pre">warning</span></code></td>
<td>LOG_WARNING</td>
</tr>
</tbody>
</table>
<p><strong>ファシリティ</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">名前 (文字列)</th>
<th class="head">シンボル値</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">auth</span></code></td>
<td>LOG_AUTH</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">authpriv</span></code></td>
<td>LOG_AUTHPRIV</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">cron</span></code></td>
<td>LOG_CRON</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">daemon</span></code></td>
<td>LOG_DAEMON</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">ftp</span></code></td>
<td>LOG_FTP</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">kern</span></code></td>
<td>LOG_KERN</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">lpr</span></code></td>
<td>LOG_LPR</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">mail</span></code></td>
<td>LOG_MAIL</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">news</span></code></td>
<td>LOG_NEWS</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">syslog</span></code></td>
<td>LOG_SYSLOG</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">user</span></code></td>
<td>LOG_USER</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">uucp</span></code></td>
<td>LOG_UUCP</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">local0</span></code></td>
<td>LOG_LOCAL0</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">local1</span></code></td>
<td>LOG_LOCAL1</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">local2</span></code></td>
<td>LOG_LOCAL2</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">local3</span></code></td>
<td>LOG_LOCAL3</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">local4</span></code></td>
<td>LOG_LOCAL4</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">local5</span></code></td>
<td>LOG_LOCAL5</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">local6</span></code></td>
<td>LOG_LOCAL6</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">local7</span></code></td>
<td>LOG_LOCAL7</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SysLogHandler.mapPriority">
<code class="descname">mapPriority</code><span class="sig-paren">(</span><em>levelname</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SysLogHandler.mapPriority" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ログレベル名を syslog 優先度名に対応付けます。カスタムレベルを使用している場合や、デフォルトアルゴリズムがニーズに適していない場合には、このメソッドをオーバーライドする必要があるかもしれません。デフォルトアルゴリズムは、 <code class="docutils literal notranslate"><span class="pre">DEBUG</span></code>, <code class="docutils literal notranslate"><span class="pre">INFO</span></code>, <code class="docutils literal notranslate"><span class="pre">WARNING</span></code>, <code class="docutils literal notranslate"><span class="pre">ERROR</span></code>, <code class="docutils literal notranslate"><span class="pre">CRITICAL</span></code> を等価な syslog 名に、他のすべてのレベル名を &quot;warning&quot; に対応付けます。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="nteventloghandler">
<span id="nt-eventlog-handler"></span><h2>NTEventLogHandler<a class="headerlink" href="#nteventloghandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.NTEventLogHandler" title="logging.handlers.NTEventLogHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">NTEventLogHandler</span></code></a> クラスは、ログ記録メッセージをローカルな Windows NT, Windows 2000, または Windows XP のイベントログに送信する機能をサポートします。この機能を使えるようにするには、 Mark Hammond による Python 用 Win32 拡張パッケージをインストールする必要があります。</p>
<dl class="class">
<dt id="logging.handlers.NTEventLogHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">NTEventLogHandler</code><span class="sig-paren">(</span><em>appname</em>, <em>dllname=None</em>, <em>logtype='Application'</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.NTEventLogHandler" title="logging.handlers.NTEventLogHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">NTEventLogHandler</span></code></a> クラスの新たなインスタンスを返します。 <em>appname</em> はイベントログに表示する際のアプリケーション名を定義するために使われます。この名前を使って適切なレジストリエントリが生成されます。 <em>dllname</em> はログに保存するメッセージ定義の入った .dll または .exe ファイルへの完全修飾パス名を与えなければなりません (指定されない場合、 <code class="docutils literal notranslate"><span class="pre">'win32service.pyd'</span></code> が使われます - このライブラリは Win32 拡張とともにインストールされ、いくつかのプレースホルダとなるメッセージ定義を含んでいます)。これらのプレースホルダを利用すると、メッセージの発信源全体がログに記録されるため、イベントログは巨大になるので注意してください。 <em>logtype</em> は <code class="docutils literal notranslate"><span class="pre">'Application'</span></code>, <code class="docutils literal notranslate"><span class="pre">'System'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Security'</span></code> のいずれかで、デフォルトは <code class="docutils literal notranslate"><span class="pre">'Application'</span></code> です。</p>
<dl class="method">
<dt id="logging.handlers.NTEventLogHandler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現時点では、イベントログエントリの発信源としてのアプリケーション名をレジストリから除去することはできます。しかしこれを行うと、イベントログビューアで意図した通りにログが見えなくなるでしょう - これはイベントログが .dll 名を取得するためにレジストリにアクセスできなければならないからです。現在のバージョンではこの操作を行いません。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.NTEventLogHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージ ID、イベントカテゴリ、イベント型を決定し、メッセージを NT イベントログに記録します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.NTEventLogHandler.getEventCategory">
<code class="descname">getEventCategory</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler.getEventCategory" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードに対するイベントカテゴリを返します。自作のカテゴリを指定したい場合、このメソッドをオーバライドしてください。このクラスのバージョンのメソッドは 0 を返します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.NTEventLogHandler.getEventType">
<code class="descname">getEventType</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler.getEventType" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードのイベント型を返します。自作の型を指定したい場合、このメソッドをオーバライドしてください。このクラスのバージョンのメソッドは、ハンドラの <em>typemap</em> 属性を使って対応付けを行います。この属性は <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> で初期化され、 <code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code> が入っています。自作のレベルを使っているのなら、このメソッドをオーバライドするか、ハンドラの <em>typemap</em> 属性に適切な辞書を配置する必要があるでしょう。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.NTEventLogHandler.getMessageID">
<code class="descname">getMessageID</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler.getMessageID" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードのメッセージ ID を返します。自作のメッセージを使っているのなら、ロガーに渡される <em>msg</em> を書式化文字列ではなく ID にします。その上で、辞書参照を行ってメッセージ ID を得ます。このクラスのバージョンでは 1 を返します。この値は <code class="file docutils literal notranslate"><span class="pre">win32service.pyd</span></code> における基本メッセージ ID です。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="smtphandler">
<span id="smtp-handler"></span><h2>SMTPHandler<a class="headerlink" href="#smtphandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.SMTPHandler" title="logging.handlers.SMTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTPHandler</span></code></a> クラスは、 SMTP を介したログ記録メッセージの送信機能をサポートします。</p>
<dl class="class">
<dt id="logging.handlers.SMTPHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">SMTPHandler</code><span class="sig-paren">(</span><em>mailhost</em>, <em>fromaddr</em>, <em>toaddrs</em>, <em>subject</em>, <em>credentials=None</em>, <em>secure=None</em>, <em>timeout=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SMTPHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新たな <a class="reference internal" href="#logging.handlers.SMTPHandler" title="logging.handlers.SMTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTPHandler</span></code></a> クラスのインスタンスを返します。インスタンスは email の from および to アドレス行、および subject 行とともに初期化されます。 <em>toaddrs</em> は文字列からなるリストでなければなりません。非標準の SMTP ポートを指定するには、 <em>mailhost</em> 引数に (host, port) のタプル形式を指定します。文字列を使った場合、標準の SMTP ポートが使われます。もし SMTP サーバが認証を必要とするならば、 (username, password) のタプル形式を <em>credentials</em> 引数に指定することができます。</p>
<p>セキュアプロトコル (TLS) の使用を指定するには <em>secure</em> 引数にタプルを渡してください。これは認証情報が渡された場合のみ使用されます。タプルは、空のタプルか、キーファイルの名前を持つ1要素のタプルか、またはキーファイルと証明書ファイルの名前を持つ2要素のタプルのいずれかでなければなりません。 (このタプルは <a class="reference internal" href="smtplib.html#smtplib.SMTP.starttls" title="smtplib.SMTP.starttls"><code class="xref py py-meth docutils literal notranslate"><span class="pre">smtplib.SMTP.starttls()</span></code></a> メソッドに渡されます。)</p>
<p>SMTP サーバとのコミュニケーションのために、 <em>timeout</em> 引数を使用してタイムアウトを指定することができます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加: </span><em>timeout</em> 引数が追加されました。</p>
</div>
<dl class="method">
<dt id="logging.handlers.SMTPHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SMTPHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードを書式化し、指定されたアドレスに送信します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SMTPHandler.getSubject">
<code class="descname">getSubject</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SMTPHandler.getSubject" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードに応じたサブジェクト行を指定したいなら、このメソッドをオーバライドしてください。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="memoryhandler">
<span id="memory-handler"></span><h2>MemoryHandler<a class="headerlink" href="#memoryhandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryHandler</span></code></a> は、ログ記録するレコードをメモリ上にバッファリングし、定期的にその内容をターゲット (<em class="dfn">target</em>) となるハンドラにフラッシュする機能をサポートしています。フラッシュ処理はバッファが一杯になるか、ある深刻度かそれ以上のレベルを持つイベントが観測された際に行われます。</p>
<p><a class="reference internal" href="#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryHandler</span></code></a> はより一般的な抽象クラス、 <a class="reference internal" href="#logging.handlers.BufferingHandler" title="logging.handlers.BufferingHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferingHandler</span></code></a> のサブクラスです。この抽象クラスでは、ログ記録するレコードをメモリ上にバッファリングします。各レコードがバッファに追加される毎に、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">shouldFlush()</span></code> を呼び出してバッファをフラッシュすべきかどうか調べます。フラッシュする必要がある場合、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">flush()</span></code> がフラッシュ処理を行うものと想定されます。</p>
<dl class="class">
<dt id="logging.handlers.BufferingHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">BufferingHandler</code><span class="sig-paren">(</span><em>capacity</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BufferingHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Initializes the handler with a buffer of the specified capacity. Here,
<em>capacity</em> means the number of logging records buffered.</p>
<dl class="method">
<dt id="logging.handlers.BufferingHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BufferingHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Append the record to the buffer. If <a class="reference internal" href="#logging.handlers.BufferingHandler.shouldFlush" title="logging.handlers.BufferingHandler.shouldFlush"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shouldFlush()</span></code></a> returns true,
call <a class="reference internal" href="#logging.handlers.BufferingHandler.flush" title="logging.handlers.BufferingHandler.flush"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flush()</span></code></a> to process the buffer.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.BufferingHandler.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BufferingHandler.flush" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドをオーバライドして、自作のフラッシュ動作を実装することができます。このクラスのバージョンのメソッドでは、単にバッファの内容を削除して空にします。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.BufferingHandler.shouldFlush">
<code class="descname">shouldFlush</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BufferingHandler.shouldFlush" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the buffer is up to capacity. This method can be
overridden to implement custom flushing strategies.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="logging.handlers.MemoryHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">MemoryHandler</code><span class="sig-paren">(</span><em>capacity</em>, <em>flushLevel=ERROR</em>, <em>target=None</em>, <em>flushOnClose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.MemoryHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns a new instance of the <a class="reference internal" href="#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryHandler</span></code></a> class. The instance is
initialized with a buffer size of <em>capacity</em> (number of records buffered).
If <em>flushLevel</em> is not specified, <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code> is used. If no <em>target</em> is
specified, the target will need to be set using <a class="reference internal" href="#logging.handlers.MemoryHandler.setTarget" title="logging.handlers.MemoryHandler.setTarget"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setTarget()</span></code></a> before this
handler does anything useful. If <em>flushOnClose</em> is specified as <code class="docutils literal notranslate"><span class="pre">False</span></code>,
then the buffer is <em>not</em> flushed when the handler is closed. If not specified
or specified as <code class="docutils literal notranslate"><span class="pre">True</span></code>, the previous behaviour of flushing the buffer will
occur when the handler is closed.</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span><em>flushOnClose</em> パラメータが追加されました。</p>
</div>
<dl class="method">
<dt id="logging.handlers.MemoryHandler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.MemoryHandler.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.MemoryHandler.flush" title="logging.handlers.MemoryHandler.flush"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flush()</span></code></a> を呼び出し、ターゲットを <code class="docutils literal notranslate"><span class="pre">None</span></code> に設定してバッファを消去します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.MemoryHandler.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.MemoryHandler.flush" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryHandler</span></code></a> の場合、フラッシュ処理は単に、バッファされたレコードをターゲットがあれば送信することを意味します。これと異なる動作を行いたい場合、オーバライドしてください。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.MemoryHandler.setTarget">
<code class="descname">setTarget</code><span class="sig-paren">(</span><em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.MemoryHandler.setTarget" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ターゲットハンドラをこのハンドラに設定します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.MemoryHandler.shouldFlush">
<code class="descname">shouldFlush</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.MemoryHandler.shouldFlush" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バッファが一杯になっているか、 <em>flushLevel</em> またはそれ以上のレコードでないかを調べます。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="httphandler">
<span id="http-handler"></span><h2>HTTPHandler<a class="headerlink" href="#httphandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.HTTPHandler" title="logging.handlers.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a> クラスは、ログ記録メッセージを <code class="docutils literal notranslate"><span class="pre">GET</span></code> または <code class="docutils literal notranslate"><span class="pre">POST</span></code> セマンティクスを使って Web サーバに送信する機能をサポートしています。</p>
<dl class="class">
<dt id="logging.handlers.HTTPHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">HTTPHandler</code><span class="sig-paren">(</span><em>host</em>, <em>url</em>, <em>method='GET'</em>, <em>secure=False</em>, <em>credentials=None</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.HTTPHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.HTTPHandler" title="logging.handlers.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a> クラスの新たなインスタンスを返します。特別なポートを使う必要がある場合、<em>host</em> は <code class="docutils literal notranslate"><span class="pre">host:port</span></code> の形式で使うことができます。 <em>method</em> が指定されない場合、 <code class="docutils literal notranslate"><span class="pre">GET</span></code> が使われます。 <em>secure</em> が真の場合、HTTPS 接続が使われます。 HTTPS 接続で使用する SSL 設定のために <em>context</em> 引数を <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> のインスタンスに設定することができます。 <em>credentials</em> を指定する場合、BASIC 認証の際の HTTP 'Authorization' ヘッダに使われるユーザIDとパスワードからなる 2要素タプルを渡してください。 credentials を指定する場合、ユーザIDとパスワードが通信中に平文として剥き出しにならないよう、secure=True も指定すべきです。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span><em>context</em> パラメータが追加されました。</p>
</div>
<dl class="method">
<dt id="logging.handlers.HTTPHandler.mapLogRecord">
<code class="descname">mapLogRecord</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.HTTPHandler.mapLogRecord" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>URL エンコードされて Web サーバに送信することになる、 <code class="docutils literal notranslate"><span class="pre">record</span></code> に基づく辞書を供給します。デフォルトの実装では単に <code class="docutils literal notranslate"><span class="pre">record.__dict__</span></code> を返します。例えば <a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> のサブセットのみを Web サーバに送信する場合や、 サーバーに送信する内容を特別にカスタマイズする必要がある場合には、このメソッドをオーバライドできます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.HTTPHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.HTTPHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードを URL エンコードされた辞書形式で Web サーバに送信します。レコードを送信のために辞書に変換するために <a class="reference internal" href="#logging.handlers.HTTPHandler.mapLogRecord" title="logging.handlers.HTTPHandler.mapLogRecord"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mapLogRecord()</span></code></a> が呼び出されます。</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Web server に送信するためのレコードを準備することは一般的な書式化操作とは同じではありませんので、 <a class="reference internal" href="logging.html#logging.Handler.setFormatter" title="logging.Handler.setFormatter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setFormatter()</span></code></a> を使って <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> を指定することは、 <a class="reference internal" href="#logging.handlers.HTTPHandler" title="logging.handlers.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a> には効果はありません。 <a class="reference internal" href="logging.html#logging.Handler.format" title="logging.Handler.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">format()</span></code></a> を呼び出す代わりに、このハンドラは <a class="reference internal" href="#logging.handlers.HTTPHandler.mapLogRecord" title="logging.handlers.HTTPHandler.mapLogRecord"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mapLogRecord()</span></code></a> を呼び出し、その後その返却辞書を Web server に送信するのに適した様式にエンコードするために <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a>  を呼び出します。</p>
</div>
</dd></dl>

</div>
<div class="section" id="queuehandler">
<span id="queue-handler"></span><h2>QueueHandler<a class="headerlink" href="#queuehandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueHandler</span></code></a> クラスは、 <a class="reference internal" href="queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">queue</span></code></a> モジュールや <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> のモジュールで実装されるようなキューにログメッセージを送信する機能をサポートしています。</p>
<p><a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueListener</span></code></a> クラスとともに <a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueHandler</span></code></a> を使うと、ロギングを行うスレッドから分離されたスレッド上でハンドラを動かすことができます。これは、クライアントに対してサービスするスレッドができるだけ速く応答する必要がある一方、別のスレッド上で (<a class="reference internal" href="#logging.handlers.SMTPHandler" title="logging.handlers.SMTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTPHandler</span></code></a> によって電子メールを送信するような) 潜在的に遅い操作が行われるような、ウェブアプリケーションおよびその他のサービスアプリケーションにおいて重要です。</p>
<dl class="class">
<dt id="logging.handlers.QueueHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">QueueHandler</code><span class="sig-paren">(</span><em>queue</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns a new instance of the <a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueHandler</span></code></a> class. The instance is
initialized with the queue to send messages to. The <em>queue</em> can be any
queue-like object; it's used as-is by the <a class="reference internal" href="#logging.handlers.QueueHandler.enqueue" title="logging.handlers.QueueHandler.enqueue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">enqueue()</span></code></a> method, which
needs to know how to send messages to it. The queue is not <em>required</em> to
have the task tracking API, which means that you can use
<a class="reference internal" href="queue.html#queue.SimpleQueue" title="queue.SimpleQueue"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleQueue</span></code></a> instances for <em>queue</em>.</p>
<dl class="method">
<dt id="logging.handlers.QueueHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Enqueues the result of preparing the LogRecord. Should an exception
occur (e.g. because a bounded queue has filled up), the
<a class="reference internal" href="logging.html#logging.Handler.handleError" title="logging.Handler.handleError"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handleError()</span></code></a> method is called to handle the
error. This can result in the record silently being dropped (if
<code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.raiseExceptions</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>) or a message printed to
<code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> (if <code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.raiseExceptions</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>).</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueHandler.prepare">
<code class="descname">prepare</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueHandler.prepare" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キューに追加するためレコードを準備します。このメソッドが返したオブジェクトがキューに追加されます。</p>
<p>メッセージと、引数と、もしあれば例外の情報を合成するためにレコードを書式化して、レコードから pickle 不可能なアイテムを in-place で取り除くベース実装です。</p>
<p>レコードを dict や JSON 文字列に変換したい場合や、オリジナルのレコードを変更せずに修正済のコピーを送りたい場合は、このメソッドをオーバーライドすると良いでしょう。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueHandler.enqueue">
<code class="descname">enqueue</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueHandler.enqueue" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キューにレコードを  <code class="docutils literal notranslate"><span class="pre">put_nowait()</span></code> を使ってエンキューします; ブロッキングやタイムアウト、あるいはなにか特別なキューの実装を使いたければ、これをオーバライドしてみてください。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="queuelistener">
<span id="queue-listener"></span><h2>QueueListener<a class="headerlink" href="#queuelistener" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueListener</span></code></a> クラスは、 <a class="reference internal" href="queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">queue</span></code></a> モジュールや <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> のモジュールで実装されるようなキューからログメッセージを受信する機能をサポートしています。メッセージは内部スレッドのキューから受信され、同じスレッド上の複数のハンドラに渡されて処理されます。 <a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueListener</span></code></a> それ自体はハンドラではありませんが、 <a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueHandler</span></code></a> と連携して動作するのでここで文書化されています。</p>
<p><a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueHandler</span></code></a> クラスとともに <a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueListener</span></code></a> を使うと、ロギングを行うスレッドから分離されたスレッド上でハンドラを動かすことができます。これは、クライアントに対してサービスするスレッドができるだけ速く応答する必要がある一方、別のスレッド上で (<a class="reference internal" href="#logging.handlers.SMTPHandler" title="logging.handlers.SMTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTPHandler</span></code></a> によって電子メールを送信するような) 潜在的に遅い操作が行われるような、ウェブアプリケーションおよびその他のサービスアプリケーションにおいて重要です。</p>
<dl class="class">
<dt id="logging.handlers.QueueListener">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">QueueListener</code><span class="sig-paren">(</span><em>queue</em>, <em>*handlers</em>, <em>respect_handler_level=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns a new instance of the <a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueListener</span></code></a> class. The instance is
initialized with the queue to send messages to and a list of handlers which
will handle entries placed on the queue. The queue can be any queue-like
object; it's passed as-is to the <a class="reference internal" href="#logging.handlers.QueueListener.dequeue" title="logging.handlers.QueueListener.dequeue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dequeue()</span></code></a> method, which needs
to know how to get messages from it. The queue is not <em>required</em> to have the
task tracking API (though it's used if available), which means that you can
use <a class="reference internal" href="queue.html#queue.SimpleQueue" title="queue.SimpleQueue"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleQueue</span></code></a> instances for <em>queue</em>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">respect_handler_level</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, a handler's level is respected
(compared with the level for the message) when deciding whether to pass
messages to that handler; otherwise, the behaviour is as in previous Python
versions - to always pass each message to each handler.</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>The <code class="docutils literal notranslate"><span class="pre">respect_handler_level</span></code> argument was added.</p>
</div>
<dl class="method">
<dt id="logging.handlers.QueueListener.dequeue">
<code class="descname">dequeue</code><span class="sig-paren">(</span><em>block</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.dequeue" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キューからレコードを取り除き、それを返します。ブロッキングすることがあります。</p>
<p>ベース実装は <code class="docutils literal notranslate"><span class="pre">get()</span></code> を使用します。タイムアウトを有効にしたい場合や、カスタムのキュー実装を使いたい場合は、このメソッドをオーバーライドすると良いでしょう。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueListener.prepare">
<code class="descname">prepare</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.prepare" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードを扱うための準備をします。</p>
<p>この実装は渡されたレコードをそのまま返します。その値をハンドラに渡す前に何らかのカスタムな整列化 (marshalling) あるいはレコードに対する操作を行う必要があれば、このメソッドをオーバーライドすると良いでしょう。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueListener.handle">
<code class="descname">handle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.handle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードを処理します。</p>
<p>これは、ハンドラをループしてそれらに処理すべきレコードを渡します。ハンドラに渡される実際のオブジェクトは、 <a class="reference internal" href="#logging.handlers.QueueListener.prepare" title="logging.handlers.QueueListener.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prepare()</span></code></a> から返されたものです。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueListener.start">
<code class="descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.start" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リスナーを開始します。</p>
<p>これは、 LogRecord を処理するキューを監視するために、バックグラウンドスレッドを開始します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueListener.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.stop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リスナーを停止します。</p>
<p>スレッドに終了するように依頼し、終了するまで待ちます。アプリケーションの終了前にこのメソッドを呼ばないと、いくつかのレコードがキューに残り、処理されなくなるかもしれないことに注意してください。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueListener.enqueue_sentinel">
<code class="descname">enqueue_sentinel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.enqueue_sentinel" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リスナーに停止するように指示するためキューに番兵を書き込みます。この実装は <code class="docutils literal notranslate"><span class="pre">put_nowait()</span></code> を使用します。タイムアウトを有効にしたい場合や、カスタムのキュー実装を使いたい場合は、このメソッドをオーバーライドすると良いでしょう。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> モジュール</dt>
<dd>logging モジュールの API リファレンス。</dd>
<dt><a class="reference internal" href="logging.config.html#module-logging.config" title="logging.config: Configuration of the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code></a> モジュール</dt>
<dd>logging モジュールの環境設定 API です。</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">logging.handlers</span></code> --- ロギングハンドラ</a><ul>
<li><a class="reference internal" href="#streamhandler">StreamHandler</a></li>
<li><a class="reference internal" href="#filehandler">FileHandler</a></li>
<li><a class="reference internal" href="#nullhandler">NullHandler</a></li>
<li><a class="reference internal" href="#watchedfilehandler">WatchedFileHandler</a></li>
<li><a class="reference internal" href="#baserotatinghandler">BaseRotatingHandler</a></li>
<li><a class="reference internal" href="#rotatingfilehandler">RotatingFileHandler</a></li>
<li><a class="reference internal" href="#timedrotatingfilehandler">TimedRotatingFileHandler</a></li>
<li><a class="reference internal" href="#sockethandler">SocketHandler</a></li>
<li><a class="reference internal" href="#datagramhandler">DatagramHandler</a></li>
<li><a class="reference internal" href="#sysloghandler">SysLogHandler</a></li>
<li><a class="reference internal" href="#nteventloghandler">NTEventLogHandler</a></li>
<li><a class="reference internal" href="#smtphandler">SMTPHandler</a></li>
<li><a class="reference internal" href="#memoryhandler">MemoryHandler</a></li>
<li><a class="reference internal" href="#httphandler">HTTPHandler</a></li>
<li><a class="reference internal" href="#queuehandler">QueueHandler</a></li>
<li><a class="reference internal" href="#queuelistener">QueueListener</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="logging.config.html"
                        title="前の章へ"><code class="docutils literal notranslate"><span class="pre">logging.config</span></code> --- ロギングの環境設定</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="getpass.html"
                        title="次の章へ"><code class="docutils literal notranslate"><span class="pre">getpass</span></code> --- 可搬性のあるパスワード入力機構</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/library/logging.handlers.rst"
            rel="nofollow">ソースコードを表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="getpass.html" title="getpass --- 可搬性のあるパスワード入力機構"
             >次へ</a> |</li>
        <li class="right" >
          <a href="logging.config.html" title="logging.config --- ロギングの環境設定"
             >前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3rc1 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >汎用オペレーティングシステムサービス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">著作権</a> 2001-2020, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最終更新: 5月 12, 2020
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>

  </body>
</html>