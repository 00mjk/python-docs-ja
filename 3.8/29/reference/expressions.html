
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>6. 式 (expression) &#8212; Python 3.8.3rc1 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.8.3rc1 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="next" title="7. 単純文 (simple statement)" href="simple_stmts.html" />
    <link rel="prev" title="5. インポートシステム" href="import.html" />
    <link rel="canonical" href="https://docs.python.org/3/reference/expressions.html" />
    
      
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. 単純文 (simple statement)"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. インポートシステム"
             accesskey="P">前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3rc1 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 言語リファレンス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="expressions">
<span id="id1"></span><h1>6. 式 (expression)<a class="headerlink" href="#expressions" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p id="index-0">この章では、Python の式における個々の要素の意味について解説します。</p>
<p><strong>表記法に関する注意:</strong> この章と以降の章での拡張BNF (extended BNF) 表記は、字句解析規則ではなく、構文規則を記述するために用いられています。ある構文規則 (のある表現方法) が、以下の形式</p>
<pre>
<strong id="grammar-token-name">name</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">othername</span></code>
</pre>
<p>で記述されていて、この構文特有の意味付け (semantics) が記述されていない場合、 <code class="docutils literal notranslate"><span class="pre">name</span></code> の形式をとる構文の意味付けは <code class="docutils literal notranslate"><span class="pre">othername</span></code> の意味付けと同じになります。</p>
<div class="section" id="arithmetic-conversions">
<span id="conversions"></span><h2>6.1. 算術変換 (arithmetic conversion)<a class="headerlink" href="#arithmetic-conversions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-1">以下の算術演算子の記述で、「数値引数は共通の型に変換されます」と書かれているとき、組み込み型に対する演算子の実装は以下の通りに動作します:</p>
<ul class="simple">
<li>片方の引数が複素数型であれば、他方は複素数型に変換されます;</li>
<li>それ以外の場合で、片方の引数が浮動小数点数であれば、他方は浮動小数点型に変換されます;</li>
<li>それ以外場合は、両方の引数は整数でなければならず、変換の必要はありません。</li>
</ul>
<p>特定の演算子 ('%' 演算子の左引数としての文字列) には、さらに別の規則が適用されます。拡張は、それ自身の型変換のふるまいを定義していなければなりません。</p>
</div>
<div class="section" id="atoms">
<span id="id2"></span><h2>6.2. アトム、原子的要素 (atom)<a class="headerlink" href="#atoms" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-2">atom は、式の一番基本的な要素です。もっとも単純な atom は、識別子またはリテラルです。丸括弧、角括弧、または波括弧で囲われた形式 (form) もまた、構文上アトムに分類されます。atom の構文は以下のようになります:</p>
<pre>
<strong id="grammar-token-atom">atom     </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> | <a class="reference internal" href="#grammar-token-literal"><code class="xref docutils literal notranslate"><span class="pre">literal</span></code></a> | <a class="reference internal" href="#grammar-token-enclosure"><code class="xref docutils literal notranslate"><span class="pre">enclosure</span></code></a>
<strong id="grammar-token-enclosure">enclosure</strong> ::=  <a class="reference internal" href="#grammar-token-parenth-form"><code class="xref docutils literal notranslate"><span class="pre">parenth_form</span></code></a> | <a class="reference internal" href="#grammar-token-list-display"><code class="xref docutils literal notranslate"><span class="pre">list_display</span></code></a> | <a class="reference internal" href="#grammar-token-dict-display"><code class="xref docutils literal notranslate"><span class="pre">dict_display</span></code></a> | <a class="reference internal" href="#grammar-token-set-display"><code class="xref docutils literal notranslate"><span class="pre">set_display</span></code></a>
               | <a class="reference internal" href="#grammar-token-generator-expression"><code class="xref docutils literal notranslate"><span class="pre">generator_expression</span></code></a> | <a class="reference internal" href="#grammar-token-yield-atom"><code class="xref docutils literal notranslate"><span class="pre">yield_atom</span></code></a>
</pre>
<div class="section" id="atom-identifiers">
<span id="identifiers-names"></span><h3>6.2.1. 識別子 (identifier、または名前 (name))<a class="headerlink" href="#atom-identifiers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-3">アトムの形になっている識別子 (identifier) は名前 (name) です。字句定義については <a class="reference internal" href="lexical_analysis.html#identifiers"><span class="std std-ref">識別子 (identifier) およびキーワード (keyword)</span></a> 節を、名前付けや束縛については <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">名前づけと束縛 (naming and binding)</span></a> 節を参照してください。</p>
<p id="index-4">名前があるオブジェクトに束縛されている場合、名前 atom を評価するとそのオブジェクトになります。名前が束縛されていない場合、 atom を評価しようとすると <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 例外を送出します。</p>
<p id="index-5"><strong>プライベートな名前のマングリング:</strong> クラス定義内に書かれた識別子で、2つ以上のアンダースコアから始まり、末尾が2つ以上のアンダースコアで終わっていないものは、そのクラスの <em class="dfn">プライベートな名前</em> とみなされます。プライベートな名前は、コードが生成される前により長い形式に変換されます。この変換によって、クラス名の先頭にアンダースコアがあれば除去し、先頭にアンダースコアを1つ付加し、名前の前に挿入されます。例えば、クラス名 <code class="docutils literal notranslate"><span class="pre">Ham</span></code> の中の識別子 <code class="docutils literal notranslate"><span class="pre">__spam</span></code> は、<code class="docutils literal notranslate"><span class="pre">_Ham__spam</span></code> に変換されます。変換は識別子が使用されている構文のコンテキストからは独立しています。変換された名前が非常に長い (255文字を超える) 場合、実装によっては名前の切り詰めが行われるかもしれません。クラス名がアンダースコアのみから成る場合は変換は行われません。</p>
</div>
<div class="section" id="literals">
<span id="atom-literals"></span><h3>6.2.2. リテラル<a class="headerlink" href="#literals" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-6">Python では、文字列やバイト列リテラルと、様々な数値リテラルをサポートしています:</p>
<pre>
<strong id="grammar-token-literal">literal</strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-stringliteral"><code class="xref docutils literal notranslate"><span class="pre">stringliteral</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-bytesliteral"><code class="xref docutils literal notranslate"><span class="pre">bytesliteral</span></code></a>
             | <a class="reference internal" href="lexical_analysis.html#grammar-token-integer"><code class="xref docutils literal notranslate"><span class="pre">integer</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-floatnumber"><code class="xref docutils literal notranslate"><span class="pre">floatnumber</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-imagnumber"><code class="xref docutils literal notranslate"><span class="pre">imagnumber</span></code></a>
</pre>
<p>リテラルの評価は、与えられた型 (文字列、バイト列、整数、浮動小数点数、複素数) の与えられた値を持つオブジェクトを与えます。浮動小数点や虚数 (複素数) リテラルの場合、値は近似値になる場合があります。詳しくは <a class="reference internal" href="lexical_analysis.html#literals"><span class="std std-ref">リテラル</span></a> を参照してください。</p>
<p id="index-7">リテラルは全て変更不能なデータ型に対応します。このため、オブジェクトのアイデンティティはオブジェクトの値ほど重要ではありません。同じ値を持つ複数のリテラルを評価した場合、(それらのリテラルがプログラムの同じ場所由来のものであっても、そうでなくても) 同じオブジェクトを指しているか、まったく同じ値を持つ別のオブジェクトになります。</p>
</div>
<div class="section" id="parenthesized-forms">
<span id="parenthesized"></span><h3>6.2.3. 丸括弧形式 (parenthesized form)<a class="headerlink" href="#parenthesized-forms" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-8">丸括弧形式とは、式リストの一形態で、丸括弧で囲ったものです:</p>
<pre>
<strong id="grammar-token-parenth-form">parenth_form</strong> ::=  &quot;(&quot; [<a class="reference internal" href="#grammar-token-starred-expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a>] &quot;)&quot;
</pre>
<p>丸括弧で囲われた式のリストは、個々の式が表現するものになります: リスト内に少なくとも一つのカンマが入っていた場合、タプルになります; そうでない場合、式のリストを構成している単一の式自体の値になります。</p>
<p id="index-9">中身が空の丸括弧のペアは、空のタプルオブジェクトを表します。
タプルは変更不能なので、リテラルと同じ規則が適用されます (すなわち、空のタプルが二箇所で使われると、それらは同じオブジェクトになることもあるし、ならないこともあります)。</p>
<p id="index-10">タプルは丸括弧で作成されるのではなく、カンマによって作成されることに注意してください。例外は空のタプルで、この場合には丸括弧が <em>必要です</em> --- 丸括弧のつかない &quot;何も記述しない式 (nothing)&quot; を使えるようにしてしまうと、文法があいまいなものになってしまい、よくあるタイプミスが検出されなくなってしまいます。</p>
</div>
<div class="section" id="displays-for-lists-sets-and-dictionaries">
<span id="comprehensions"></span><h3>6.2.4. リスト、集合、辞書の表示<a class="headerlink" href="#displays-for-lists-sets-and-dictionaries" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>リスト、集合、辞書を構築するために、 Python は &quot;表示 (display)&quot; と呼ばれる特別な構文を提供していて、次の二種類ずつがあります:</p>
<ul class="simple">
<li>コンテナの内容を明示的に列挙する</li>
<li><em class="dfn">内包表記 (comprehension)</em> と呼ばれる、ループ処理とフィルター処理の組み合わせを用いた計算結果</li>
</ul>
<p id="index-11">内包表記の共通の構文要素は次の通りです:</p>
<pre>
<strong id="grammar-token-comprehension">comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-assignment-expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> <a class="reference internal" href="#grammar-token-comp-for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a>
<strong id="grammar-token-comp-for">comp_for     </strong> ::=  [&quot;async&quot;] &quot;for&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-target-list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a> &quot;in&quot; <a class="reference internal" href="#grammar-token-or-test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [<a class="reference internal" href="#grammar-token-comp-iter"><code class="xref docutils literal notranslate"><span class="pre">comp_iter</span></code></a>]
<strong id="grammar-token-comp-iter">comp_iter    </strong> ::=  <a class="reference internal" href="#grammar-token-comp-for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a> | <a class="reference internal" href="#grammar-token-comp-if"><code class="xref docutils literal notranslate"><span class="pre">comp_if</span></code></a>
<strong id="grammar-token-comp-if">comp_if      </strong> ::=  &quot;if&quot; <a class="reference internal" href="#grammar-token-expression-nocond"><code class="xref docutils literal notranslate"><span class="pre">expression_nocond</span></code></a> [<a class="reference internal" href="#grammar-token-comp-iter"><code class="xref docutils literal notranslate"><span class="pre">comp_iter</span></code></a>]
</pre>
<p>内包表記はまず単一の式、続いて少なくとも 1 個の <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節、さらに続いて 0 個以上の <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節あるいは <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> 節からなります。
この場合、各々の <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節や <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> 節を、左から右へ深くなっていくネストしたブロックとみなし、ネストの最内のブロックに到達するごとに内包表記の先頭にある式を評価した結果が、最終的にできあがるコンテナの各要素になります。</p>
<p>ただし、最も左にある <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節のイテラブル式を除いて、内包表記は暗黙的にネストされた個別のスコープで実行されます。
この仕組みのおかげで、対象のリスト内で代入された名前が外側のスコープに &quot;漏れる&quot; ことはありません。</p>
<p>最も左にある <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節のイテラブル式は、それを直接囲んでいるスコープでそのまま評価され、暗黙的な入れ子のスコープに引数として渡されます。
後に続く <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節と、最も左にある <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節のフィルター条件はイテラブル式を直接囲んでいるスコープでは評価できません。というのは、それらは最も左のイテラブルから得られる値に依存しているかもしれないからです。
例えば次の通りです: <code class="docutils literal notranslate"><span class="pre">[x*y</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">range(x,</span> <span class="pre">x+10)]</span></code> 。</p>
<p>内包表記が常に適切な型のコンテナになるのを保証するために、 <code class="docutils literal notranslate"><span class="pre">yield</span></code> 式や <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 式は暗黙的な入れ子のスコープでは禁止されています。</p>
<p id="index-12">Python 3.6 から、 <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 関数では <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 節が <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> の反復処理をするのに使われることがありました。
<code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> 関数に含まれる内包表記が、先頭の式に続く <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節あるいは <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 節で構成されていることや、追加の <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節あるいは <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 節を含んでいること、そのうえ <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 式を使っていることがあるかもしれません。
内包表記が <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 節あるいは <code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code> 式を含んでいる場合、それは <em class="dfn">非同期内包表記</em> と呼ばれます。
非同期内包表記は、それが現れるコルーチン関数の実行を中断させるかもしれません。
<span class="target" id="index-107"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0530"><strong>PEP 530</strong></a> も参照してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加: </span>非同期内包表記が導入されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.8 で変更: </span><code class="docutils literal notranslate"><span class="pre">yield</span></code> および <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> は暗黙的な入れ子のスコープでは禁止となりました。</p>
</div>
</div>
<div class="section" id="list-displays">
<span id="lists"></span><h3>6.2.5. リスト表示<a class="headerlink" href="#list-displays" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-14">リスト表示は、角括弧で囲われた式の系列です。系列は空の系列であってもかまいません:</p>
<pre>
<strong id="grammar-token-list-display">list_display</strong> ::=  &quot;[&quot; [<a class="reference internal" href="#grammar-token-starred-list"><code class="xref docutils literal notranslate"><span class="pre">starred_list</span></code></a> | <a class="reference internal" href="#grammar-token-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>] &quot;]&quot;
</pre>
<p>リスト表示は、新しいリストオブジェクトを与えます。リストの内容は、式のリストまたはリスト内包表記 (list comprehension) で指定されます。
カンマで区切られた式のリストが与えられたときは、それらの各要素は左から右へと順に評価され、その順にリスト内に配置されます。
内包表記が与えられたときは、内包表記の結果の要素でリストが構成されます。</p>
</div>
<div class="section" id="set-displays">
<span id="set"></span><h3>6.2.6. 集合表示<a class="headerlink" href="#set-displays" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-15">集合表示は波括弧で表され、キーと値を分けるコロンがないことで辞書表現と区別されます:</p>
<pre>
<strong id="grammar-token-set-display">set_display</strong> ::=  &quot;{&quot; (<a class="reference internal" href="#grammar-token-starred-list"><code class="xref docutils literal notranslate"><span class="pre">starred_list</span></code></a> | <a class="reference internal" href="#grammar-token-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>) &quot;}&quot;
</pre>
<p>集合表示は、新しいミュータブルな集合オブジェクトを与えます。集合の内容は、式の並びまたは内包表記によって指定されます。
カンマ区切りの式のリストが与えられたときは、その要素は左から右へ順に評価され、集合オブジェクトに加えられます。
内包表記が与えられたときは、内包表記の結果の要素で集合が構成されます。</p>
<p>空集合は <code class="docutils literal notranslate"><span class="pre">{}</span></code> で構成できません。このリテラルは空の辞書を構成します。</p>
</div>
<div class="section" id="dictionary-displays">
<span id="dict"></span><h3>6.2.7. 辞書表示<a class="headerlink" href="#dictionary-displays" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-16">辞書表示は、波括弧で囲われた、キーと値のペアからなる系列です。系列は空の系列であってもかまいません:</p>
<pre>
<strong id="grammar-token-dict-display">dict_display      </strong> ::=  &quot;{&quot; [<a class="reference internal" href="#grammar-token-key-datum-list"><code class="xref docutils literal notranslate"><span class="pre">key_datum_list</span></code></a> | <a class="reference internal" href="#grammar-token-dict-comprehension"><code class="xref docutils literal notranslate"><span class="pre">dict_comprehension</span></code></a>] &quot;}&quot;
<strong id="grammar-token-key-datum-list">key_datum_list    </strong> ::=  <a class="reference internal" href="#grammar-token-key-datum"><code class="xref docutils literal notranslate"><span class="pre">key_datum</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-key-datum"><code class="xref docutils literal notranslate"><span class="pre">key_datum</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-key-datum">key_datum         </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | &quot;**&quot; <a class="reference internal" href="#grammar-token-or-expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>
<strong id="grammar-token-dict-comprehension">dict_comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-comp-for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a>
</pre>
<p>辞書表示は、新たな辞書オブジェクトを表します。</p>
<p>キーとデータからなる対の並びがカンマ区切りで与えられたときは、その要素は左から右へ評価され、辞書のエントリーを定義します。すなわち、それぞれのキーオブジェクトが、辞書内で対応するデータを保存するキーとして使われます。
これにより、キーとデータのリストの中で同じキーを複数回指定することができ、そのキーに対する最終的な辞書の値は、最後に与えられたものになります。</p>
<p id="index-17">ダブルアスタリスク <code class="docutils literal notranslate"><span class="pre">**</span></code> は <em class="dfn">辞書のアンパック</em> を表します。このとき被演算子は <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a> でなければなりません。それぞれのmappingの要素は、新たな辞書に追加されます。キー/データの対もしくは辞書のアンパックによって先に追加された値は、後から追加された値によって上書きされます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加: </span>辞書表示のアンパックは最初に <span class="target" id="index-108"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0448"><strong>PEP 448</strong></a> で提案されました。</p>
</div>
<p>辞書内包表記は、リストや集合の内包表記とは対照的に、通常の &quot;for&quot; や &quot;if&quot; 節の前に、コロンで分けられた 2 つの式が必要です。内包表記が起動すると、結果のキーと値の要素が、作られた順に新しい辞書に挿入されます。</p>
<p id="index-19">キーの値として使える型に関する制限は <a class="reference internal" href="datamodel.html#types"><span class="std std-ref">標準型の階層</span></a> 節ですでに列挙しています。(一言でいうと、キーは変更可能なオブジェクトを全て排除した <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> でなければなりません。) 重複するキー間で衝突が起きても、衝突が検出されることはありません; あるキーに対して、最後に渡されたデータ (プログラムテキスト上では、辞書表記の最も右側値となるもの) が使われます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.8 で変更: </span>Prior to Python 3.8, in dict comprehensions, the evaluation order of key
and value was not well-defined.  In CPython, the value was evaluated before
the key.  Starting with 3.8, the key is evaluated before the value, as
proposed by <span class="target" id="index-20"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0572"><strong>PEP 572</strong></a>.</p>
</div>
</div>
<div class="section" id="generator-expressions">
<span id="genexpr"></span><h3>6.2.8. ジェネレータ式<a class="headerlink" href="#generator-expressions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-21">ジェネレータ式 (generator expression) とは、丸括弧を使ったコンパクトなジェネレータ表記法です:</p>
<pre>
<strong id="grammar-token-generator-expression">generator_expression</strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-comp-for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a> &quot;)&quot;
</pre>
<p>ジェネレータ式は新たなジェネレータオブジェクトを与えます。この構文は内包表記とほぼ同じですが、角括弧や波括弧ではなく、丸括弧で囲まれます。</p>
<p>ジェネレータ式の中で使われている変数は、 (通常のジェネレータと同じように) そのジェネレータオブジェクトに対して <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> メソッドが呼ばれるときまで評価が遅延されます。
ただし、最も左にある <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節のイテラブル式は直ちに評価されます。そのためそこで生じたエラーは、最初の値が得られた時点ではなく、ジェネレータ式が定義された時点で発せられます。
後に続く <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節と、最も左にある <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節のフィルター条件はイテラブル式を直接囲んでいるスコープでは評価できません。というのは、それらは最も左のイテラブルから得られる値に依存しているかもしれないからです。
例えば次の通りです: <code class="docutils literal notranslate"><span class="pre">(x*y</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">range(x,</span> <span class="pre">x+10))</span></code> 。</p>
<p>関数の唯一の引数として渡す場合には、丸括弧を省略できます。詳しくは <a class="reference internal" href="#calls"><span class="std std-ref">呼び出し (call)</span></a> 節を参照してください。</p>
<p>ジェネレータ式自身の期待される動作を妨げないために、 <code class="docutils literal notranslate"><span class="pre">yield</span></code> 式や <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 式は暗黙的に定義されたジェネレータでは禁止されています。</p>
<p>ジェネレータ式が <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 節あるいは <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 式を含んでいる場合、それは <em class="dfn">非同期ジェネレータ式</em> と呼ばれます。
非同期ジェネレータ式は、非同期イテレータである新しい非同期ジェネレータオブジェクトを返します (<a class="reference internal" href="datamodel.html#async-iterators"><span class="std std-ref">非同期イテレータ (Asynchronous Iterator)</span></a> を参照してください)。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加: </span>非同期ジェネレータ式が導入されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.7 で変更: </span>Python 3.7 より前では、非同期ジェネレータ式は <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> コルーチンでしか使えませんでした。
3.7 からは、任意の関数で非同期ジェネレータ式が使えるようになりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.8 で変更: </span><code class="docutils literal notranslate"><span class="pre">yield</span></code> および <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> は暗黙的な入れ子のスコープでは禁止となりました。</p>
</div>
</div>
<div class="section" id="yield-expressions">
<span id="yieldexpr"></span><h3>6.2.9. Yield 式<a class="headerlink" href="#yield-expressions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<pre id="index-22">
<strong id="grammar-token-yield-atom">yield_atom      </strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-yield-expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a> &quot;)&quot;
<strong id="grammar-token-yield-expression">yield_expression</strong> ::=  &quot;yield&quot; [<a class="reference internal" href="#grammar-token-expression-list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> | &quot;from&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
</pre>
<p>yield 式は <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">ジェネレータ</span></a> 関数や term:<cite>非同期ジェネレータ &lt;asynchronous generator&gt;</cite> を定義するときに使われます。従って、関数定義の本体でのみ使えます。
関数の本体で yield 式 を使用するとその関数はジェネレータになり、 <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 関数の本体で使用するとそのコルーチン関数は非同期ジェネレータになります。
例えば次のようになります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>  <span class="c1"># defines a generator function</span>
    <span class="k">yield</span> <span class="mi">123</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">agen</span><span class="p">():</span> <span class="c1"># defines an asynchronous generator function</span>
    <span class="k">yield</span> <span class="mi">123</span>
</pre></div>
</div>
<p>含まれているスコープの副作用のため、 <code class="docutils literal notranslate"><span class="pre">yield</span></code> 式は暗黙的に定義されたスコープの一部として内包表記やジェネレータ式を実装するのに使うことは許可されていません。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.8 で変更: </span>yield 式は、暗黙的な入れ子のスコープで内包表記やジェネレータ式を実装するための使用が禁止になりました。</p>
</div>
<p>ジェネレータ関数についてはすぐ下で説明されています。非同期ジェネレータ関数は、 <a class="reference internal" href="#asynchronous-generator-functions"><span class="std std-ref">非同期ジェネレータ関数 (asynchronous generator function)</span></a> 節に分けて説明されています。</p>
<p>ジェネレータ関数が呼び出された時、ジェネレータとしてのイテレータを返します。ジェネレータはその後ジェネレータ関数の実行を制御します。ジェネレータのメソッドが呼び出されると実行が開始されます。開始されると、最初の yield 式まで処理して一時停止し、呼び出し元へ <a class="reference internal" href="#grammar-token-expression-list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> の値を返します。ここで言う一時停止とは、ローカル変数の束縛、命令ポインタや内部の評価スタック、そして例外処理のを含むすべてのローカル状態が保持されることを意味します。再度、ジェネレータのメソッドが呼び出されて実行を再開した時、ジェネレータは yield 式がただの外部呼び出しであったかのように処理を継続します。再開後の yield 式の値は実行を再開するメソッドに依存します。<a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> を使用した場合 (一般に <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 文や組み込み関数 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> など) の結果は <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> となり、<a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> を使用した場合はそのメソッドに渡された値が結果になります。</p>
<p id="index-23">これまで説明した内容から、ジェネレータ関数はコルーチンにとてもよく似ています。ジェネレータ関数は何度も生成し、1つ以上のエントリポイントを持ち、その実行は一時停止されます。ジェネレータ関数は yield した後で実行の継続を制御できないことが唯一の違いです。その制御は常にジェネレータの呼び出し元へ移されます。</p>
<p>yield 式は <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 構造内で使用できます。ジェネレータの (参照カウントがゼロに達するか、ガベージコレクションによる) 完了前に再開されない場合、ジェネレータ-イテレータの <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> メソッドが呼ばれ、<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 節が実行されます。</p>
<p id="index-24"><code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> を使用した場合、与えられた式はサブイテレータとして扱われます。サブイテレータによって生成されたすべての値は現在のジェネレータのメソッドの呼び出し元へ直接渡されます。<a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> で渡されたあらゆる値と <a class="reference internal" href="#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> で渡されたあらゆる例外は根底のイテレータに適切なメソッドがあれば渡されます。適切なメソッドがない場合、<a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> は <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> か <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> を、<a class="reference internal" href="#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> は渡された例外を即座に送出します。</p>
<p>根底のイテレータの完了時、引き起こされた <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> インスタンスの <code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> 属性はその yield 式の値となります。
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> を起こす際に明示的にセットされるか、サブイテレータがジェネレータであれば (サブイテレータからかえる値で) 自動的にセットされるかのどちらかです。</p>
<blockquote>
<div><div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>サブイテレータに制御フローを委譲するために <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> が追加されました。</p>
</div>
</div></blockquote>
<p>yield 式が代入文の単独の右辺式であるとき、括弧は省略できます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-109"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0255"><strong>PEP 255</strong></a> - 単純なジェネレータ</dt>
<dd>Python へのジェネレータと <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 文の導入提案。</dd>
<dt><span class="target" id="index-110"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0342"><strong>PEP 0342</strong></a> - 拡張されたジェネレータを用いたコルーチン</dt>
<dd>シンプルなコルーチンとして利用できるように、ジェネレータの構文と API を拡張する提案。</dd>
<dt><span class="target" id="index-111"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0380"><strong>PEP 380</strong></a> - サブジェネレータへの委譲構文</dt>
<dd>サブジェネレータの委譲を簡単にするための、 <code class="xref std std-token docutils literal notranslate"><span class="pre">yield_from</span></code> 構文の導入提案。</dd>
<dt><span class="target" id="index-112"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0525"><strong>PEP 525</strong></a> - 非同期ジェネレータ</dt>
<dd>コルーチン関数へのジェネレータの実装能力の追加による <span class="target" id="index-113"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> の拡張提案。</dd>
</dl>
</div>
<div class="section" id="generator-iterator-methods">
<span id="generator-methods"></span><span id="index-30"></span><h4>6.2.9.1. ジェネレータ-イテレータメソッド<a class="headerlink" href="#generator-iterator-methods" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>この説ではジェネレータイテレータのメソッドについて説明します。これらはジェネレータ関数の実行制御に使用できます。</p>
<p>以下のジェネレータメソッドの呼び出しは、ジェネレータが既に実行中の場合 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 例外を送出する点に注意してください。</p>
<span class="target" id="index-31"></span><dl class="method">
<dt id="generator.__next__">
<code class="descclassname">generator.</code><code class="descname">__next__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.__next__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータ関数の実行を開始するか、最後に yield 式が実行されたところから再開します。ジェネレータ関数が <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> メソッドによって再開された時、その時点の <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 式の値は常に <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> と評価されます。その後次の <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 式まで実行し、ジェネレータは一時停止し、<a class="reference internal" href="#grammar-token-expression-list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> の値を <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> メソッドの呼び出し元に返します。ジェネレータが次の値を yield せずに終了した場合、<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 例外が送出されます。</p>
<p>このメソッドは通常、例えば <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> ループや組み込みの <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 関数によって暗黙に呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="generator.send">
<code class="descclassname">generator.</code><code class="descname">send</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#generator.send" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータ関数の内部へ値を &quot;送り&quot;、実行を再開します。引数の <em>value</em> はその時点の yield 式の結果になります。 <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> メソッドは次にジェネレータが生成した値を返し、ジェネレータが次の値を生成することなく終了すると <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> を送出します。 <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> が呼び出されてジェネレータが開始するときは、値を受け取る yield 式が存在しないので、 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> を引数として呼び出さなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="generator.throw">
<code class="descclassname">generator.</code><code class="descname">throw</code><span class="sig-paren">(</span><em>type</em><span class="optional">[</span>, <em>value</em><span class="optional">[</span>, <em>traceback</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.throw" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータが中断した位置で <code class="docutils literal notranslate"><span class="pre">type</span></code> 型の例外を発生させて、そのジェネレータ関数が生成する次の値を返します。ジェネレータが値を生成することなく終了すると <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> が発生します。ジェネレータ関数が渡された例外を捕捉しない、もしくは違う例外を発生させるなら、その例外は呼び出し元へ伝搬されます。</p>
</dd></dl>

<span class="target" id="index-32"></span><dl class="method">
<dt id="generator.close">
<code class="descclassname">generator.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータ関数が一時停止した時点で <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> を発生させます。
そして、ジェネレータ関数が無事に終了するか、既にクローズされているか、(例外が捕捉されなかったために) <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> が送出された場合、 close は呼び出し元へ戻ります。
ジェネレータが値を生成する場合 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> が発生します。
<a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> はジェネレータが例外や正常な終了により既に終了している場合は何もしません。</p>
</dd></dl>

</div>
<div class="section" id="examples">
<span id="index-33"></span><h4>6.2.9.2. 使用例<a class="headerlink" href="#examples" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>以下の簡単なサンプルはジェネレータとジェネレータ関数の振る舞いを実際に紹介します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Execution starts when &#39;next()&#39; is called for the first time.&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="n">e</span>
<span class="gp">... </span>    <span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Don&#39;t forget to clean up when &#39;close()&#39; is called.&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span> <span class="o">=</span> <span class="n">echo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">Execution starts when &#39;next()&#39; is called for the first time.</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">generator</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="s2">&quot;spam&quot;</span><span class="p">)</span>
<span class="go">TypeError(&#39;spam&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">Don&#39;t forget to clean up when &#39;close()&#39; is called.</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> の使用例は、&quot;What's New in Python.&quot; の <a class="reference internal" href="../whatsnew/3.3.html#pep-380"><span class="std std-ref">PEP 380: サブジェネレータへの委譲構文</span></a> を参照してください。</p>
</div>
<div class="section" id="asynchronous-generator-functions">
<span id="id3"></span><h4>6.2.9.3. 非同期ジェネレータ関数 (asynchronous generator function)<a class="headerlink" href="#asynchronous-generator-functions" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> を使用して定義された関数やメソッドに yield 式があると、その関数は <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">非同期ジェネレータ</span></a> 関数として定義されます。</p>
<p>非同期ジェネレータ関数が呼び出されると、非同期ジェネレータオブジェクトと呼ばれる非同期イテレータが返されます。
そして、そのオブジェクトはジェネレータ関数の実行を制御します。
通常、非同期ジェネレータオブジェクトは、コルーチン関数内の <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 文で使われ、これはジェネレータオブジェクトが <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 文で使われる様子に類似します。</p>
<p>非同期ジェネレータのメソッドの 1 つを呼び出すと <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> オブジェクトが返され、このオブジェクトが動く番になったときに実行が開始されます。
そのときに実行は最初の yield 式まで進み、そこで再び中断され、 <a class="reference internal" href="#grammar-token-expression-list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> の値を待機中のコルーチンに返します。
ジェネレータと同様に、中断とは、現在のローカル変数束縛、命令ポインタ、内部評価スタック、および例外処理の状態など、すべてのローカルな状態が保たれることを意味します。
非同期ジェネレータのメソッドから次のオブジェクトが返されたことで実行が再開されると、関数はあたかも yield 式が単なる外部呼び出しであるかのように処理を進めていきます。
再開後の yield 式の値は、実行を再開したメソッドによって異なります。
<a class="reference internal" href="#agen.__anext__" title="agen.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> を使った場合は、結果は <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> になります。
そうではなく、 <a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> が使用された場合は、結果はそのメソッドに渡された値になります。</p>
<p>非同期ジェネレータ関数では、 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 構造内の任意の場所で yield 式が使用できます。
ただし、非同期ジェネレータが、(参照カウントがゼロに達するか、ガベージコレクションによる) 終了処理より前に再開されない場合、 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code> 構造内の yield 式は失敗となり、実行待ちだった <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 節が実行されます。
このケースでは、非同期ジェネレータが作動しているイベントループやスケジューラの責務は、非同期ジェネレータの <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> メソッドを呼び出し、残りのコルーチンオブジェクトを実行し、それによって実行待ちだった <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 節が実行できるようにします。</p>
<p>To take care of finalization, an event loop should define
a <em>finalizer</em> function which takes an asynchronous generator-iterator
and presumably calls <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> and executes the coroutine.
This  <em>finalizer</em> may be registered by calling <a class="reference internal" href="../library/sys.html#sys.set_asyncgen_hooks" title="sys.set_asyncgen_hooks"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.set_asyncgen_hooks()</span></code></a>.
When first iterated over, an asynchronous generator-iterator will store the
registered <em>finalizer</em> to be called upon finalization. For a reference example
of a <em>finalizer</em> method see the implementation of
<code class="docutils literal notranslate"><span class="pre">asyncio.Loop.shutdown_asyncgens</span></code> in <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/asyncio/base_events.py">Lib/asyncio/base_events.py</a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> 式は、非同期ジェネレータ関数で使われると文法エラーになります。</p>
</div>
<div class="section" id="asynchronous-generator-iterator-methods">
<span id="asynchronous-generator-methods"></span><span id="index-34"></span><h4>6.2.9.4. 非同期ジェネレータイテレータメソッド<a class="headerlink" href="#asynchronous-generator-iterator-methods" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>この小節では、ジェネレータ関数の実行制御に使われる非同期ジェネレータイテレータのメソッドについて説明します。</p>
<span class="target" id="index-35"></span><dl class="method">
<dt id="agen.__anext__">
<em class="property">coroutine </em><code class="descclassname">agen.</code><code class="descname">__anext__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.__anext__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns an awaitable which when run starts to execute the asynchronous
generator or resumes it at the last executed yield expression.  When an
asynchronous generator function is resumed with an <a class="reference internal" href="#agen.__anext__" title="agen.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a>
method, the current yield expression always evaluates to <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> in
the returned awaitable, which when run will continue to the next yield
expression. The value of the <a class="reference internal" href="#grammar-token-expression-list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> of the yield
expression is the value of the <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception raised by
the completing coroutine.  If the asynchronous generator exits without
yielding another value, the awaitable instead raises a
<a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> exception, signalling that the asynchronous
iteration has completed.</p>
<p>このメソッドは通常、 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> ループによって暗黙に呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="agen.asend">
<em class="property">coroutine </em><code class="descclassname">agen.</code><code class="descname">asend</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#agen.asend" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns an awaitable which when run resumes the execution of the
asynchronous generator. As with the <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> method for a
generator, this &quot;sends&quot; a value into the asynchronous generator function,
and the <em>value</em> argument becomes the result of the current yield expression.
The awaitable returned by the <a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> method will return the next
value yielded by the generator as the value of the raised
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, or raises <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> if the
asynchronous generator exits without yielding another value.  When
<a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> is called to start the asynchronous
generator, it must be called with <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> as the argument,
because there is no yield expression that could receive the value.</p>
</dd></dl>

<dl class="method">
<dt id="agen.athrow">
<em class="property">coroutine </em><code class="descclassname">agen.</code><code class="descname">athrow</code><span class="sig-paren">(</span><em>type</em><span class="optional">[</span>, <em>value</em><span class="optional">[</span>, <em>traceback</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.athrow" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns an awaitable that raises an exception of type <code class="docutils literal notranslate"><span class="pre">type</span></code> at the point
where the asynchronous generator was paused, and returns the next value
yielded by the generator function as the value of the raised
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception.  If the asynchronous generator exits
without yielding another value, a <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> exception is
raised by the awaitable.
If the generator function does not catch the passed-in exception, or
raises a different exception, then when the awaitable is run that exception
propagates to the caller of the awaitable.</p>
</dd></dl>

<span class="target" id="index-36"></span><dl class="method">
<dt id="agen.aclose">
<em class="property">coroutine </em><code class="descclassname">agen.</code><code class="descname">aclose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.aclose" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns an awaitable that when run will throw a <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> into
the asynchronous generator function at the point where it was paused.
If the asynchronous generator function then exits gracefully, is already
closed, or raises <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> (by not catching the exception),
then the returned awaitable will raise a <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception.
Any further awaitables returned by subsequent calls to the asynchronous
generator will raise a <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> exception.  If the
asynchronous generator yields a value, a <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> is raised
by the awaitable.  If the asynchronous generator raises any other exception,
it is propagated to the caller of the awaitable.  If the asynchronous
generator has already exited due to an exception or normal exit, then
further calls to <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> will return an awaitable that does nothing.</p>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="primaries">
<span id="id4"></span><h2>6.3. プライマリ<a class="headerlink" href="#primaries" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-37">プライマリは、言語において最も結合の強い操作を表します。文法は以下のようになります:</p>
<pre>
<strong id="grammar-token-primary">primary</strong> ::=  <a class="reference internal" href="#grammar-token-atom"><code class="xref docutils literal notranslate"><span class="pre">atom</span></code></a> | <a class="reference internal" href="#grammar-token-attributeref"><code class="xref docutils literal notranslate"><span class="pre">attributeref</span></code></a> | <a class="reference internal" href="#grammar-token-subscription"><code class="xref docutils literal notranslate"><span class="pre">subscription</span></code></a> | <a class="reference internal" href="#grammar-token-slicing"><code class="xref docutils literal notranslate"><span class="pre">slicing</span></code></a> | <a class="reference internal" href="#grammar-token-call"><code class="xref docutils literal notranslate"><span class="pre">call</span></code></a>
</pre>
<div class="section" id="attribute-references">
<span id="id5"></span><h3>6.3.1. 属性参照<a class="headerlink" href="#attribute-references" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-38">属性参照は、プライマリの後ろにピリオドと名前を連ねたものです:</p>
<pre>
<strong id="grammar-token-attributeref">attributeref</strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;.&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
</pre>
<p id="index-39">プライマリの評価は、属性参照をサポートする型のオブジェクトでなければならず、これにはほとんどのオブジェクトが当てはまります。そしてこのオブジェクトは、名前が指定した識別子名であるような属性を生成しなければなりません。この生成は <a class="reference internal" href="datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> メソッドをオーバーライドすることでカスタマイズできます。その属性が得られなければ、例外 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> が送出されます。そうでなければ、生成されるオブジェクトの型と値は、属性を生成したオブジェクトにより決まります。同じ属性参照を複数回評価すると、互いに異なる属性オブジェクトが得られることがあります。</p>
</div>
<div class="section" id="subscriptions">
<span id="id6"></span><h3>6.3.2. 添字表記 (subscription)<a class="headerlink" href="#subscriptions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<span class="target" id="index-40"></span><p id="index-41">添字表記は、シーケンス (文字列、タプルまたはリスト) やマップ (辞書) オブジェクトから、要素を一つ選択します:</p>
<pre>
<strong id="grammar-token-subscription">subscription</strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-expression-list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> &quot;]&quot;
</pre>
<p>プライマリの評価は、添字表記をサポートするオブジェクト (例えばリストや辞書) でなければなりません。ユーザ定義のオブジェクトは、 <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> メソッドを定義することで添字表記をサポートできます。</p>
<p>組み込みオブジェクトでは、添字表記をサポートするオブジェクトには 2 種類あります:</p>
<p>プライマリがマップであれば、式リストの値評価結果はマップ内のいずれかのキー値に相当するオブジェクトにならなければなりません。添字表記は、そのキーに対応するマップ内の値 (value) を選択します。 (式リストの要素が単独である場合を除き、式リストはタプルでなければなりません。)</p>
<p>プライマリがシーケンスであれば、式リストの評価結果は整数またはスライス (以下の節で論じます) でなければなりません。</p>
<p>形式的な構文はシーケンスの負のインデックスにいかなる特例も与えません。しかし、すべての組み込みのシーケンスが与える <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> メソッドは、負のインデックスを、インデックスにシーケンスの長さを加えて解釈します (つまり、 <code class="docutils literal notranslate"><span class="pre">x[-1]</span></code> は <code class="docutils literal notranslate"><span class="pre">x</span></code> の最後の要素を選択します)。結果の値はシーケンスの要素数より小さな非負の整数でなければなりません。添字表記は、(0 から数えた) インデックスを持つ要素を選択します。負のインデックスのサポートは、オブジェクトの <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> メソッドに現れるので、このメソッドをオーバーライドするサブクラスは、明示的にこのサポートを追加する必要があります。</p>
<p id="index-42">文字列型の要素は文字 (character) です。文字は個別の型ではなく、 1 文字だけからなる文字列です。</p>
</div>
<div class="section" id="slicings">
<span id="id7"></span><h3>6.3.3. スライス表記 (slicing)<a class="headerlink" href="#slicings" title="このヘッドラインへのパーマリンク">¶</a></h3>
<span class="target" id="index-43"></span><p id="index-44">スライス表記はシーケンスオブジェクト (文字列、タプルまたはリスト) におけるある範囲の要素を選択します。スライス表記は式として用いたり、代入や <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> 文の対象として用いたりできます。スライス表記の構文は以下のようになります:</p>
<pre>
<strong id="grammar-token-slicing">slicing     </strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-slice-list"><code class="xref docutils literal notranslate"><span class="pre">slice_list</span></code></a> &quot;]&quot;
<strong id="grammar-token-slice-list">slice_list  </strong> ::=  <a class="reference internal" href="#grammar-token-slice-item"><code class="xref docutils literal notranslate"><span class="pre">slice_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-slice-item"><code class="xref docutils literal notranslate"><span class="pre">slice_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-slice-item">slice_item  </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | <a class="reference internal" href="#grammar-token-proper-slice"><code class="xref docutils literal notranslate"><span class="pre">proper_slice</span></code></a>
<strong id="grammar-token-proper-slice">proper_slice</strong> ::=  [<a class="reference internal" href="#grammar-token-lower-bound"><code class="xref docutils literal notranslate"><span class="pre">lower_bound</span></code></a>] &quot;:&quot; [<a class="reference internal" href="#grammar-token-upper-bound"><code class="xref docutils literal notranslate"><span class="pre">upper_bound</span></code></a>] [ &quot;:&quot; [<a class="reference internal" href="#grammar-token-stride"><code class="xref docutils literal notranslate"><span class="pre">stride</span></code></a>] ]
<strong id="grammar-token-lower-bound">lower_bound </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-upper-bound">upper_bound </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-stride">stride      </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>上記の形式的な構文法にはあいまいなところがあります: 式リストに見えるものは、スライスリストにも見えるため、添字表記はスライス表記としても解釈されうるということです。(スライスリストが適切なスライスを含まない場合)、これ以上の構文の複雑化はせず、スライス表記としての解釈よりも添字表記としての解釈が優先されるように定義することで、あいまいさを取り除いています。</p>
<p id="index-45">スライス表記に対する意味付けは、以下のようになります。プライマリの値評価結果は、以下に述べるようにしてスライスリストから生成されたキーによって (通常の添字表記と同じ <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> メソッドを使って) インデクス指定できなければなりません。スライスリストに一つ以上のカンマが含まれている場合、キーは各スライス要素を値変換したものからなるタプルになります; それ以外の場合、単一のスライス要素自体を値変換したものがキーになります。一個の式であるスライス要素は、その式に変換されます。適切なスライスは、スライスオブジェクト (<a class="reference internal" href="datamodel.html#types"><span class="std std-ref">標準型の階層</span></a> 参照) に変換され、その <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> および <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code>  属性は、それぞれ指定した下境界、上境界、およびとび幅 (stride) になります。式がない場所は <code class="docutils literal notranslate"><span class="pre">None</span></code> で置き換えられます。</p>
</div>
<div class="section" id="calls">
<span id="index-46"></span><span id="id8"></span><h3>6.3.4. 呼び出し (call)<a class="headerlink" href="#calls" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>呼び出しは、呼び出し可能オブジェクト (例えば <a class="reference internal" href="../glossary.html#term-function"><span class="xref std std-term">function</span></a>) を <a class="reference internal" href="../glossary.html#term-argument"><span class="xref std std-term">arguments</span></a> の系列とともに呼び出します。系列は空の系列であってもかまいません:</p>
<pre>
<strong id="grammar-token-call">call                </strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;(&quot; [<a class="reference internal" href="#grammar-token-argument-list"><code class="xref docutils literal notranslate"><span class="pre">argument_list</span></code></a> [&quot;,&quot;] | <a class="reference internal" href="#grammar-token-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>] &quot;)&quot;
<strong id="grammar-token-argument-list">argument_list       </strong> ::=  <a class="reference internal" href="#grammar-token-positional-arguments"><code class="xref docutils literal notranslate"><span class="pre">positional_arguments</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-starred-and-keywords"><code class="xref docutils literal notranslate"><span class="pre">starred_and_keywords</span></code></a>]
                            [&quot;,&quot; <a class="reference internal" href="#grammar-token-keywords-arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>]
                          | <a class="reference internal" href="#grammar-token-starred-and-keywords"><code class="xref docutils literal notranslate"><span class="pre">starred_and_keywords</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-keywords-arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>]
                          | <a class="reference internal" href="#grammar-token-keywords-arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>
<strong id="grammar-token-positional-arguments">positional_arguments</strong> ::=  positional_item (&quot;,&quot; positional_item)*
<strong id="grammar-token-positional-item">positional_item     </strong> ::=  <a class="reference internal" href="#grammar-token-assignment-expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> | &quot;*&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-starred-and-keywords">starred_and_keywords</strong> ::=  (&quot;*&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | <a class="reference internal" href="#grammar-token-keyword-item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a>)
                          (&quot;,&quot; &quot;*&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | &quot;,&quot; <a class="reference internal" href="#grammar-token-keyword-item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a>)*
<strong id="grammar-token-keywords-arguments">keywords_arguments  </strong> ::=  (<a class="reference internal" href="#grammar-token-keyword-item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a> | &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)
                          (&quot;,&quot; <a class="reference internal" href="#grammar-token-keyword-item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a> | &quot;,&quot; &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)*
<strong id="grammar-token-keyword-item">keyword_item        </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> &quot;=&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>最後の位置引数やキーワード引数の後にカンマをつけてもかまいません。構文の意味付けに影響を及ぼすことはありません。</p>
<p id="index-47">プライマリの評価は呼び出し可能オブジェクトでなければなりません。 (ユーザ定義関数、組み込み関数、組み込みオブジェクトのメソッド、クラスオブジェクト、クラスインスタンスのメソッド、および <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> メソッドを持つ全てのオブジェクトが呼び出し可能です)。引数式は全て、呼び出しを試みる前に評価されます。仮引数 (formal <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameter</span></a>) リストの構文については <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> を参照してください。</p>
<p>キーワード引数が存在する場合、以下のようにして最初に位置引数 (positional argument) に変換されます。まず、値の入っていないスロットが仮引数に対して生成されます。N 個の位置引数がある場合、位置引数は先頭の N スロットに配置されます。次に、各キーワード引数について、識別子を使って対応するスロットを決定します (識別子が最初の仮引数名と同じなら、最初のスロットを使う、といった具合です)。スロットがすでにすべて埋まっていたなら <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 例外が送出されます。それ以外の場合、引数値をスロットに埋めていきます。 (式が <code class="docutils literal notranslate"><span class="pre">None</span></code> であっても、その式でスロットを埋めます)。全ての引数が処理されたら、まだ埋められていないスロットをそれぞれに対応する関数定義時のデフォルト値で埋めます。(デフォルト値は、関数が定義されたときに一度だけ計算されます; 従って、リストや辞書のような変更可能なオブジェクトがデフォルト値として使われると、対応するスロットに引数を指定しない限り、このオブジェクトが全ての呼び出しから共有されます; このような状況は通常避けるべきです。) デフォルト値が指定されていない、値の埋められていないスロットが残っている場合 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 例外が送出されます。そうでない場合、値の埋められたスロットからなるリストが呼び出しの引数として使われます。</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> 実装では、名前を持たない位置引数を受け取る組み込み関数を提供されるかもしれません。そういった引数がドキュメント化のために '名付けられて' いたとしても、実際には名付けられていないのでキーワードでは提供されません。 CPython では、C 言語で実装された関数の、名前を持たない位置引数をパースするために <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> を使用します。</p>
</div>
<p>仮引数スロットの数よりも多くの位置引数がある場合、構文 <code class="docutils literal notranslate"><span class="pre">*identifier</span></code> を使って指定された仮引数がないかぎり、 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 例外が送出されます; 仮引数 <code class="docutils literal notranslate"><span class="pre">*identifier</span></code> がある場合、この仮引数は余分な位置引数が入ったタプル (もしくは、余分な位置引数がない場合には空のタプル) を受け取ります。</p>
<p>キーワード引数のいずれかが仮引数名に対応しない場合、構文 <code class="docutils literal notranslate"><span class="pre">**identifier</span></code> を使って指定された仮引数がない限り、 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 例外が送出されます; 仮引数 <code class="docutils literal notranslate"><span class="pre">**identifier</span></code> がある場合、この仮引数は余分なキーワード引数が入った (キーワードをキーとし、引数値をキーに対応する値とした) 辞書を受け取ります。余分なキーワード引数がない場合には、空の (新たな) 辞書を受け取ります。</p>
<p id="index-48">関数呼び出しに <code class="docutils literal notranslate"><span class="pre">*expression</span></code> という構文が現れる場合は、 <code class="docutils literal notranslate"><span class="pre">expression</span></code> の評価結果は <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">イテラブル</span></a> でなければなりません。
そのイテラブルの要素は、追加の位置引数であるかのように扱われます。
<code class="docutils literal notranslate"><span class="pre">f(x1,</span> <span class="pre">x2,</span> <span class="pre">*y,</span> <span class="pre">x3,</span> <span class="pre">x4)</span></code> という呼び出しにおいて、 <em>y</em> の評価結果がシーケンス <em>y1</em>, ..., <em>yM</em> だった場合は、この呼び出しは M+4 個の位置引数 <em>x1</em>, <em>x2</em>, <em>y1</em>, ..., <em>yM</em>, <em>x3</em>, <em>x4</em> での呼び出しと同じになります。</p>
<p>この結論としては、 <code class="docutils literal notranslate"><span class="pre">*expression</span></code> 構文がキーワード引数の <em>後ろ</em> に来ることもありますが、キーワード引数 (と任意の <code class="docutils literal notranslate"><span class="pre">**expression</span></code> 引数 -- 下を参照) よりも <em>前</em> にあるものとして処理されます。
従って、このような動作になります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">2 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">f() got multiple values for keyword argument &#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">1 2</span>
</pre></div>
</div>
<p>キーワード引数と <code class="docutils literal notranslate"><span class="pre">*expression</span></code> 構文を同じ呼び出しで一緒に使うことはあまりないので、実際に上記のような混乱が生じることはありません。</p>
<p id="index-49">関数呼び出しで <code class="docutils literal notranslate"><span class="pre">**expression</span></code> 構文が使われた場合、 <code class="docutils literal notranslate"><span class="pre">expression</span></code> の評価結果は <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">マッピング</span></a> でなければなりません。その内容は追加のキーワード引数として扱われます。
キーワードが (明示的なキーワード引数として、あるいは他のアンパックの中に) 既に存在する場合、 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 例外が送出されます。</p>
<p><code class="docutils literal notranslate"><span class="pre">*identifier</span></code> や <code class="docutils literal notranslate"><span class="pre">**identifier</span></code> 構文を使った仮引数は、位置引数スロットやキーワード引数名にすることができません。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>関数呼び出しは任意の数の <code class="docutils literal notranslate"><span class="pre">*</span></code> アンパックと <code class="docutils literal notranslate"><span class="pre">**</span></code> アンパックを受け取り、位置引数はイテラブルアンパック (<code class="docutils literal notranslate"><span class="pre">*</span></code>) の後ろに置け、キーワード引数は辞書アンパック (<code class="docutils literal notranslate"><span class="pre">**</span></code>) の後ろに置けるようになりました。
最初に <span class="target" id="index-114"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0448"><strong>PEP 448</strong></a> で提案されました。</p>
</div>
<p>呼び出しを行うと、例外を送出しない限り、常に何らかの値を返します。 <code class="docutils literal notranslate"><span class="pre">None</span></code> を返す場合もあります。戻り値がどのように算出されるかは、呼び出し可能オブジェクトの形態によって異なります。</p>
<p>各形態では---</p>
<dl class="docutils">
<dt>ユーザ定義関数:</dt>
<dd><p class="first last" id="index-51">関数のコードブロックに引数リストが渡され、実行されます。コードブロックは、まず仮引数を実引数に結合 (bind) します; この動作については <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> で記述しています。コードブロックで <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 文が実行される際に、関数呼び出しの戻り値 (return value) が決定されます。</p>
</dd>
<dt>組み込み関数またはメソッド:</dt>
<dd><p class="first last" id="index-52">結果はインタプリタに依存します; 組み込み関数やメソッドの詳細は <a class="reference internal" href="../library/functions.html#built-in-funcs"><span class="std std-ref">組み込み関数</span></a> を参照してください。</p>
</dd>
<dt>クラスオブジェクト:</dt>
<dd><p class="first last" id="index-53">そのクラスの新しいインスタンスが返されます。</p>
</dd>
<dt>クラスインスタンスメソッド:</dt>
<dd><p class="first last" id="index-54">対応するユーザ定義の関数が呼び出されます。このとき、呼び出し時の引数リストより一つ長い引数リストで呼び出されます: インスタンスが引数リストの先頭に追加されます。</p>
</dd>
<dt>クラスインスタンス:</dt>
<dd><p class="first last" id="index-55">クラスで <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> メソッドが定義されていなければなりません; <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> メソッドが呼び出された場合と同じ効果をもたらします。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="await-expression">
<span id="await"></span><span id="index-56"></span><h2>6.4. Await 式<a class="headerlink" href="#await-expression" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> オブジェクトでの <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a> 実行を一時停止します。
<a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">coroutine function</span></a> 内でのみ使用できます。</p>
<pre>
<strong id="grammar-token-await-expr">await_expr</strong> ::=  &quot;await&quot; <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a>
</pre>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
</div>
<div class="section" id="the-power-operator">
<span id="power"></span><h2>6.5. べき乗演算 (power operator)<a class="headerlink" href="#the-power-operator" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-57">べき乗演算は、左側にある単項演算子よりも強い結合優先順位となります。一方、右側にある単項演算子よりは弱い結合優先順位になっています。構文は以下のようになります:</p>
<pre>
<strong id="grammar-token-power">power</strong> ::=  (<a class="reference internal" href="#grammar-token-await-expr"><code class="xref docutils literal notranslate"><span class="pre">await_expr</span></code></a> | <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a>) [&quot;**&quot; <a class="reference internal" href="#grammar-token-u-expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>]
</pre>
<p>従って、べき乗演算子と単項演算子からなる演算列が丸括弧で囲われていない場合、演算子は右から左へと評価されます (この場合は演算子の評価順序を強制しません。つまり <code class="docutils literal notranslate"><span class="pre">-1**2</span></code> は <code class="docutils literal notranslate"><span class="pre">-1</span></code> になります)。</p>
<p>べき乗演算子の意味は、二つの引数で呼び出される組み込み関数 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> と同じで、左引数を右引数乗して与えます。数値引数はまず共通の型に変換され、結果はその型です。</p>
<p>整数の被演算子では、第二引数が負でない限り、結果は被演算子と同じ型になります; 第二引数が負の場合、全ての引数は浮動小数点型に変換され、浮動小数点型が返されます。例えば <code class="docutils literal notranslate"><span class="pre">10**2</span></code> は <code class="docutils literal notranslate"><span class="pre">100</span></code> を返しますが、<code class="docutils literal notranslate"><span class="pre">10**-2</span></code> は <code class="docutils literal notranslate"><span class="pre">0.01</span></code> を返します。</p>
<p><code class="docutils literal notranslate"><span class="pre">0.0</span></code> を負の数でべき乗すると <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a> を送出します。負の数を小数でべき乗した結果は複素数 (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a> number) になります。 (以前のバージョンでは <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> を送出していました)</p>
</div>
<div class="section" id="unary-arithmetic-and-bitwise-operations">
<span id="unary"></span><h2>6.6. 単項算術演算とビット単位演算 (unary arithmetic and bitwise operation)<a class="headerlink" href="#unary-arithmetic-and-bitwise-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-58">全ての単項算術演算とビット単位演算は、同じ優先順位を持っています:</p>
<pre>
<strong id="grammar-token-u-expr">u_expr</strong> ::=  <a class="reference internal" href="#grammar-token-power"><code class="xref docutils literal notranslate"><span class="pre">power</span></code></a> | &quot;-&quot; <a class="reference internal" href="#grammar-token-u-expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | &quot;+&quot; <a class="reference internal" href="#grammar-token-u-expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | &quot;~&quot; <a class="reference internal" href="#grammar-token-u-expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>
</pre>
<p id="index-59">単項演算子 <code class="docutils literal notranslate"><span class="pre">-</span></code> (マイナス) は、引数となる数値の符号を反転 (negation) します。</p>
<p id="index-60">単項演算子 <code class="docutils literal notranslate"><span class="pre">+</span></code> (プラス) は、数値引数を変更しません。</p>
<p id="index-61">単項演算子 <code class="docutils literal notranslate"><span class="pre">~</span></code> (反転) は、整数引数をビット単位反転 (bitwise invert) したものを与えます。<code class="docutils literal notranslate"><span class="pre">x</span></code> のビット単位反転は、<code class="docutils literal notranslate"><span class="pre">-(x+1)</span></code> として定義されています。この演算子は整数にのみ適用されます。</p>
<p id="index-62">上記の三つはいずれも、引数が正しい型でない場合には <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 例外が送出されます。</p>
</div>
<div class="section" id="binary-arithmetic-operations">
<span id="binary"></span><h2>6.7. 二項算術演算 (binary arithmetic operation)<a class="headerlink" href="#binary-arithmetic-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-63">二項算術演算は、慣習的な優先順位を踏襲しています。演算子のいずれかは、特定の非数値型にも適用されるので注意してください。べき乗 (power) 演算子を除き、演算子には二つのレベル、すなわち乗算的 (multiplicatie) 演算子と加算的 (additie) 演算子しかありません:</p>
<pre>
<strong id="grammar-token-m-expr">m_expr</strong> ::=  <a class="reference internal" href="#grammar-token-u-expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-m-expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;*&quot; <a class="reference internal" href="#grammar-token-u-expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-m-expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;&#64;&quot; <a class="reference internal" href="#grammar-token-m-expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> |
            <a class="reference internal" href="#grammar-token-m-expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;//&quot; <a class="reference internal" href="#grammar-token-u-expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-m-expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;/&quot; <a class="reference internal" href="#grammar-token-u-expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> |
            <a class="reference internal" href="#grammar-token-m-expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;%&quot; <a class="reference internal" href="#grammar-token-u-expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>
<strong id="grammar-token-a-expr">a_expr</strong> ::=  <a class="reference internal" href="#grammar-token-m-expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-a-expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> &quot;+&quot; <a class="reference internal" href="#grammar-token-m-expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-a-expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> &quot;-&quot; <a class="reference internal" href="#grammar-token-m-expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a>
</pre>
<p id="index-64"><code class="docutils literal notranslate"><span class="pre">*</span></code> (乗算: multiplication) 演算子は、引数同士の積を与えます。引数は、両方とも数値であるか、片方が整数で他方がシーケンスかのどちらかでなければなりません。前者の場合、数値は共通の型に変換された後乗算されます。後者の場合、シーケンスの繰り返し操作が行われます。繰り返し数を負にすると、空のシーケンスを与えます。</p>
<p id="index-65"><code class="docutils literal notranslate"><span class="pre">&#64;</span></code> (at) 演算子は行列の乗算に対し使用されます。
Python の組み込み型はこの演算子を実装していません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
<p id="index-66"><code class="docutils literal notranslate"><span class="pre">/</span></code> (除算: division) および <code class="docutils literal notranslate"><span class="pre">//</span></code> (切り捨て除算: floor division) は、引数同士の商を与えます。数値引数はまず共通の型に変換されます。整数の除算結果は浮動小数点になりますが、整数の切り捨て除算結果は整数になります; この場合、結果は数学的な除算に 'floor' 関数 を適用したものになります。ゼロによる除算を行うと <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a> 例外を送出します。</p>
<p id="index-67"><code class="docutils literal notranslate"><span class="pre">%</span></code> (剰余: modulo) 演算は、第一引数を第二引数で除算したときの剰余になります。数値引数はまず共通の型に変換されます。右引数値がゼロの場合には <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a> 例外が送出されます。引数値は浮動小数点でもよく。例えば <code class="docutils literal notranslate"><span class="pre">3.14%0.7</span></code> は <code class="docutils literal notranslate"><span class="pre">0.34</span></code> になります (<code class="docutils literal notranslate"><span class="pre">3.14</span></code> は <code class="docutils literal notranslate"><span class="pre">4*0.7</span> <span class="pre">+</span> <span class="pre">0.34</span></code> だからです)。剰余演算子は常に第二引数と同じ符号 (またはゼロ) の結果になります; 剰余演算の結果の絶対値は、常に第二引数の絶対値よりも小さくなります。 <a class="footnote-reference" href="#id17" id="id9">[1]</a></p>
<p>切り捨て除算演算と剰余演算は、恒等式: <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x//y)*y</span> <span class="pre">+</span> <span class="pre">(x%y)</span></code> の関係にあります。切り捨て除算や剰余はまた、組み込み関数 <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>: <code class="docutils literal notranslate"><span class="pre">divmod(x,</span> <span class="pre">y)</span> <span class="pre">==</span> <span class="pre">(x//y,</span> <span class="pre">x%y)</span></code> とも関係しています。 <a class="footnote-reference" href="#id18" id="id10">[2]</a> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">%</span></code> 演算子は、数値に対する剰余演算を行うのに加えて、文字列 (string) オブジェクトにオーバーロードされ、旧式の文字列の書式化 (いわゆる補間) を行います。文字列の書式化の構文は Python ライブラリリファレンス <a class="reference internal" href="../library/stdtypes.html#old-string-formatting"><span class="std std-ref">printf 形式の文字列書式化</span></a> 節を参照してください。</p>
<p>切り捨て除算演算子、剰余演算子、および <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> 関数は、複素数に対しては定義されていません。目的に合うならば、代わりに <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> を使って浮動小数点に変換してください。</p>
<p id="index-68"><code class="docutils literal notranslate"><span class="pre">+</span></code> (加算) 演算は、引数同士の和を与えます。引数は双方とも数値型か、双方とも同じ型のシーケンスでなければなりません。前者の場合、数値は共通の型に変換され、加算されます。後者の場合、シーケンスは結合 (concatenate) されます。</p>
<p id="index-69"><code class="docutils literal notranslate"><span class="pre">-</span></code> (減算) 演算は、引数間で減算を行った値を返します。数値引数はまず共通の型に変換されます。</p>
</div>
<div class="section" id="shifting-operations">
<span id="shifting"></span><h2>6.8. シフト演算 (shifting operation)<a class="headerlink" href="#shifting-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-70">シフト演算は、算術演算よりも低い優先順位を持っています:</p>
<pre>
<strong id="grammar-token-shift-expr">shift_expr</strong> ::=  <a class="reference internal" href="#grammar-token-a-expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> | <a class="reference internal" href="#grammar-token-shift-expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a> (&quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot;) <a class="reference internal" href="#grammar-token-a-expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a>
</pre>
<p>これらは整数を引数にとります。引数は共通の型に変換されます。シフト演算は第一引数を、第二引数で与えられたビット数だけ、左または右にビットシフトします。</p>
<p id="index-71"><em>n</em> ビットの右シフトは <code class="docutils literal notranslate"><span class="pre">pow(2,n)</span></code> による除算として定義されます。<em>n</em> ビットの左シフトは <code class="docutils literal notranslate"><span class="pre">pow(2,n)</span></code> による乗算として定義されます。</p>
</div>
<div class="section" id="binary-bitwise-operations">
<span id="bitwise"></span><h2>6.9. ビット単位演算の二項演算 (binary bitwise operation)<a class="headerlink" href="#binary-bitwise-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-72">以下の三つのビット単位演算には、それぞれ異なる優先順位レベルがあります:</p>
<pre>
<strong id="grammar-token-and-expr">and_expr</strong> ::=  <a class="reference internal" href="#grammar-token-shift-expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a> | <a class="reference internal" href="#grammar-token-and-expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a> &quot;&amp;&quot; <a class="reference internal" href="#grammar-token-shift-expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a>
<strong id="grammar-token-xor-expr">xor_expr</strong> ::=  <a class="reference internal" href="#grammar-token-and-expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a> | <a class="reference internal" href="#grammar-token-xor-expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a> &quot;^&quot; <a class="reference internal" href="#grammar-token-and-expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a>
<strong id="grammar-token-or-expr">or_expr </strong> ::=  <a class="reference internal" href="#grammar-token-xor-expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a> | <a class="reference internal" href="#grammar-token-or-expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a> &quot;|&quot; <a class="reference internal" href="#grammar-token-xor-expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a>
</pre>
<p id="index-73"><code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 演算子は、引数同士のビット単位の AND を与えます。引数は整数でなければなりません。</p>
<p id="index-74"><code class="docutils literal notranslate"><span class="pre">^</span></code> 演算子は、引数同士のビット単位の XOR (排他的 OR) を与えます。引数は整数でなければなりません。</p>
<p id="index-75"><code class="docutils literal notranslate"><span class="pre">|</span></code> 演算子は、引数同士のビット単位の (包含的) OR を与えます。引数は整数でなければなりません。</p>
</div>
<div class="section" id="comparisons">
<span id="id11"></span><h2>6.10. 比較<a class="headerlink" href="#comparisons" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-76">C 言語と違って、Python における比較演算子は同じ優先順位をもっており、全ての算術演算子、シフト演算子、ビット単位演算子よりも低くなっています。また <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">c</span></code> が数学で伝統的に用いられているのと同じ解釈になる点も C 言語と違います:</p>
<pre>
<strong id="grammar-token-comparison">comparison   </strong> ::=  <a class="reference internal" href="#grammar-token-or-expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a> (<a class="reference internal" href="#grammar-token-comp-operator"><code class="xref docutils literal notranslate"><span class="pre">comp_operator</span></code></a> <a class="reference internal" href="#grammar-token-or-expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>)*
<strong id="grammar-token-comp-operator">comp_operator</strong> ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;==&quot; | &quot;&gt;=&quot; | &quot;&lt;=&quot; | &quot;!=&quot;
                   | &quot;is&quot; [&quot;not&quot;] | [&quot;not&quot;] &quot;in&quot;
</pre>
<p>比較演算の結果はブール値: <code class="docutils literal notranslate"><span class="pre">True</span></code> または <code class="docutils literal notranslate"><span class="pre">False</span></code> になります。</p>
<p id="index-77">比較はいくらでも連鎖することができます。例えば <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> は <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> と等価になります。ただしこの場合、前者では <code class="docutils literal notranslate"><span class="pre">y</span></code> はただ一度だけ評価される点が異なります (どちらの場合でも、 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> が偽になると <code class="docutils literal notranslate"><span class="pre">z</span></code> の値はまったく評価されません)。</p>
<p>形式的には、 <em>a</em>, <em>b</em>, <em>c</em>, ..., <em>y</em>, <em>z</em> が式で <em>op1</em>, <em>op2</em>, ..., <em>opN</em> が比較演算子である場合、 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code> は <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">and</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">and</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code> と等価になります。ただし、前者では各式は多くても一度しか評価されません。</p>
<p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span></code> と書いた場合、 <em>a</em> から <em>c</em> までの範囲にあるかどうかのテストを指すのではないことに注意してください。例えば <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> は (きれいな書き方ではありませんが) 完全に正しい文法です。</p>
<div class="section" id="value-comparisons">
<h3>6.10.1. 値の比較<a class="headerlink" href="#value-comparisons" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>演算子 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, および <code class="docutils literal notranslate"><span class="pre">!=</span></code> は2つのオブジェクトの値を比較します。
オブジェクトが同じ型を持つ必要はりません。</p>
<p><a class="reference internal" href="datamodel.html#objects"><span class="std std-ref">オブジェクト、値、および型</span></a> の章では、オブジェクトは (型や id のに加えて) 値を持つことを述べています。
オブジェクトの値は Python ではやや抽象的な概念です: 例えば、オブジェクトの値にアクセスする正統な方法はありません。
また、その全てのデータ属性から構成されるなどの特定の方法で、オブジェクトの値を構築する必要性もありません。
比較演算子は、オブジェクトの値とは何かについての特定の概念を実装しています。
この比較の実装によって、間接的にオブジェクトの値を定義している考えることもできます。</p>
<p>全ての型は (直接的あるいは間接的に) <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> のサブクラスとなっているので、デフォルトの比較の振る舞いを <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> から継承しています。
<a class="reference internal" href="datamodel.html#customization"><span class="std std-ref">基本的なカスタマイズ</span></a> で解説されているように、型を使って <em class="dfn">rich comparison methods</em> である <a class="reference internal" href="datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> などのメソッドを実装することで、 比較の振る舞いをカスタマイズできます。</p>
<p>等価比較 (<code class="docutils literal notranslate"><span class="pre">==</span></code> および <code class="docutils literal notranslate"><span class="pre">!=</span></code>) のデフォルトの振る舞いは、オブジェクトの同一性に基づいています。
従って、同一のインスタンスの等価比較の結果は等しいとなり、同一でないインスタンスの等価比較の結果は等しくないとなります。
デフォルトの振る舞いをこのようにしたのは、全てのオブジェクトを反射的 (reflexive つまり <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> ならば <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code>) なものにしたかったからです。</p>
<p>デフォルトの順序比較 (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>) は提供されません; 比較しようとすると <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> が送出されます。
この振る舞いをデフォルトの振る舞いにした動機は、等価性と同じような不変性が欠けているからです。</p>
<p>同一でないインスタンスは常に等価でないとする等価比較のデフォルトの振る舞いは、型が必要とするオブジェクトの値や値に基づいた等価性の実用的な定義とは対照的に思えるでしょう。
そのような型では比較の振る舞いをカスタマイズする必要が出てきて、実際にたくさんの組み込み型でそれが行われています。</p>
<p>次のリストでは、最重要の組み込み型の比較の振る舞いを解説しています。</p>
<ul>
<li><p class="first">いくつかの組み込みの数値型 (<a class="reference internal" href="../library/stdtypes.html#typesnumeric"><span class="std std-ref">数値型 int, float, complex</span></a>) と標準ライブラリの型 <a class="reference internal" href="../library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a> および <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a> は、これらの型の範囲で異なる型とも比較できますが、複素数では順序比較がサポートされていないという制限があります。
関わる型の制限の範囲内では、精度のロス無しに数学的に (アルゴリズム的に) 正しい比較が行われます。</p>
<p>非数値である <code class="docutils literal notranslate"><span class="pre">float('NaN')</span></code> と <code class="docutils literal notranslate"><span class="pre">decimal.Decimal('NaN')</span></code> は特別です。
数と非数値との任意の順序比較は偽です。
直観に反する帰結として、非数値は自分自身と等価ではないことになります。
例えば <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">float('NaN')</span></code> ならば、 <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">&lt;</span> <span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">3</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">x</span></code> は全て偽で、<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">x</span></code> は真です。
この振る舞いは IEEE 754 に従ったものです。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">None</span></code> and <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> are singletons.  <span class="target" id="index-78"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0008"><strong>PEP 8</strong></a> advises that
comparisons for singletons should always be done with <code class="docutils literal notranslate"><span class="pre">is</span></code> or <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code>,
never the equality operators.</p>
</li>
<li><p class="first">バイナリシーケンス (<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> または <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> のインスタンス) は、これらの型の範囲で異なる型とも比較できます。
比較は要素の数としての値を使った辞書式順序で行われます。</p>
</li>
<li><p class="first">文字列 (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> のインスタンス) の比較は、文字の Unicode のコードポイントの数としての値 (組み込み関数 <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a> の返り値) を使った辞書式順序で行われます。 <a class="footnote-reference" href="#id19" id="id12">[3]</a></p>
<p>文字列とバイナリシーケンスは直接には比較できません。</p>
</li>
<li><p class="first">シーケンス (<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, or <a class="reference internal" href="../library/stdtypes.html#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a> のインスタンス) の比較は、同じ型どうしでしか行えず、 range は順序比較をサポートしていません。
異なる型どうしの等価比較の結果は等価でないとなり、異なる型どうしの順序比較は <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> を送出します。</p>
<p>Sequences compare lexicographically using comparison of corresponding
elements.  The built-in containers typically assume identical objects are
equal to themselves.  That lets them bypass equality tests for identical
objects to improve performance and to maintain their internal invariants.</p>
<p>組み込みのコレクションどうしの辞書式比較は次のように動作します:</p>
<ul class="simple">
<li>比較の結果が等価となる2つのコレクションは、同じ型、同じ長さ、対応する要素どうしの比較の結果が等価でなければなりません (例えば、 <code class="docutils literal notranslate"><span class="pre">[1,2]</span> <span class="pre">==</span> <span class="pre">(1,2)</span></code> は型が同じでないので偽です)。</li>
<li>順序比較をサポートしているコレクションの順序は、最初の等価でない要素の順序と同じになります (例えば、 <code class="docutils literal notranslate"><span class="pre">[1,2,x]</span> <span class="pre">&lt;=</span> <span class="pre">[1,2,y]</span></code> は <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y``と同じ値になります)。</span>
<span class="pre">対応する要素が存在しない場合、短い方のコレクションの方が先の順序となります</span> <span class="pre">(例えば、</span> <span class="pre">``[1,2]</span> <span class="pre">&lt;</span> <span class="pre">[1,2,3]</span></code> は真です)。</li>
</ul>
</li>
<li><p class="first">マッピング (<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> のインスタンス) の比較の結果が等価となるのは、同じ <cite>(key, value)</cite> を持っているときかつそのときに限ります。
キーと値の等価比較では反射性が強制されます。</p>
<p>順序比較 (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>) は <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> を送出します。</p>
</li>
<li><p class="first">集合 (<a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> または <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> のインスタンス) の比較は、これらの型の範囲で異なる型とも行えます。</p>
<p>集合には、部分集合あるいは上位集合かどうかを基準とする順序比較が定義されています。
この関係は全順序を定義しません (例えば、 <code class="docutils literal notranslate"><span class="pre">{1,2}</span></code> と <code class="docutils literal notranslate"><span class="pre">{2,3}</span></code> という2つの集合は片方がもう一方の部分集合でもなく上位集合でもありません)。
従って、集合は全順序性に依存する関数の引数として適切ではありません (例えば、 <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> は集合のリストを入力として与えると未定義な結果となります)。</p>
<p>集合の比較では、その要素の反射性が強制されます。</p>
</li>
<li><p class="first">他の組み込み型のほとんどは比較メソッドが実装されておらず、デフォルトの比較の振る舞いを継承します。</p>
</li>
</ul>
<p>比較の振る舞いをカスタマイズしたユーザ定義クラスは、可能なら次の一貫性の規則に従う必要があります:</p>
<ul>
<li><p class="first">等価比較は反射的でなければなりません。
つまり、同一のオブジェクトは等しくなければなりません:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> ならば <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code></p>
</div></blockquote>
</li>
<li><p class="first">比較は対称的でなければなりません。
つまり、以下の式の結果は同じでなければなりません:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">==</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">!=</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&gt;=</span> <span class="pre">x</span></code></p>
</div></blockquote>
</li>
<li><p class="first">比較は推移的でなければなりません。
以下の (包括的でない) 例がその説明です:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> ならば <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">z</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> ならば <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">z</span></code></p>
</div></blockquote>
</li>
<li><p class="first">比較の逆は真偽値の否定でなければなりません。
つまり、以下の式の結果は同じでなければなりません:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> と <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> と <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code> (全順序の場合)</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> と <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> (全順序の場合)</p>
</div></blockquote>
<p>最後の2式は全順序コレクションに当てはまります (たとえばシーケンスには当てはまりますが、集合やマッピングには当てはまりません)。
<a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">total_ordering()</span></code></a> デコレータも参照してください。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> の結果は等価性と一貫している必要があります。
等価なオブジェクトどうしは同じハッシュ値を持つか、ハッシュ値が計算できないものとされる必要があります。</p>
</li>
</ul>
<p>Python はこの一貫性規則を強制しません。
事実、非数値がこの規則に従わない例となります。</p>
</div>
<div class="section" id="membership-test-operations">
<span id="membership-test-details"></span><span id="not-in"></span><span id="in"></span><h3>6.10.2. 所属検査演算<a class="headerlink" href="#membership-test-operations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>演算子 <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> および <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a> は所属関係を調べます。
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code> の評価は、 <em>x</em> が <em>s</em> の要素であれば <code class="docutils literal notranslate"><span class="pre">True</span></code> となり、そうでなければ <code class="docutils literal notranslate"><span class="pre">False</span></code> となります。
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></code> は <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code> の否定を返します。
すべての組み込みのシーケンス型と集合型に加えて、辞書も <code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code> を辞書が与えられたキーを持っているかを調べる演算子としてサポートしています。
リスト、タプル、集合、凍結集合、辞書、 collections.deque のようなコンテナ型において、式 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> は <code class="docutils literal notranslate"><span class="pre">any(x</span> <span class="pre">is</span> <span class="pre">e</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">e</span> <span class="pre">for</span> <span class="pre">e</span> <span class="pre">in</span> <span class="pre">y)</span></code> と等価です。</p>
<p>文字列やバイト列型については、 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> は <em>x</em> が <em>y</em> の部分文字列であるとき、かつそのときに限り <code class="docutils literal notranslate"><span class="pre">True</span></code> になります。これは <code class="docutils literal notranslate"><span class="pre">y.find(x)</span> <span class="pre">!=</span> <span class="pre">-1</span></code> と等価です。空文字列は、他の任意の文字列の部分文字列とみなされます。従って <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span> <span class="pre">in</span> <span class="pre">&quot;abc&quot;</span></code> は <code class="docutils literal notranslate"><span class="pre">True</span></code> を返すことになります。</p>
<p><a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> メソッドを実装したユーザ定義クラスでは、 <code class="docutils literal notranslate"><span class="pre">y.__contains__(x)</span></code> の返り値が真となる場合に <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> の返り値は <code class="docutils literal notranslate"><span class="pre">True</span></code> となり、そうでない場合は <code class="docutils literal notranslate"><span class="pre">False</span></code> となります。</p>
<p>For user-defined classes which do not define <a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> but do define
<a class="reference internal" href="datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> if some value <code class="docutils literal notranslate"><span class="pre">z</span></code>, for which the
expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">z</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">z</span></code> is true, is produced while iterating over <code class="docutils literal notranslate"><span class="pre">y</span></code>.
If an exception is raised during the iteration, it is as if <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> raised
that exception.</p>
<p>Lastly, the old-style iteration protocol is tried: if a class defines
<a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> if and only if there is a non-negative
integer index <em>i</em> such that <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y[i]</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">y[i]</span></code>, and no lower integer index
raises the <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> exception.  (If any other exception is raised, it is as
if <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> raised that exception).</p>
<p id="index-79">演算子 <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a> は <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> の真理値を反転した値として定義されています。</p>
</div>
<div class="section" id="is-not">
<span id="is"></span><span id="index-80"></span><span id="identity-comparisons"></span><h3>6.10.3. 同一性の比較<a class="headerlink" href="#is-not" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>演算子 <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> および <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></a> は、オブジェクトの同一性に対するテストを行います: <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> は、 <em>x</em> と <em>y</em> が同じオブジェクトを指すとき、かつそのときに限り真になります。
オブジェクトの同一性は <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id()</span></code></a> 関数を使って判定されます。
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">y</span></code> は <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> の真値を反転したものになります。 <a class="footnote-reference" href="#id20" id="id13">[4]</a></p>
</div>
</div>
<div class="section" id="boolean-operations">
<span id="not"></span><span id="or"></span><span id="and"></span><span id="booleans"></span><h2>6.11. ブール演算 (boolean operation)<a class="headerlink" href="#boolean-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-81">
<strong id="grammar-token-or-test">or_test </strong> ::=  <a class="reference internal" href="#grammar-token-and-test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a> | <a class="reference internal" href="#grammar-token-or-test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> &quot;or&quot; <a class="reference internal" href="#grammar-token-and-test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a>
<strong id="grammar-token-and-test">and_test</strong> ::=  <a class="reference internal" href="#grammar-token-not-test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a> | <a class="reference internal" href="#grammar-token-and-test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a> &quot;and&quot; <a class="reference internal" href="#grammar-token-not-test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a>
<strong id="grammar-token-not-test">not_test</strong> ::=  <a class="reference internal" href="#grammar-token-comparison"><code class="xref docutils literal notranslate"><span class="pre">comparison</span></code></a> | &quot;not&quot; <a class="reference internal" href="#grammar-token-not-test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a>
</pre>
<p>ブール演算のコンテキストや、式が制御フローの文で使われる際には、次の値は偽だと解釈されます: <code class="docutils literal notranslate"><span class="pre">False</span></code> 、 <code class="docutils literal notranslate"><span class="pre">None</span></code> 、すべての型における数値の 0、空の文字列、空のコンテナ (文字列、タプル、リスト、辞書、集合、凍結集合など)。
それ以外の値は真だと解釈されます。
ユーザ定義のオブジェクトは、 <a class="reference internal" href="datamodel.html#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> メソッドを与えることで、真偽値をカスタマイズできます。</p>
<p id="index-82">演算子 <a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a> は、引数が偽である場合には <code class="docutils literal notranslate"><span class="pre">True</span></code> を、それ以外の場合には <code class="docutils literal notranslate"><span class="pre">False</span></code> になります。</p>
<p id="index-83">式 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></code> は、まず <em>x</em> を評価します; <em>x</em> が偽なら <em>x</em> の値を返します; それ以外の場合には、 <em>y</em> の値を評価し、その結果を返します。</p>
<p id="index-84">式 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></code> は、まず <em>x</em> を評価します; <em>x</em> が真なら <em>x</em> の値を返します; それ以外の場合には、 <em>y</em> の値を評価し、その結果を返します。</p>
<p>なお、 <a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code></a> も <a class="reference internal" href="#or"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code></a> も、返す値を <code class="docutils literal notranslate"><span class="pre">True</span></code> や <code class="docutils literal notranslate"><span class="pre">False</span></code> に制限せず、最後に評価した引数を返します。
この仕様が便利なときもあります。例えば <code class="docutils literal notranslate"><span class="pre">s</span></code> が文字列で、空文字列ならデフォルトの値に置き換えたいとき、式 <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">or</span> <span class="pre">'foo'</span></code> は望んだ値を与えます。
<a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a> は必ず新しい値を作成するので、引数の型に関係なくブール値を返します (例えば、 <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">'foo'</span></code> は <code class="docutils literal notranslate"><span class="pre">''</span></code> ではなく <code class="docutils literal notranslate"><span class="pre">False</span></code> になります)。</p>
</div>
<div class="section" id="assignment-expressions">
<h2>6.12. 代入式<a class="headerlink" href="#assignment-expressions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre>
<strong id="grammar-token-assignment-expression">assignment_expression</strong> ::=  [<a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> &quot;:=&quot;] <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>代入式に関してより詳しくは <span class="target" id="index-115"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0572"><strong>PEP 572</strong></a> を参照してください。</p>
</div>
<div class="section" id="conditional-expressions">
<span id="if-expr"></span><h2>6.13. 条件式 (Conditional Expressions)<a class="headerlink" href="#conditional-expressions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-86">
<strong id="grammar-token-conditional-expression">conditional_expression</strong> ::=  <a class="reference internal" href="#grammar-token-or-test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [&quot;if&quot; <a class="reference internal" href="#grammar-token-or-test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> &quot;else&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
<strong id="grammar-token-expression">expression            </strong> ::=  <a class="reference internal" href="#grammar-token-conditional-expression"><code class="xref docutils literal notranslate"><span class="pre">conditional_expression</span></code></a> | <a class="reference internal" href="#grammar-token-lambda-expr"><code class="xref docutils literal notranslate"><span class="pre">lambda_expr</span></code></a>
<strong id="grammar-token-expression-nocond">expression_nocond     </strong> ::=  <a class="reference internal" href="#grammar-token-or-test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> | <a class="reference internal" href="#grammar-token-lambda-expr-nocond"><code class="xref docutils literal notranslate"><span class="pre">lambda_expr_nocond</span></code></a>
</pre>
<p>条件式 (しばしば &quot;三項演算子&quot; と呼ばれます) は最も優先度が低いPython の演算です。</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">if</span> <span class="pre">C</span> <span class="pre">else</span> <span class="pre">y</span></code> という式は最初に条件 <em>x</em> ではなく <em>C</em> を評価します; <em>C</em> が true の場合 <em>x</em> が評価され値が返されます; それ以外の場合には <em>y</em> が評価され返されます。</p>
<p>条件演算に関してより詳しくは <span class="target" id="index-116"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0308"><strong>PEP 308</strong></a> を参照してください。</p>
</div>
<div class="section" id="lambda">
<span id="lambdas"></span><span id="id14"></span><h2>6.14. ラムダ (lambda)<a class="headerlink" href="#lambda" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-88">
<strong id="grammar-token-lambda-expr">lambda_expr       </strong> ::=  &quot;lambda&quot; [<a class="reference internal" href="compound_stmts.html#grammar-token-parameter-list"><code class="xref docutils literal notranslate"><span class="pre">parameter_list</span></code></a>] &quot;:&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-lambda-expr-nocond">lambda_expr_nocond</strong> ::=  &quot;lambda&quot; [<a class="reference internal" href="compound_stmts.html#grammar-token-parameter-list"><code class="xref docutils literal notranslate"><span class="pre">parameter_list</span></code></a>] &quot;:&quot; <a class="reference internal" href="#grammar-token-expression-nocond"><code class="xref docutils literal notranslate"><span class="pre">expression_nocond</span></code></a>
</pre>
<p>ラムダ式 (ラムダ形式とも呼ばれます) は無名関数を作成するのに使います。
式 <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">parameters:</span> <span class="pre">expression</span></code> は関数オブジェクトになります。
この無名オブジェクトは以下に定義されている関数オブジェクト同様に動作します:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def &lt;lambda&gt;(parameters):
    return expression
</pre></div>
</div>
<p>引数の一覧の構文は <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> を参照してください。ラムダ式で作成された関数は文やアノテーションを含むことができない点に注意してください。</p>
</div>
<div class="section" id="expression-lists">
<span id="exprlists"></span><h2>6.15. 式のリスト<a class="headerlink" href="#expression-lists" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-89">
<strong id="grammar-token-expression-list">expression_list   </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-starred-list">starred_list      </strong> ::=  <a class="reference internal" href="#grammar-token-starred-item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-starred-item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-starred-expression">starred_expression</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | (<a class="reference internal" href="#grammar-token-starred-item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a> &quot;,&quot;)* [<a class="reference internal" href="#grammar-token-starred-item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a>]
<strong id="grammar-token-starred-item">starred_item      </strong> ::=  <a class="reference internal" href="#grammar-token-assignment-expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> | &quot;*&quot; <a class="reference internal" href="#grammar-token-or-expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>
</pre>
<p id="index-90">リスト表示や辞書表示の一部になっているものを除き、少なくとも一つのカンマを含む式のリストはタプルになります。
タプルの長さは、リストにある式の数に等しくなります。
式は左から右へ評価されます。</p>
<p id="index-91">アスタリスク <code class="docutils literal notranslate"><span class="pre">*</span></code> は <em class="dfn">イテラブルのアンパック</em> を意味します。
この被演算子は <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">イテラブル</span></a> でなければなりません。
このイテラブルはアンパックされた位置で要素のシーケンスに展開され、新しいタプル、リスト、集合に入れ込まれます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加: </span>式リストでのイテラブルのアンパックは最初に <span class="target" id="index-117"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0448"><strong>PEP 448</strong></a> で提案されました。</p>
</div>
<p id="index-93">単一要素のタプル (別名 <em>単集合 (singleton)</em> ) を作りたければ、末尾にカンマが必要です。単一の式だけで、末尾にカンマをつけない場合には、タプルではなくその式の値になります (空のタプルを作りたいなら、中身が空の丸括弧ペア: <code class="docutils literal notranslate"><span class="pre">()</span></code> を使います。)</p>
</div>
<div class="section" id="evaluation-order">
<span id="evalorder"></span><h2>6.16. 評価順序<a class="headerlink" href="#evaluation-order" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-94">Python は、式を左から右へと順に評価します。
ただし、代入式を評価するときは、右辺が左辺よりも先に評価されます。</p>
<p>以下に示す実行文の各行での評価順序は、添え字の数字順序と同じになります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span>
<span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span><span class="p">)</span>
<span class="p">{</span><span class="n">expr1</span><span class="p">:</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">:</span> <span class="n">expr4</span><span class="p">}</span>
<span class="n">expr1</span> <span class="o">+</span> <span class="n">expr2</span> <span class="o">*</span> <span class="p">(</span><span class="n">expr3</span> <span class="o">-</span> <span class="n">expr4</span><span class="p">)</span>
<span class="n">expr1</span><span class="p">(</span><span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="o">*</span><span class="n">expr4</span><span class="p">,</span> <span class="o">**</span><span class="n">expr5</span><span class="p">)</span>
<span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span> <span class="o">=</span> <span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span>
</pre></div>
</div>
</div>
<div class="section" id="operator-precedence">
<span id="operator-summary"></span><h2>6.17. 演算子の優先順位<a class="headerlink" href="#operator-precedence" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-95">以下の表は Python における演算子の優先順位を要約したものです。優先順位の最も低い (結合が最も弱い) ものから最も高い (結合が最も強い) ものに並べてあります。同じボックス内の演算子の優先順位は同じです。構文が明示的に示されていないものは二項演算子です。同じボックス内の演算子は、左から右へとグループ化されます (例外として、べき乗は右から左にグループ化されます)。</p>
<p><a class="reference internal" href="#comparisons"><span class="std std-ref">比較</span></a> 節で述べられているように、比較、所属、同一性のテストは全てが同じ優先順位を持っていて、左から右に連鎖するという特徴を持っていることに注意してください。</p>
<table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算子</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">:=</span></code></td>
<td>代入式</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a></td>
<td>ラムダ式</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#if-expr"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> -- <code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></td>
<td>条件式</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#or"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code></a></td>
<td>ブール演算 OR</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code></a></td>
<td>ブール演算 AND</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a> <code class="docutils literal notranslate"><span class="pre">x</span></code></td>
<td>ブール演算 NOT</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a>, <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>,
<a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a>, <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></a>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code></td>
<td>所属や同一性のテストを含む比較</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">|</span></code></td>
<td>ビット単位 OR</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">^</span></code></td>
<td>ビット単位 XOR</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">&amp;</span></code></td>
<td>ビット単位 AND</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code></td>
<td>シフト演算</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code></td>
<td>加算および減算</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code></td>
<td>乗算、行列乗算、除算、切り捨て除算、剰余 <a class="footnote-reference" href="#id21" id="id15">[5]</a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">+x</span></code>, <code class="docutils literal notranslate"><span class="pre">-x</span></code>, <code class="docutils literal notranslate"><span class="pre">~x</span></code></td>
<td>正数、負数、ビット単位 NOT</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">**</span></code></td>
<td>べき乗 <a class="footnote-reference" href="#id22" id="id16">[6]</a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> <code class="docutils literal notranslate"><span class="pre">x</span></code></td>
<td>Await 式</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">x[index]</span></code>, <code class="docutils literal notranslate"><span class="pre">x[index:index]</span></code>,
<code class="docutils literal notranslate"><span class="pre">x(arguments...)</span></code>, <code class="docutils literal notranslate"><span class="pre">x.attribute</span></code></td>
<td>添字指定、スライス操作、呼び出し、属性参照</td>
</tr>
<tr class="row-odd"><td><p class="first"><code class="docutils literal notranslate"><span class="pre">(expressions...)</span></code>,</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">[expressions...]</span></code>,
<code class="docutils literal notranslate"><span class="pre">{key:</span> <span class="pre">value...}</span></code>,
<code class="docutils literal notranslate"><span class="pre">{expressions...}</span></code></p>
</td>
<td>結合式または括弧式、リスト表示、辞書表示、集合表示</td>
</tr>
</tbody>
</table>
<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[1]</a></td><td><code class="docutils literal notranslate"><span class="pre">abs(x%y)</span> <span class="pre">&lt;</span> <span class="pre">abs(y)</span></code> は数学的には真となりますが、浮動小数点に対する演算の場合には、値丸め (roundoff) のために数値計算的に真にならない場合があります。例えば、Python の浮動小数点型が IEEE754 倍精度数型になっているプラットフォームを仮定すると、 <code class="docutils literal notranslate"><span class="pre">-1e-100</span> <span class="pre">%</span> <span class="pre">1e100</span></code> は <code class="docutils literal notranslate"><span class="pre">1e100</span></code> と同じ符号になるはずなのに、計算結果は <code class="docutils literal notranslate"><span class="pre">-1e-100</span> <span class="pre">+</span> <span class="pre">1e100</span></code> となります。これは数値計算的には厳密に <code class="docutils literal notranslate"><span class="pre">1e100</span></code> と等価です。関数 <a class="reference internal" href="../library/math.html#math.fmod" title="math.fmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.fmod()</span></code></a> は、最初の引数と符号が一致するような値を返すので、上記の場合には <code class="docutils literal notranslate"><span class="pre">-1e-100</span></code> を返します。どちらのアプローチが適切かは、アプリケーションに依存します。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[2]</a></td><td>x が y の正確な整数倍に非常に近いと、丸めのために <code class="docutils literal notranslate"><span class="pre">x//y</span></code> が <code class="docutils literal notranslate"><span class="pre">(x-x%y)//y</span></code> よりも 1 だけ大きくなる可能性があります。そのような場合、Python は <code class="docutils literal notranslate"><span class="pre">divmod(x,y)[0]</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code> が <code class="docutils literal notranslate"><span class="pre">x</span></code> に非常に近くなるという関係を保つために、後者の値を返します。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[3]</a></td><td><p class="first">Unicode 標準では、 <em class="dfn">コードポイント (code point)</em> (例えば、U+0041) と <em class="dfn">抽象文字 (abstract character)</em> (例えば、&quot;LATIN CAPITAL LETTER A&quot;) を区別します。
Unicode のほとんどの抽象文字は 1 つのコードポイントだけを使って表現されますが、複数のコードポイントの列を使っても表現できる抽象文字もたくさんあります。
例えば、抽象文字 &quot;LATIN CAPITAL LETTER C WITH CEDILLA&quot; はコード位置 U+00C7 にある <em class="dfn">合成済み文字 (precomposed character)</em> 1 つだけでも表現できますし、コード位置 U+0043 (LATIN CAPITAL LETTER C) にある <em class="dfn">基底文字 (base character)</em> の後ろに、コード位置 U+0327 (COMBINING CEDILLA) にある <em class="dfn">結合文字 (combining character)</em> が続く列としても表現できます。</p>
<p>文字列の比較操作は Unicode のコードポイントのレベルで行われます。
これは人間にとっては直感的ではないかもしれません。
例えば、 <code class="docutils literal notranslate"><span class="pre">&quot;\u00C7&quot;</span> <span class="pre">==</span> <span class="pre">&quot;\u0043\u0327&quot;</span></code> は、どちらの文字も同じ抽象文字 &quot;LATIN CAPITAL LETTER C WITH CEDILLA&quot; を表現しているにもかかわらず、その結果は <code class="docutils literal notranslate"><span class="pre">False</span></code> となります。</p>
<p class="last">抽象文字のレベルで (つまり、人間にとって直感的な方法で) 文字列を比較するには <a class="reference internal" href="../library/unicodedata.html#unicodedata.normalize" title="unicodedata.normalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">unicodedata.normalize()</span></code></a> を使ってください。</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[4]</a></td><td>自動的なガベージコレクション、フリーリスト、ディスクリプタの動的特性のために、インスタンスメソッドや定数の比較を行うようなときに <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> 演算子の利用は、一見すると普通ではない振る舞いだと気付くかもしれません。詳細はそれぞれのドキュメントを確認してください。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[5]</a></td><td><code class="docutils literal notranslate"><span class="pre">%</span></code> 演算子は文字列フォーマットにも使われ、同じ優先順位が当てはまります。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[6]</a></td><td>べき乗演算子 <code class="docutils literal notranslate"><span class="pre">**</span></code> は、右側にある単項算術演算子あるいは単項ビット演算子より弱い結合優先順位となります。
つまり <code class="docutils literal notranslate"><span class="pre">2**-1</span></code> は <code class="docutils literal notranslate"><span class="pre">0.5</span></code> になります。</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">6. 式 (expression)</a><ul>
<li><a class="reference internal" href="#arithmetic-conversions">6.1. 算術変換 (arithmetic conversion)</a></li>
<li><a class="reference internal" href="#atoms">6.2. アトム、原子的要素 (atom)</a><ul>
<li><a class="reference internal" href="#atom-identifiers">6.2.1. 識別子 (identifier、または名前 (name))</a></li>
<li><a class="reference internal" href="#literals">6.2.2. リテラル</a></li>
<li><a class="reference internal" href="#parenthesized-forms">6.2.3. 丸括弧形式 (parenthesized form)</a></li>
<li><a class="reference internal" href="#displays-for-lists-sets-and-dictionaries">6.2.4. リスト、集合、辞書の表示</a></li>
<li><a class="reference internal" href="#list-displays">6.2.5. リスト表示</a></li>
<li><a class="reference internal" href="#set-displays">6.2.6. 集合表示</a></li>
<li><a class="reference internal" href="#dictionary-displays">6.2.7. 辞書表示</a></li>
<li><a class="reference internal" href="#generator-expressions">6.2.8. ジェネレータ式</a></li>
<li><a class="reference internal" href="#yield-expressions">6.2.9. Yield 式</a><ul>
<li><a class="reference internal" href="#generator-iterator-methods">6.2.9.1. ジェネレータ-イテレータメソッド</a></li>
<li><a class="reference internal" href="#examples">6.2.9.2. 使用例</a></li>
<li><a class="reference internal" href="#asynchronous-generator-functions">6.2.9.3. 非同期ジェネレータ関数 (asynchronous generator function)</a></li>
<li><a class="reference internal" href="#asynchronous-generator-iterator-methods">6.2.9.4. 非同期ジェネレータイテレータメソッド</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#primaries">6.3. プライマリ</a><ul>
<li><a class="reference internal" href="#attribute-references">6.3.1. 属性参照</a></li>
<li><a class="reference internal" href="#subscriptions">6.3.2. 添字表記 (subscription)</a></li>
<li><a class="reference internal" href="#slicings">6.3.3. スライス表記 (slicing)</a></li>
<li><a class="reference internal" href="#calls">6.3.4. 呼び出し (call)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#await-expression">6.4. Await 式</a></li>
<li><a class="reference internal" href="#the-power-operator">6.5. べき乗演算 (power operator)</a></li>
<li><a class="reference internal" href="#unary-arithmetic-and-bitwise-operations">6.6. 単項算術演算とビット単位演算 (unary arithmetic and bitwise operation)</a></li>
<li><a class="reference internal" href="#binary-arithmetic-operations">6.7. 二項算術演算 (binary arithmetic operation)</a></li>
<li><a class="reference internal" href="#shifting-operations">6.8. シフト演算 (shifting operation)</a></li>
<li><a class="reference internal" href="#binary-bitwise-operations">6.9. ビット単位演算の二項演算 (binary bitwise operation)</a></li>
<li><a class="reference internal" href="#comparisons">6.10. 比較</a><ul>
<li><a class="reference internal" href="#value-comparisons">6.10.1. 値の比較</a></li>
<li><a class="reference internal" href="#membership-test-operations">6.10.2. 所属検査演算</a></li>
<li><a class="reference internal" href="#is-not">6.10.3. 同一性の比較</a></li>
</ul>
</li>
<li><a class="reference internal" href="#boolean-operations">6.11. ブール演算 (boolean operation)</a></li>
<li><a class="reference internal" href="#assignment-expressions">6.12. 代入式</a></li>
<li><a class="reference internal" href="#conditional-expressions">6.13. 条件式 (Conditional Expressions)</a></li>
<li><a class="reference internal" href="#lambda">6.14. ラムダ (lambda)</a></li>
<li><a class="reference internal" href="#expression-lists">6.15. 式のリスト</a></li>
<li><a class="reference internal" href="#evaluation-order">6.16. 評価順序</a></li>
<li><a class="reference internal" href="#operator-precedence">6.17. 演算子の優先順位</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="import.html"
                        title="前の章へ">5. インポートシステム</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="simple_stmts.html"
                        title="次の章へ">7. 単純文 (simple statement)</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/reference/expressions.rst"
            rel="nofollow">ソースコードを表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. 単純文 (simple statement)"
             >次へ</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. インポートシステム"
             >前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3rc1 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 言語リファレンス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">著作権</a> 2001-2020, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最終更新: 5月 12, 2020
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>

  </body>
</html>