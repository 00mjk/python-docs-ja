
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>ssl --- ソケットオブジェクトに対する TLS/SSL ラッパー &#8212; Python 3.8.3 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.8.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="next" title="select --- I/O 処理の完了を待機する" href="select.html" />
    <link rel="prev" title="socket --- 低水準ネットワークインターフェイス" href="socket.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/ssl.html" />
    
      
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="select.html" title="select --- I/O 処理の完了を待機する"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="socket.html" title="socket --- 低水準ネットワークインターフェイス"
             accesskey="P">前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" accesskey="U">ネットワーク通信とプロセス間通信</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-ssl">
<span id="ssl-tls-ssl-wrapper-for-socket-objects"></span><h1><a class="reference internal" href="#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> --- ソケットオブジェクトに対する TLS/SSL ラッパー<a class="headerlink" href="#module-ssl" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/ssl.py">Lib/ssl.py</a></p>
<span class="target" id="index-0"></span><hr class="docutils" id="index-1" />
<p>このモジュールは Transport Layer Security ( &quot;Secure Sockets Layer&quot; という名前でよく知られています) 暗号化と、クライアントサイド、サーバサイド両方のネットワークソケットのためのピア認証の仕組みを提供しています。このモジュールは OpenSSL ライブラリを利用しています。 OpenSSL は、すべてのモダンな Unix システム、 Windows 、 Mac OS X 、その他幾つかの OpenSSL がインストールされているプラットフォームで利用できます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">OSのソケットAPIに対して実装されているので、幾つかの挙動はプラットフォーム依存になるかもしれません。インストールされているOpenSSLのバージョンの違いも挙動の違いの原因になるかもしれません。例えば、TLSv1.1, TLSv1.2 は openssl version 1.0.1 以降でのみ利用できます。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last"><a class="reference internal" href="#ssl-security"><span class="std std-ref">セキュリティで考慮すべき点</span></a> を読まずにこのモジュールを使用しないでください。SSL のデフォルト設定はアプリケーションに十分ではないので、読まない場合はセキュリティに誤った意識を持ってしまうかもしれません。</p>
</div>
<p>このセクションでは、 <code class="docutils literal notranslate"><span class="pre">ssl</span></code> モジュールのオブジェクトと関数を解説します。 TLS, SSL, 証明書に関するより一般的な情報は、末尾にある &quot;See Also&quot; のセクションを参照してください。</p>
<p>This module provides a class, <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a>, which is derived from the
<a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> type, and provides a socket-like wrapper that also
encrypts and decrypts the data going over the socket with SSL.  It supports
additional methods such as <code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeercert()</span></code>, which retrieves the
certificate of the other side of the connection, and <code class="xref py py-meth docutils literal notranslate"><span class="pre">cipher()</span></code>, which
retrieves the cipher being used for the secure connection.</p>
<p>より洗練されたアプリケーションのために、 <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> クラスが設定と証明書の管理の助けとなるでしょう。それは <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> メソッドを通して SSL ソケットを作成することで引き継がれます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5.3 で変更: </span>Updated to support linking with OpenSSL 1.1.0</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>OpenSSL 0.9.8, 1.0.0, 1.0.1 は廃止されており、もはやサポートされていません。ssl モジュールは、将来的に OpenSSL 1.0.2 または 1.1.0 を必要とするようになります。</p>
</div>
<div class="section" id="functions-constants-and-exceptions">
<h2>関数、定数、例外<a class="headerlink" href="#functions-constants-and-exceptions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="socket-creation">
<h3>ソケットの作成<a class="headerlink" href="#socket-creation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Since Python 3.2 and 2.7.9, it is recommended to use the
<a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> of an <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> instance to wrap
sockets as <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> objects. The helper functions
<a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> returns a new context with secure default
settings. The old <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> function is deprecated since it is
both inefficient and has no support for server name indication (SNI) and
hostname matching.</p>
<p>Client socket example with default context and IPv4/IPv6 dual stack:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">ssl</span>

<span class="n">hostname</span> <span class="o">=</span> <span class="s1">&#39;www.python.org&#39;</span>
<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span>

<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">create_connection</span><span class="p">((</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span> <span class="k">as</span> <span class="n">sock</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">server_hostname</span><span class="o">=</span><span class="n">hostname</span><span class="p">)</span> <span class="k">as</span> <span class="n">ssock</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ssock</span><span class="o">.</span><span class="n">version</span><span class="p">())</span>
</pre></div>
</div>
<p>Client socket example with custom context and IPv4:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">hostname</span> <span class="o">=</span> <span class="s1">&#39;www.python.org&#39;</span>
<span class="c1"># PROTOCOL_TLS_CLIENT requires valid cert chain and hostname</span>
<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLS_CLIENT</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_verify_locations</span><span class="p">(</span><span class="s1">&#39;path/to/cabundle.pem&#39;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">as</span> <span class="n">sock</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">server_hostname</span><span class="o">=</span><span class="n">hostname</span><span class="p">)</span> <span class="k">as</span> <span class="n">ssock</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ssock</span><span class="o">.</span><span class="n">version</span><span class="p">())</span>
</pre></div>
</div>
<p>Server socket example listening on localhost IPv4:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLS_SERVER</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_cert_chain</span><span class="p">(</span><span class="s1">&#39;/path/to/certchain.pem&#39;</span><span class="p">,</span> <span class="s1">&#39;/path/to/private.key&#39;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">as</span> <span class="n">sock</span><span class="p">:</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8443</span><span class="p">))</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">server_side</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">ssock</span><span class="p">:</span>
        <span class="n">conn</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">ssock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="context-creation">
<h3>コンテキストの作成<a class="headerlink" href="#context-creation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>コンビニエンス関数が、共通の目的で使用される <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> オブジェクトを作成するのに役立ちます。</p>
<dl class="function">
<dt id="ssl.create_default_context">
<code class="descclassname">ssl.</code><code class="descname">create_default_context</code><span class="sig-paren">(</span><em>purpose=Purpose.SERVER_AUTH</em>, <em>cafile=None</em>, <em>capath=None</em>, <em>cadata=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.create_default_context" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新規の <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> オブジェクトを、与えられた <em>purpose</em> のデフォルト設定で返します。設定は <a class="reference internal" href="#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> モジュールで選択され、通常は <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> のコンストラクタを直接呼び出すよりも高いセキュリティレベルを表現します。</p>
<p><em>cafile</em>, <em>capath</em>, <em>cadata</em> は証明書の検証で信用するオプションの CA 証明書で、 <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations()</span></code></a> のものと同じです。これら 3 つすべてが <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> であれば、この関数は代わりにシステムのデフォルトの CA 証明書を信用して選択することができます。</p>
<p>設定は、 <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>, <a class="reference internal" href="#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv2</span></code></a>, RC4 と非認証暗号化スイート以外の、高度暗号化スイートを利用した <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a> です。<a class="reference internal" href="#ssl.Purpose.SERVER_AUTH" title="ssl.Purpose.SERVER_AUTH"><code class="xref py py-data docutils literal notranslate"><span class="pre">SERVER_AUTH</span></code></a> を <em>purpose</em> として渡すと、<a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-data docutils literal notranslate"><span class="pre">verify_mode</span></code></a> を <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> に設定し、 CA 証明書をロードする (<em>cafile</em>, <em>capath</em>, <em>cadata</em> の少なくとも1つが与えられている場合) か、<a class="reference internal" href="#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_default_certs()</span></code></a> を使用してデフォルトの CA 証明書をロードします。</p>
<p>When <a class="reference internal" href="#ssl.SSLContext.keylog_filename" title="ssl.SSLContext.keylog_filename"><code class="xref py py-attr docutils literal notranslate"><span class="pre">keylog_filename</span></code></a> is supported and the environment
variable <span class="target" id="index-2"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">SSLKEYLOGFILE</span></code> is set, <a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a>
enables key logging.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>プロトコル、オプション、暗号方式その他の設定は、事前に非推奨の状態にすることなく、もっと制限の強い値に変更される場合があります。これらの値は、互換性と安全性との妥当なバランスをとって決められます。</p>
<p class="last">もしもあなたのアプリケーションが特定の設定を必要とする場合、 <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> を作って自分自身で設定を適用すべきです。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>ある種の古いクライアントやサーバが接続しようと試みてきた場合に、この関数で作られた <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> が &quot;Protocol or cipher suite mismatch&quot; で始まるエラーを起こすのを目撃したらそれは、この関数が <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a> を使って除外している SSL 3.0 しかサポートしていないのでしょう。SSL 3.0 は <a class="reference external" href="https://en.wikipedia.org/wiki/POODLE">完璧にぶっ壊れている</a> ことが広く知られています。それでもまだこの関数を使って、ただし SSL 3.0 接続を許可したいと望むならば、これをこのように再有効化できます:</p>
<div class="last highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">(</span><span class="n">Purpose</span><span class="o">.</span><span class="n">CLIENT_AUTH</span><span class="p">)</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">options</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ssl</span><span class="o">.</span><span class="n">OP_NO_SSLv3</span>
</pre></div>
</div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4.4 で変更: </span>デフォルトの暗号設定から RC4 が除かれました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>デフォルトの暗号化文字列に ChaCha20/Poly1305 が追加されました。</p>
<p>デフォルトの暗号化文字列から 3DES が除かれました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.8 で変更: </span>Support for key logging to <span class="target" id="index-3"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">SSLKEYLOGFILE</span></code> was added.</p>
</div>
</dd></dl>

</div>
<div class="section" id="exceptions">
<h3>例外<a class="headerlink" href="#exceptions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="exception">
<dt id="ssl.SSLError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLError</code><a class="headerlink" href="#ssl.SSLError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>(現在のところ OpenSSL ライブラリによって提供されている)下層の SSL 実装からのエラーを伝えるための例外です。このエラーは、低レベルなネットワークの上に載っている、高レベルな暗号化と認証レイヤーでの問題を通知します。このエラーは <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> のサブタイプです。 <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> インスタンスのエラーコードとメッセージは OpenSSL ライブラリによるものです。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span><a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> は以前は <a class="reference internal" href="socket.html#socket.error" title="socket.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">socket.error</span></code></a> のサブタイプでした。</p>
</div>
<dl class="attribute">
<dt id="ssl.SSLError.library">
<code class="descname">library</code><a class="headerlink" href="#ssl.SSLError.library" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>エラーが起こった OpenSSL サブモジュールを示すニーモニック文字列で、 <code class="docutils literal notranslate"><span class="pre">SSL</span></code>, <code class="docutils literal notranslate"><span class="pre">PEM</span></code>, <code class="docutils literal notranslate"><span class="pre">X509</span></code> などです。取り得る値は OpenSSL のバージョンに依存します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLError.reason">
<code class="descname">reason</code><a class="headerlink" href="#ssl.SSLError.reason" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>エラーが起こった原因を示すニーモニック文字列で、 <code class="docutils literal notranslate"><span class="pre">CERTIFICATE_VERIFY_FAILED</span></code> などです。取り得る値は OpenSSL のバージョンに依存します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="ssl.SSLZeroReturnError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLZeroReturnError</code><a class="headerlink" href="#ssl.SSLZeroReturnError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>読み出しあるいは書き込みを試みようとした際に SSL コネクションが行儀よく閉じられてしまった場合に送出される <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> サブクラス例外です。これは下層の転送(read TCP)が閉じたことは意味しないことに注意してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLWantReadError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLWantReadError</code><a class="headerlink" href="#ssl.SSLWantReadError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>読み出しあるいは書き込みを試みようとした際に、リクエストが遂行される前に下層の TCP 転送で受け取る必要があるデータが不足した場合に <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">non-blocking SSL socket</span></a> によって送出される <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> サブクラス例外です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLWantWriteError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLWantWriteError</code><a class="headerlink" href="#ssl.SSLWantWriteError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>読み出しあるいは書き込みを試みようとした際に、リクエストが遂行される前に下層の TCP 転送が送信する必要があるデータが不足した場合に <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">non-blocking SSL socket</span></a> によって送出される <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> サブクラス例外です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLSyscallError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLSyscallError</code><a class="headerlink" href="#ssl.SSLSyscallError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL ソケット上で操作を遂行しようとしていてシステムエラーが起こった場合に送出される <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> サブクラス例外です。残念ながら元となった errno 番号を調べる簡単な方法はありません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLEOFError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLEOFError</code><a class="headerlink" href="#ssl.SSLEOFError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL コネクションが唐突に打ち切られた際に送出される <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> サブクラス例外です。一般的に、このエラーが起こったら下層の転送を再利用しようと試みるべきではありません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLCertVerificationError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLCertVerificationError</code><a class="headerlink" href="#ssl.SSLCertVerificationError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A subclass of <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> raised when certificate validation has
failed.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
<dl class="attribute">
<dt id="ssl.SSLCertVerificationError.verify_code">
<code class="descname">verify_code</code><a class="headerlink" href="#ssl.SSLCertVerificationError.verify_code" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A numeric error number that denotes the verification error.</p>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLCertVerificationError.verify_message">
<code class="descname">verify_message</code><a class="headerlink" href="#ssl.SSLCertVerificationError.verify_message" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A human readable string of the verification error.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="ssl.CertificateError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">CertificateError</code><a class="headerlink" href="#ssl.CertificateError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>An alias for <a class="reference internal" href="#ssl.SSLCertVerificationError" title="ssl.SSLCertVerificationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLCertVerificationError</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.7 で変更: </span>The exception is now an alias for <a class="reference internal" href="#ssl.SSLCertVerificationError" title="ssl.SSLCertVerificationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLCertVerificationError</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="random-generation">
<h3>乱数生成<a class="headerlink" href="#random-generation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="function">
<dt id="ssl.RAND_bytes">
<code class="descclassname">ssl.</code><code class="descname">RAND_bytes</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_bytes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>暗号学的に強固な擬似乱数の <em>num</em> バイトを返します。擬似乱数生成器に十分なデータでシードが与えられていない場合や、現在の RANDOM メソッドに操作がサポートされていない場合は <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a> を送出します。 <a class="reference internal" href="#ssl.RAND_status" title="ssl.RAND_status"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_status()</span></code></a> を使って擬似乱数生成器の状態をチェックできます。
<a class="reference internal" href="#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_add()</span></code></a> を使って擬似乱数生成器にシードを与えることができます。</p>
<p>ほとんどすべてのアプリケーションでは <a class="reference internal" href="os.html#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a> が望ましいです。</p>
<p>暗号論的擬似乱数生成器に要求されることについては Wikipedia の記事 <a class="reference external" href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator">Cryptographically secure pseudorandom number generator (CSPRNG)</a> (日本語版: <a class="reference external" href="http://ja.wikipedia.org/wiki/%E6%9A%97%E5%8F%B7%E8%AB%96%E7%9A%84%E6%93%AC%E4%BC%BC%E4%B9%B1%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8">暗号論的擬似乱数生成器</a>) を参照してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_pseudo_bytes">
<code class="descclassname">ssl.</code><code class="descname">RAND_pseudo_bytes</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_pseudo_bytes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>(bytes, is_cryptographic) タプルを返却: bytes は長さ <em>num</em> の擬似乱数バイト列、 is_cryptographic は、生成されたバイト列が暗号として強ければ <code class="docutils literal notranslate"><span class="pre">True</span></code> 。 操作が現在使われている RAND メソッドでサポートされていなければ、  <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a> が送出されます。</p>
<p>生成される擬似乱数バイトシーケンスは十分な長さであれば一意にはなるでしょうが、必ずしも予測不可能とは言えません。これは非暗号目的、あるいは暗号化プロトコルでの若干の用途に使われますが、普通は鍵生成などには使いません。</p>
<p>ほとんどすべてのアプリケーションでは <a class="reference internal" href="os.html#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a> が望ましいです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.6 で非推奨: </span>OpenSSL は <a class="reference internal" href="#ssl.RAND_pseudo_bytes" title="ssl.RAND_pseudo_bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.RAND_pseudo_bytes()</span></code></a> を廃止しました。代わりに <a class="reference internal" href="#ssl.RAND_bytes" title="ssl.RAND_bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.RAND_bytes()</span></code></a> を使用してください。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_status">
<code class="descclassname">ssl.</code><code class="descname">RAND_status</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_status" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL 擬似乱数生成器が十分なランダム性(randomness)を受け取っている時に <code class="docutils literal notranslate"><span class="pre">True</span></code> を、それ以外の場合は <cite>False</cite> を返します。 <a class="reference internal" href="#ssl.RAND_egd" title="ssl.RAND_egd"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.RAND_egd()</span></code></a> と <a class="reference internal" href="#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.RAND_add()</span></code></a> を使って擬似乱数生成機にランダム性を加えることができます。</p>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_egd">
<code class="descclassname">ssl.</code><code class="descname">RAND_egd</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_egd" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>もしエントロピー収集デーモン(EGD=entropy-gathering daemon)が動いていて、 <em>path</em> がEGDへのソケットのパスだった場合、この関数はそのソケットから 256バイトのランダム性を読み込み、SSL擬似乱数生成器にそれを渡すことで、生成される暗号鍵のセキュリティを向上させることができます。これは、より良いランダム性のソースが無いシステムでのみ必要です。</p>
<p>エントロピー収集デーモンについては、 <a class="reference external" href="http://egd.sourceforge.net/">http://egd.sourceforge.net/</a> や <a class="reference external" href="http://prngd.sourceforge.net/">http://prngd.sourceforge.net/</a> を参照してください。</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not available with LibreSSL and OpenSSL &gt; 1.1.0.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_add">
<code class="descclassname">ssl.</code><code class="descname">RAND_add</code><span class="sig-paren">(</span><em>bytes</em>, <em>entropy</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_add" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた <em>bytes</em> をSSL擬似乱数生成器に混ぜます。 <em>entropy</em> 引数(float値)は、その文字列に含まれるエントロピーの下限(lower bound)です。 (なので、いつでも <code class="xref py py-const docutils literal notranslate"><span class="pre">0.0</span></code> を使うことができます。) エントロピーのソースについてのより詳しい情報は、 <span class="target" id="index-38"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1750.html"><strong>RFC 1750</strong></a> を参照してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>書き込み可能な <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> を使用できるようになりました。</p>
</div>
</dd></dl>

</div>
<div class="section" id="certificate-handling">
<h3>証明書の取り扱い<a class="headerlink" href="#certificate-handling" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="function">
<dt id="ssl.match_hostname">
<code class="descclassname">ssl.</code><code class="descname">match_hostname</code><span class="sig-paren">(</span><em>cert</em>, <em>hostname</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.match_hostname" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Verify that <em>cert</em> (in decoded format as returned by
<a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a>) matches the given <em>hostname</em>.  The rules
applied are those for checking the identity of HTTPS servers as outlined
in <span class="target" id="index-5"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2818.html"><strong>RFC 2818</strong></a>, <span class="target" id="index-6"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5280.html"><strong>RFC 5280</strong></a> and <span class="target" id="index-7"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6125.html"><strong>RFC 6125</strong></a>.  In addition to HTTPS, this
function should be suitable for checking the identity of servers in
various SSL-based protocols such as FTPS, IMAPS, POPS and others.</p>
<p>失敗すれば <a class="reference internal" href="#ssl.CertificateError" title="ssl.CertificateError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CertificateError</span></code></a> が送出されます。成功すれば、この関数は何も返しません:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cert</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s1">&#39;commonName&#39;</span><span class="p">,</span> <span class="s1">&#39;example.com&#39;</span><span class="p">),),)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">match_hostname</span><span class="p">(</span><span class="n">cert</span><span class="p">,</span> <span class="s2">&quot;example.com&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">match_hostname</span><span class="p">(</span><span class="n">cert</span><span class="p">,</span> <span class="s2">&quot;example.org&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;/home/py3k/Lib/ssl.py&quot;</span>, line <span class="m">130</span>, in <span class="n">match_hostname</span>
<span class="gr">ssl.CertificateError</span>: <span class="n">hostname &#39;example.org&#39; doesn&#39;t match &#39;example.com&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3.3 で変更: </span>この関数は <span class="target" id="index-39"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6125.html"><strong>RFC 6125</strong></a> の section 6.4.3 に従うようになりましたので、マルチプルワイルドカード(例. <code class="docutils literal notranslate"><span class="pre">*.*.com</span></code> や <code class="docutils literal notranslate"><span class="pre">*a*.example.org</span></code>) にも国際化ドメイン名 (IDN=internationalized domain name)フラグメント内部に含まれるワイルドカードのどちらにも合致しません。 <code class="docutils literal notranslate"><span class="pre">www*.xn--pthon-kva.org</span></code> のような IDN A-labels はまだサポートしますが、 <code class="docutils literal notranslate"><span class="pre">x*.python.org</span></code> はもはや <code class="docutils literal notranslate"><span class="pre">xn--tda.python.org</span></code> には合致しません。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>認定書の subjectAltName フィールドで提示されている場合、IP アドレスの一致がサポートされるようになりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.7 で変更: </span>The function is no longer used to TLS connections. Hostname matching
is now performed by OpenSSL.</p>
<p>Allow wildcard when it is the leftmost and the only character
in that segment. Partial wildcards like <code class="docutils literal notranslate"><span class="pre">www*.example.com</span></code> are no
longer supported.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.7 で非推奨.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.cert_time_to_seconds">
<code class="descclassname">ssl.</code><code class="descname">cert_time_to_seconds</code><span class="sig-paren">(</span><em>cert_time</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.cert_time_to_seconds" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">cert_time</span></code> として証明書内の &quot;notBefore&quot; や &quot;notAfter&quot; の <code class="docutils literal notranslate"><span class="pre">&quot;%b</span> <span class="pre">%d</span> <span class="pre">%H:%M:%S</span> <span class="pre">%Y</span> <span class="pre">%Z&quot;</span></code> strptime フォーマット (C locale) 日付を渡すと、エポックからの積算秒を返します。</p>
<p>例です。 :</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ssl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">cert_time_to_seconds</span><span class="p">(</span><span class="s2">&quot;Jan  5 09:34:43 2018 GMT&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timestamp</span>  
<span class="go">1515144883</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">utcfromtimestamp</span><span class="p">(</span><span class="n">timestamp</span><span class="p">))</span>  
<span class="go">2018-01-05 09:34:43</span>
</pre></div>
</div>
<p>&quot;notBefore&quot; や &quot;notAfter&quot; の日付には GMT を使わなければなりません(<span class="target" id="index-40"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5280.html"><strong>RFC 5280</strong></a>)。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>入力文字列に指定された 'GMT' タイムゾーンを UTC として解釈するようになりました。以前はローカルタイムで解釈していました。また、整数を返すようになりました(入力に含まれる秒の端数を含まない)。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.get_server_certificate">
<code class="descclassname">ssl.</code><code class="descname">get_server_certificate</code><span class="sig-paren">(</span><em>addr</em>, <em>ssl_version=PROTOCOL_TLS</em>, <em>ca_certs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.get_server_certificate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Given the address <code class="docutils literal notranslate"><span class="pre">addr</span></code> of an SSL-protected server, as a (<em>hostname</em>,
<em>port-number</em>) pair, fetches the server's certificate, and returns it as a
PEM-encoded string.  If <code class="docutils literal notranslate"><span class="pre">ssl_version</span></code> is specified, uses that version of
the SSL protocol to attempt to connect to the server.  If <code class="docutils literal notranslate"><span class="pre">ca_certs</span></code> is
specified, it should be a file containing a list of root certificates, the
same format as used for the same parameter in
<a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>.  The call will attempt to validate the
server certificate against that set of root certificates, and will fail
if the validation attempt fails.</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>この関数はIPv6互換になりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span><em>ssl_version</em> のデフォルトが、最近のサーバへの最大限の互換性のために <a class="reference internal" href="#ssl.PROTOCOL_SSLv3" title="ssl.PROTOCOL_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_SSLv3</span></code></a> から <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> に変更されました。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.DER_cert_to_PEM_cert">
<code class="descclassname">ssl.</code><code class="descname">DER_cert_to_PEM_cert</code><span class="sig-paren">(</span><em>DER_cert_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.DER_cert_to_PEM_cert" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>DERエンコードされたバイト列として与えられた証明書から、 PEMエンコードされたバージョンの同じ証明書を返します。</p>
</dd></dl>

<dl class="function">
<dt id="ssl.PEM_cert_to_DER_cert">
<code class="descclassname">ssl.</code><code class="descname">PEM_cert_to_DER_cert</code><span class="sig-paren">(</span><em>PEM_cert_string</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.PEM_cert_to_DER_cert" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>PEM 形式のASCII文字列として与えられた証明書から、同じ証明書をDERエンコードしたバイト列を返します。</p>
</dd></dl>

<dl class="function">
<dt id="ssl.get_default_verify_paths">
<code class="descclassname">ssl.</code><code class="descname">get_default_verify_paths</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.get_default_verify_paths" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>OpenSSL デフォルトの cafile, capath を指すパスを名前付きタプルで返します。パスは <a class="reference internal" href="#ssl.SSLContext.set_default_verify_paths" title="ssl.SSLContext.set_default_verify_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_default_verify_paths()</span></code></a> で使われるものと同じです。戻り値は <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> <code class="docutils literal notranslate"><span class="pre">DefaultVerifyPaths</span></code> です:</p>
<ul class="simple">
<li><code class="xref py py-attr docutils literal notranslate"><span class="pre">cafile</span></code> - cafile の解決済みパス、またはファイルが存在しない場合は <code class="docutils literal notranslate"><span class="pre">None</span></code></li>
<li><code class="xref py py-attr docutils literal notranslate"><span class="pre">capath</span></code> - capath の解決済みパス、またはディレクトリが存在しない場合は <code class="docutils literal notranslate"><span class="pre">None</span></code></li>
<li><code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_cafile_env</span></code> - cafile を指す OpenSSL の環境変数</li>
<li><code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_cafile</span></code> - OpenSSL にハードコードされた cafile のパス</li>
<li><code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_capath_env</span></code> - capath を指す OpenSSL の環境変数</li>
<li><code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_capath</span></code> - OpenSSL にハードコードされた capath のパス</li>
</ul>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: LibreSSL ignores the environment vars
<code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_cafile_env</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_capath_env</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.enum_certificates">
<code class="descclassname">ssl.</code><code class="descname">enum_certificates</code><span class="sig-paren">(</span><em>store_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.enum_certificates" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows のシステム証明書ストアより証明書を抽出します。 <em>store_name</em> は <code class="docutils literal notranslate"><span class="pre">CA</span></code>, <code class="docutils literal notranslate"><span class="pre">ROOT</span></code>, <code class="docutils literal notranslate"><span class="pre">MY</span></code> のうちどれか一つでしょう。Windows は追加の証明書ストアを提供しているかもしれません。</p>
<p>この関数はタプル (cert_bytes, encoding_type, trust) のリストで返します。encoding_type は cert_bytes のエンコーディングを表します。X.509 ASN.1 に対する <code class="xref py py-const docutils literal notranslate"><span class="pre">x509_asn</span></code> か PKCS#7 ASN.1 データに対する <code class="xref py py-const docutils literal notranslate"><span class="pre">pkcs_7_asn</span></code> のいずれかです。trust は、証明書の目的を、OIDS を内容に持つ set として表すか、または証明書がすべての目的で信頼できるならば <code class="docutils literal notranslate"><span class="pre">True</span></code> です。</p>
<p>以下はプログラム例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">enum_certificates</span><span class="p">(</span><span class="s2">&quot;CA&quot;</span><span class="p">)</span>
<span class="go">[(b&#39;data...&#39;, &#39;x509_asn&#39;, {&#39;1.3.6.1.5.5.7.3.1&#39;, &#39;1.3.6.1.5.5.7.3.2&#39;}),</span>
<span class="go"> (b&#39;data...&#39;, &#39;x509_asn&#39;, True)]</span>
</pre></div>
</div>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">利用可能な環境</span></a>: Windows 。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.enum_crls">
<code class="descclassname">ssl.</code><code class="descname">enum_crls</code><span class="sig-paren">(</span><em>store_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.enum_crls" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows のシステム証明書ストアより CRLs を抽出します。 <em>store_name</em> は <code class="docutils literal notranslate"><span class="pre">CA</span></code>, <code class="docutils literal notranslate"><span class="pre">ROOT</span></code>, <code class="docutils literal notranslate"><span class="pre">MY</span></code> のうちどれか一つでしょう。Windows は追加の証明書ストアを提供しているかもしれません。</p>
<p>この関数はタプル (cert_bytes, encoding_type, trust) のリストで返します。encoding_type は cert_bytes のエンコーディングを表します。X.509 ASN.1 に対する <code class="xref py py-const docutils literal notranslate"><span class="pre">x509_asn</span></code> か PKCS#7 ASN.1 データに対する <code class="xref py py-const docutils literal notranslate"><span class="pre">pkcs_7_asn</span></code> のいずれかです。</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">利用可能な環境</span></a>: Windows 。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.wrap_socket">
<code class="descclassname">ssl.</code><code class="descname">wrap_socket</code><span class="sig-paren">(</span><em>sock</em>, <em>keyfile=None</em>, <em>certfile=None</em>, <em>server_side=False</em>, <em>cert_reqs=CERT_NONE</em>, <em>ssl_version=PROTOCOL_TLS</em>, <em>ca_certs=None</em>, <em>do_handshake_on_connect=True</em>, <em>suppress_ragged_eofs=True</em>, <em>ciphers=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.wrap_socket" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> のインスタンス <code class="docutils literal notranslate"><span class="pre">sock</span></code> を受け取り、 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> のサブタイプである <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> のインスタンスを返します。 <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> は低レイヤのソケットをSSLコンテキストでラップします。 <code class="docutils literal notranslate"><span class="pre">sock</span></code> は <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a> ソケットでなければなりません; ほかのタイプのソケットはサポートされていません。</p>
<p>Internally, function creates a <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> with protocol
<em>ssl_version</em> and <a class="reference internal" href="#ssl.SSLContext.options" title="ssl.SSLContext.options"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.options</span></code></a> set to <em>cert_reqs</em>. If
parameters <em>keyfile</em>, <em>certfile</em>, <em>ca_certs</em> or <em>ciphers</em> are set, then
the values are passed to <a class="reference internal" href="#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_cert_chain()</span></code></a>,
<a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations()</span></code></a>, and
<a class="reference internal" href="#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_ciphers()</span></code></a>.</p>
<p>The arguments <em>server_side</em>, <em>do_handshake_on_connect</em>, and
<em>suppress_ragged_eofs</em> have the same meaning as
<a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.7 で非推奨: </span>Since Python 3.2 and 2.7.9, it is recommended to use the
<a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> instead of <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>. The
top-level function is limited and creates an insecure client socket
without server name indication or hostname matching.</p>
</div>
</dd></dl>

</div>
<div class="section" id="constants">
<h3>定数<a class="headerlink" href="#constants" title="このヘッドラインへのパーマリンク">¶</a></h3>
<blockquote>
<div><p>すべての定数が <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> コレクションまたは <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a> コレクションになりました。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</div></blockquote>
<dl class="data">
<dt id="ssl.CERT_NONE">
<code class="descclassname">ssl.</code><code class="descname">CERT_NONE</code><a class="headerlink" href="#ssl.CERT_NONE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Possible value for <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a>, or the <code class="docutils literal notranslate"><span class="pre">cert_reqs</span></code>
parameter to <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>.  Except for <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a>,
it is the default mode.  With client-side sockets, just about any
cert is accepted.  Validation errors, such as untrusted or expired cert,
are ignored and do not abort the TLS/SSL handshake.</p>
<p>In server mode, no certificate is requested from the client, so the client
does not send any for client cert authentication.</p>
<p>このドキュメントの下の方の、 <a class="reference internal" href="#ssl-security"><span class="std std-ref">セキュリティで考慮すべき点</span></a> に関する議論を参照してください。</p>
</dd></dl>

<dl class="data">
<dt id="ssl.CERT_OPTIONAL">
<code class="descclassname">ssl.</code><code class="descname">CERT_OPTIONAL</code><a class="headerlink" href="#ssl.CERT_OPTIONAL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Possible value for <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a>, or the <code class="docutils literal notranslate"><span class="pre">cert_reqs</span></code>
parameter to <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>.  In client mode, <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a>
has the same meaning as <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>. It is recommended to
use <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> for client-side sockets instead.</p>
<p>In server mode, a client certificate request is sent to the client.  The
client may either ignore the request or send a certificate in order
perform TLS client cert authentication.  If the client chooses to send
a certificate, it is verified.  Any verification error immediately aborts
the TLS handshake.</p>
<p>この設定では、正当なCA証明書のセットを <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations()</span></code></a> または <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> の <code class="docutils literal notranslate"><span class="pre">ca_certs</span></code> パラメータのどちらかに渡す必要があります。</p>
</dd></dl>

<dl class="data">
<dt id="ssl.CERT_REQUIRED">
<code class="descclassname">ssl.</code><code class="descname">CERT_REQUIRED</code><a class="headerlink" href="#ssl.CERT_REQUIRED" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Possible value for <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a>, or the <code class="docutils literal notranslate"><span class="pre">cert_reqs</span></code>
parameter to <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>.  In this mode, certificates are
required from the other side of the socket connection; an <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a>
will be raised if no certificate is provided, or if its validation fails.
This mode is <strong>not</strong> sufficient to verify a certificate in client mode as
it does not match hostnames.  <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> must be
enabled as well to verify the authenticity of a cert.
<a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> uses <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> and
enables <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> by default.</p>
<p>With server socket, this mode provides mandatory TLS client cert
authentication.  A client certificate request is sent to the client and
the client must provide a valid and trusted certificate.</p>
<p>この設定では、正当なCA証明書のセットを <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations()</span></code></a> または <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> の <code class="docutils literal notranslate"><span class="pre">ca_certs</span></code> パラメータのどちらかに渡す必要があります。</p>
</dd></dl>

<dl class="class">
<dt id="ssl.VerifyMode">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">VerifyMode</code><a class="headerlink" href="#ssl.VerifyMode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>CERT_* 定数の <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> コレクションです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.VERIFY_DEFAULT">
<code class="descclassname">ssl.</code><code class="descname">VERIFY_DEFAULT</code><a class="headerlink" href="#ssl.VERIFY_DEFAULT" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> に渡せる値です。このモードでは、証明書失効リスト(CRLs)はチェックされません。デフォルトでは OpenSSL は CRLs を必要ともしませんし検証にも使いません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.VERIFY_CRL_CHECK_LEAF">
<code class="descclassname">ssl.</code><code class="descname">VERIFY_CRL_CHECK_LEAF</code><a class="headerlink" href="#ssl.VERIFY_CRL_CHECK_LEAF" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Possible value for <a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a>. In this mode, only the
peer cert is checked but none of the intermediate CA certificates. The mode
requires a valid CRL that is signed by the peer cert's issuer (its direct
ancestor CA). If no proper CRL has has been loaded with
<a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations</span></code></a>, validation will fail.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.VERIFY_CRL_CHECK_CHAIN">
<code class="descclassname">ssl.</code><code class="descname">VERIFY_CRL_CHECK_CHAIN</code><a class="headerlink" href="#ssl.VERIFY_CRL_CHECK_CHAIN" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> に渡せる値です。このモードでは、接続先の証明書チェイン内のすべての証明書についての CRLs がチェックされます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.VERIFY_X509_STRICT">
<code class="descclassname">ssl.</code><code class="descname">VERIFY_X509_STRICT</code><a class="headerlink" href="#ssl.VERIFY_X509_STRICT" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> に渡せる値で、壊れた X.509 証明書に対するワークアラウンドを無効にします。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.VERIFY_X509_TRUSTED_FIRST">
<code class="descclassname">ssl.</code><code class="descname">VERIFY_X509_TRUSTED_FIRST</code><a class="headerlink" href="#ssl.VERIFY_X509_TRUSTED_FIRST" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> に渡せる値です。OpenSSL に対し、証明書検証のために信頼チェインを構築する際、信頼できる証明書を選ぶように指示します。これはデフォルトで有効にされています。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="ssl.VerifyFlags">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">VerifyFlags</code><a class="headerlink" href="#ssl.VerifyFlags" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>VERIFY_* 定数の <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a> コレクションです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLS">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLS</code><a class="headerlink" href="#ssl.PROTOCOL_TLS" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Selects the highest protocol version that both the client and server support.
Despite the name, this option can select both &quot;SSL&quot; and &quot;TLS&quot; protocols.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLS_CLIENT">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLS_CLIENT</code><a class="headerlink" href="#ssl.PROTOCOL_TLS_CLIENT" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Auto-negotiate the highest protocol version like <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>,
but only support client-side <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> connections. The protocol
enables <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> and <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> by
default.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLS_SERVER">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLS_SERVER</code><a class="headerlink" href="#ssl.PROTOCOL_TLS_SERVER" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Auto-negotiate the highest protocol version like <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>,
but only support server-side <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> connections.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv23">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_SSLv23</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv23" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Alias for <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.6 で非推奨: </span>代わりに <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> を使用してください。</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv2">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_SSLv2</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv2" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとして SSL バージョン2を選択します。</p>
<p>このプロトコルは、 OpenSSL が <code class="docutils literal notranslate"><span class="pre">OPENSSL_NO_SSL2</span></code> フラグが有効な状態でコンパイルされている場合には利用できません。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">SSL version 2 は非セキュアです。このプロトコルは強く非推奨です。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.6 で非推奨: </span>OpenSSL は SSLv2 へのサポートを打切りました。</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv3">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_SSLv3</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv3" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとしてSSLバージョン3を選択します。</p>
<p>このプロトコルは、 OpenSSL が <code class="docutils literal notranslate"><span class="pre">OPENSSL_NO_SSLv3</span></code> フラグが有効な状態でコンパイルされている場合には利用できません。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">SSL version 3 は非セキュアです。このプロトコルは強く非推奨です。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.6 で非推奨: </span>OpenSSL は全てのバージョン固有のプロトコルを廃止しました。デフォルトプロトコルの <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> に <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a> などのフラグをつけて使用してください。</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLSv1">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLSv1</code><a class="headerlink" href="#ssl.PROTOCOL_TLSv1" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとしてTLSバージョン1.0を選択します。</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.6 で非推奨: </span>OpenSSL は全てのバージョン固有のプロトコルを廃止しました。デフォルトプロトコルの <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> に <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a> などのフラグをつけて使用してください。</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLSv1_1">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLSv1_1</code><a class="headerlink" href="#ssl.PROTOCOL_TLSv1_1" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとしてTLSバージョン1.1を選択します。 openssl version 1.0.1+ のみで利用可能です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.6 で非推奨: </span>OpenSSL は全てのバージョン固有のプロトコルを廃止しました。デフォルトプロトコルの <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> に <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a> などのフラグをつけて使用してください。</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLSv1_2">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLSv1_2</code><a class="headerlink" href="#ssl.PROTOCOL_TLSv1_2" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとしてTLSバージョン1.2を選択します。これは最も現代的で、接続の両サイドが利用できる場合は、たぶん最も安全な選択肢です。 openssl version 1.0.1+ のみで利用可能です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.6 で非推奨: </span>OpenSSL は全てのバージョン固有のプロトコルを廃止しました。デフォルトプロトコルの <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> に <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a> などのフラグをつけて使用してください。</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_ALL">
<code class="descclassname">ssl.</code><code class="descname">OP_ALL</code><a class="headerlink" href="#ssl.OP_ALL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>相手にする SSL 実装のさまざまなバグを回避するためのワークアラウンドを有効にします。このオプションはデフォルトで有効です。これを有効にする場合 OpenSSL 用の同じ意味のフラグ <code class="docutils literal notranslate"><span class="pre">SSL_OP_ALL</span></code> をセットする必要はありません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_SSLv2">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_SSLv2</code><a class="headerlink" href="#ssl.OP_NO_SSLv2" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSLv2 接続が行われないようにします。このオプションは <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> と組み合わされている場合にのみ適用されます。ピアがプロトコルバージョンとして SSLv2 を選択しないようにします。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.6 で非推奨: </span>SSLv2 は非推奨です</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_SSLv3">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_SSLv3</code><a class="headerlink" href="#ssl.OP_NO_SSLv3" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSLv3 接続が行われないようにします。このオプションは <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> と組み合わされている場合にのみ適用されます。ピアがプロトコルバージョンとして SSLv3 を選択しないようにします。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.6 で非推奨: </span>SSLv3 は非推奨です</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_TLSv1">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_TLSv1</code><a class="headerlink" href="#ssl.OP_NO_TLSv1" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>TLSv1 接続が行われないようにします。このオプションは <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> と組み合わされている場合にのみ適用されます。ピアがプロトコルバージョンとして TLSv1 を選択しないようにします。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.7 で非推奨: </span>The option is deprecated since OpenSSL 1.1.0, use the new
<a class="reference internal" href="#ssl.SSLContext.minimum_version" title="ssl.SSLContext.minimum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.minimum_version</span></code></a> and
<a class="reference internal" href="#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.maximum_version</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_TLSv1_1">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_TLSv1_1</code><a class="headerlink" href="#ssl.OP_NO_TLSv1_1" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>TLSv1.1 接続が行われないようにします。このオプションは <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> と組み合わされている場合にのみ適用されます。ピアがプロトコルバージョンとして TLSv1.1 を選択しないようにします。openssl バージョン 1.0.1 以降でのみ利用できます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.7 で非推奨: </span>The option is deprecated since OpenSSL 1.1.0.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_TLSv1_2">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_TLSv1_2</code><a class="headerlink" href="#ssl.OP_NO_TLSv1_2" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>TLSv1.2 接続が行われないようにします。このオプションは <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> と組み合わされている場合にのみ適用されます。ピアがプロトコルバージョンとして TLSv1.2 を選択しないようにします。openssl バージョン 1.0.1 以降でのみ利用できます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.7 で非推奨: </span>The option is deprecated since OpenSSL 1.1.0.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_TLSv1_3">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_TLSv1_3</code><a class="headerlink" href="#ssl.OP_NO_TLSv1_3" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Prevents a TLSv1.3 connection. This option is only applicable in conjunction
with <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>. It prevents the peers from choosing TLSv1.3 as
the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later.
When Python has been compiled against an older version of OpenSSL, the
flag defaults to <em>0</em>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.7 で非推奨: </span>The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15,
3.6.3 and 3.7.0 for backwards compatibility with OpenSSL 1.0.2.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_RENEGOTIATION">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_RENEGOTIATION</code><a class="headerlink" href="#ssl.OP_NO_RENEGOTIATION" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Disable all renegotiation in TLSv1.2 and earlier. Do not send
HelloRequest messages, and ignore renegotiation requests via ClientHello.</p>
<p>This option is only available with OpenSSL 1.1.0h and later.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_CIPHER_SERVER_PREFERENCE">
<code class="descclassname">ssl.</code><code class="descname">OP_CIPHER_SERVER_PREFERENCE</code><a class="headerlink" href="#ssl.OP_CIPHER_SERVER_PREFERENCE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>暗号の優先順位として、クライアントのものではなくサーバのものを使います。このオプションはクライアントソケットと SSLv2 のサーバソケットでは効果はありません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_SINGLE_DH_USE">
<code class="descclassname">ssl.</code><code class="descname">OP_SINGLE_DH_USE</code><a class="headerlink" href="#ssl.OP_SINGLE_DH_USE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL セッションを区別するのに同じ DH 鍵を再利用しないようにします。これはセキュリティを向上させますが、より多くの計算機リソースを必要とします。このオプションはサーバソケットに適用されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_SINGLE_ECDH_USE">
<code class="descclassname">ssl.</code><code class="descname">OP_SINGLE_ECDH_USE</code><a class="headerlink" href="#ssl.OP_SINGLE_ECDH_USE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL セッションを区別するのに同じ ECDH 鍵を再利用しないようにします。これはセキュリティを向上させますが、より多くの計算機リソースを必要とします。このオプションはサーバソケットに適用されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_ENABLE_MIDDLEBOX_COMPAT">
<code class="descclassname">ssl.</code><code class="descname">OP_ENABLE_MIDDLEBOX_COMPAT</code><a class="headerlink" href="#ssl.OP_ENABLE_MIDDLEBOX_COMPAT" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make
a TLS 1.3 connection look more like a TLS 1.2 connection.</p>
<p>This option is only available with OpenSSL 1.1.1 and later.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.8 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_COMPRESSION">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_COMPRESSION</code><a class="headerlink" href="#ssl.OP_NO_COMPRESSION" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL チャネルでの圧縮を無効にします。これはアプリケーションのプロトコルが自身の圧縮方法をサポートする場合に有用です。</p>
<p>このオプションは OpenSSL 1.0.0以降のみで使用できます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="ssl.Options">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">Options</code><a class="headerlink" href="#ssl.Options" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>OP_* 定数の <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a> コレクションです。</p>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_TICKET">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_TICKET</code><a class="headerlink" href="#ssl.OP_NO_TICKET" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クライアントサイドがセッションチケットをリクエストしないようにします。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_ALPN">
<code class="descclassname">ssl.</code><code class="descname">HAS_ALPN</code><a class="headerlink" href="#ssl.HAS_ALPN" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>OpenSSL ライブラリが、組み込みで <span class="target" id="index-41"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7301.html"><strong>RFC 7301</strong></a> で記述されている <em>Application-Layer Protocol Negotiation</em> TLS 拡張をサポートしているかどうか。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_NEVER_CHECK_COMMON_NAME">
<code class="descclassname">ssl.</code><code class="descname">HAS_NEVER_CHECK_COMMON_NAME</code><a class="headerlink" href="#ssl.HAS_NEVER_CHECK_COMMON_NAME" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Whether the OpenSSL library has built-in support not checking subject
common name and <a class="reference internal" href="#ssl.SSLContext.hostname_checks_common_name" title="ssl.SSLContext.hostname_checks_common_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.hostname_checks_common_name</span></code></a> is
writeable.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_ECDH">
<code class="descclassname">ssl.</code><code class="descname">HAS_ECDH</code><a class="headerlink" href="#ssl.HAS_ECDH" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Whether the OpenSSL library has built-in support for the Elliptic Curve-based
Diffie-Hellman key exchange.  This should be true unless the feature was
explicitly disabled by the distributor.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_SNI">
<code class="descclassname">ssl.</code><code class="descname">HAS_SNI</code><a class="headerlink" href="#ssl.HAS_SNI" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Whether the OpenSSL library has built-in support for the <em>Server Name
Indication</em> extension (as defined in <span class="target" id="index-11"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6066.html"><strong>RFC 6066</strong></a>).</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_NPN">
<code class="descclassname">ssl.</code><code class="descname">HAS_NPN</code><a class="headerlink" href="#ssl.HAS_NPN" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Whether the OpenSSL library has built-in support for the <em>Next Protocol
Negotiation</em> as described in the <a class="reference external" href="https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation">Application Layer Protocol
Negotiation</a>.
When true, you can use the <a class="reference internal" href="#ssl.SSLContext.set_npn_protocols" title="ssl.SSLContext.set_npn_protocols"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_npn_protocols()</span></code></a> method to advertise
which protocols you want to support.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_SSLv2">
<code class="descclassname">ssl.</code><code class="descname">HAS_SSLv2</code><a class="headerlink" href="#ssl.HAS_SSLv2" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Whether the OpenSSL library has built-in support for the SSL 2.0 protocol.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_SSLv3">
<code class="descclassname">ssl.</code><code class="descname">HAS_SSLv3</code><a class="headerlink" href="#ssl.HAS_SSLv3" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Whether the OpenSSL library has built-in support for the SSL 3.0 protocol.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_TLSv1">
<code class="descclassname">ssl.</code><code class="descname">HAS_TLSv1</code><a class="headerlink" href="#ssl.HAS_TLSv1" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Whether the OpenSSL library has built-in support for the TLS 1.0 protocol.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_TLSv1_1">
<code class="descclassname">ssl.</code><code class="descname">HAS_TLSv1_1</code><a class="headerlink" href="#ssl.HAS_TLSv1_1" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Whether the OpenSSL library has built-in support for the TLS 1.1 protocol.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_TLSv1_2">
<code class="descclassname">ssl.</code><code class="descname">HAS_TLSv1_2</code><a class="headerlink" href="#ssl.HAS_TLSv1_2" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Whether the OpenSSL library has built-in support for the TLS 1.2 protocol.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_TLSv1_3">
<code class="descclassname">ssl.</code><code class="descname">HAS_TLSv1_3</code><a class="headerlink" href="#ssl.HAS_TLSv1_3" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Whether the OpenSSL library has built-in support for the TLS 1.3 protocol.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.CHANNEL_BINDING_TYPES">
<code class="descclassname">ssl.</code><code class="descname">CHANNEL_BINDING_TYPES</code><a class="headerlink" href="#ssl.CHANNEL_BINDING_TYPES" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サポートされている TLS のチャネルバインディングのタイプのリスト。リスト内の文字列は <a class="reference internal" href="#ssl.SSLSocket.get_channel_binding" title="ssl.SSLSocket.get_channel_binding"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.get_channel_binding()</span></code></a> の引数に渡せます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION">
<code class="descclassname">ssl.</code><code class="descname">OPENSSL_VERSION</code><a class="headerlink" href="#ssl.OPENSSL_VERSION" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>インタプリタによってロードされた OpenSSL ライブラリのバージョン文字列:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION</span>
<span class="go">&#39;OpenSSL 1.0.2k  26 Jan 2017&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION_INFO">
<code class="descclassname">ssl.</code><code class="descname">OPENSSL_VERSION_INFO</code><a class="headerlink" href="#ssl.OPENSSL_VERSION_INFO" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>OpenSSL ライブラリのバージョン情報を表す5つの整数のタプル:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_INFO</span>
<span class="go">(1, 0, 2, 11, 15)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION_NUMBER">
<code class="descclassname">ssl.</code><code class="descname">OPENSSL_VERSION_NUMBER</code><a class="headerlink" href="#ssl.OPENSSL_VERSION_NUMBER" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>1つの整数の形式の、 OpenSSL ライブラリの生のバージョン番号:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_NUMBER</span>
<span class="go">268443839</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_NUMBER</span><span class="p">)</span>
<span class="go">&#39;0x100020bf&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE">
<code class="descclassname">ssl.</code><code class="descname">ALERT_DESCRIPTION_HANDSHAKE_FAILURE</code><a class="headerlink" href="#ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE" title="この定義へのパーマリンク">¶</a></dt>
<dt id="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR">
<code class="descclassname">ssl.</code><code class="descname">ALERT_DESCRIPTION_INTERNAL_ERROR</code><a class="headerlink" href="#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">ALERT_DESCRIPTION_*</code></dt>
<dd><p><span class="target" id="index-42"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5246.html"><strong>RFC 5246</strong></a> その他からのアラートの種類です。 <a class="reference external" href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-6">IANA TLS Alert Registry</a> にはこのリストとその意味が定義された RFC へのリファレンスが含まれています。</p>
<p><a class="reference internal" href="#ssl.SSLContext.set_servername_callback" title="ssl.SSLContext.set_servername_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_servername_callback()</span></code></a> でのコールバック関数の戻り値として使われます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="ssl.AlertDescription">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">AlertDescription</code><a class="headerlink" href="#ssl.AlertDescription" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ALERT_DESCRIPTION_* 定数の <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a>&nbsp;コレクションです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.Purpose.SERVER_AUTH">
<code class="descclassname">Purpose.</code><code class="descname">SERVER_AUTH</code><a class="headerlink" href="#ssl.Purpose.SERVER_AUTH" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> と <a class="reference internal" href="#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_default_certs()</span></code></a> に渡すオプションです。この値はコンテキストが Web サーバの認証に使われることを示します (ですので、クライアントサイドのソケットを作るのに使うことになるでしょう)。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.Purpose.CLIENT_AUTH">
<code class="descclassname">Purpose.</code><code class="descname">CLIENT_AUTH</code><a class="headerlink" href="#ssl.Purpose.CLIENT_AUTH" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> と <a class="reference internal" href="#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_default_certs()</span></code></a> に渡すオプションです。この値はコンテキストが Web クライアントの認証に使われることを示します (ですので、サーバサイドのソケットを作るのに使うことになるでしょう)。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="ssl.SSLErrorNumber">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">SSLErrorNumber</code><a class="headerlink" href="#ssl.SSLErrorNumber" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL_ERROR_* 定数の <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a>&nbsp;コレクションです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="ssl.TLSVersion">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">TLSVersion</code><a class="headerlink" href="#ssl.TLSVersion" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> collection of SSL and TLS versions for
<a class="reference internal" href="#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.maximum_version</span></code></a> and <a class="reference internal" href="#ssl.SSLContext.minimum_version" title="ssl.SSLContext.minimum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.minimum_version</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.TLSVersion.MINIMUM_SUPPORTED">
<code class="descclassname">TLSVersion.</code><code class="descname">MINIMUM_SUPPORTED</code><a class="headerlink" href="#ssl.TLSVersion.MINIMUM_SUPPORTED" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.TLSVersion.MAXIMUM_SUPPORTED">
<code class="descclassname">TLSVersion.</code><code class="descname">MAXIMUM_SUPPORTED</code><a class="headerlink" href="#ssl.TLSVersion.MAXIMUM_SUPPORTED" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The minimum or maximum supported SSL or TLS version. These are magic
constants. Their values don't reflect the lowest and highest available
TLS/SSL versions.</p>
</dd></dl>

<dl class="attribute">
<dt id="ssl.TLSVersion.SSLv3">
<code class="descclassname">TLSVersion.</code><code class="descname">SSLv3</code><a class="headerlink" href="#ssl.TLSVersion.SSLv3" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.TLSVersion.TLSv1">
<code class="descclassname">TLSVersion.</code><code class="descname">TLSv1</code><a class="headerlink" href="#ssl.TLSVersion.TLSv1" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.TLSVersion.TLSv1_1">
<code class="descclassname">TLSVersion.</code><code class="descname">TLSv1_1</code><a class="headerlink" href="#ssl.TLSVersion.TLSv1_1" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.TLSVersion.TLSv1_2">
<code class="descclassname">TLSVersion.</code><code class="descname">TLSv1_2</code><a class="headerlink" href="#ssl.TLSVersion.TLSv1_2" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.TLSVersion.TLSv1_3">
<code class="descclassname">TLSVersion.</code><code class="descname">TLSv1_3</code><a class="headerlink" href="#ssl.TLSVersion.TLSv1_3" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL 3.0 to TLS 1.3.</p>
</dd></dl>

</div>
</div>
<div class="section" id="ssl-sockets">
<h2>SSL ソケット<a class="headerlink" href="#ssl-sockets" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="class">
<dt id="ssl.SSLSocket">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">SSLSocket</code><span class="sig-paren">(</span><em>socket.socket</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL ソケットは <a class="reference internal" href="socket.html#socket-objects"><span class="std std-ref">socket オブジェクト</span></a> の以下のメソッドを提供します:</p>
<ul class="simple">
<li><a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.bind" title="socket.socket.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.close" title="socket.socket.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.detach" title="socket.socket.detach"><code class="xref py py-meth docutils literal notranslate"><span class="pre">detach()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.fileno" title="socket.socket.fileno"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fileno()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.getpeername" title="socket.socket.getpeername"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeername()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.getsockname" title="socket.socket.getsockname"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getsockname()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.getsockopt" title="socket.socket.getsockopt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getsockopt()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.setsockopt" title="socket.socket.setsockopt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setsockopt()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.gettimeout" title="socket.socket.gettimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gettimeout()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a>,
<a class="reference internal" href="socket.html#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setblocking()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv_into()</span></code></a> (非ゼロの <code class="docutils literal notranslate"><span class="pre">flags</span></code> は渡せません)</li>
<li><a class="reference internal" href="socket.html#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendall()</span></code></a> (非ゼロの <code class="docutils literal notranslate"><span class="pre">flags</span></code> は渡せません)</li>
<li><a class="reference internal" href="socket.html#socket.socket.sendfile" title="socket.socket.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendfile()</span></code></a> (ただし、 <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.sendfile</span></code></a> は平文ソケットにのみ使用されます。それ以外の場合には、 <a class="reference internal" href="socket.html#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> が使用されます。)</li>
<li><a class="reference internal" href="socket.html#socket.socket.shutdown" title="socket.socket.shutdown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shutdown()</span></code></a></li>
</ul>
<p>SSL(およびTLS)プロトコルは TCP の上に独自の枠組みを持っているので、SSLソケットの抽象化は、いくつかの点で通常の OSレベルのソケットの仕様から逸脱することがあります。特に <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">ノンブロッキングソケットについての注釈</span></a> を参照してください。</p>
<p>Instances of <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> must be created using the
<a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> method.</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendfile()</span></code> メソッドが追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span><code class="xref py py-meth docutils literal notranslate"><span class="pre">shutdown()</span></code> は、バイトが送受信されるたびにソケットのタイムアウトをリセットしません。ソケットのタイムアウトは、シャットダウンの最大合計時間になりました。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.6 で非推奨: </span><a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> インスタンスを直接作成することは非推奨です。ソケットをラップするために <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> を使用してください。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.7 で変更: </span><a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> instances must to created with
<a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>. In earlier versions, it was possible
to create instances directly. This was never documented or officially
supported.</p>
</div>
</dd></dl>

<p>SSL ソケットには、以下に示す追加のメソッドと属性もあります:</p>
<dl class="method">
<dt id="ssl.SSLSocket.read">
<code class="descclassname">SSLSocket.</code><code class="descname">read</code><span class="sig-paren">(</span><em>len=1024</em>, <em>buffer=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.read" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL ソケットからデータの <em>len</em> バイトまでを読み出し、読み出した結果を <code class="docutils literal notranslate"><span class="pre">bytes</span></code> インスタンスで返します。 <em>buffer</em> を指定すると、結果は代わりに buffer に読み込まれ、読み込んだバイト数を返します。</p>
<p>ソケットが <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">non-blocking</span></a> で読み出しがブロックすると、 <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> もしくは <a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> が送出されます。</p>
<p>再ネゴシエーションがいつでも可能なので、 <a class="reference internal" href="#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>  の呼び出しは書き込み操作も引き起こしえます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>ソケットのタイムアウトは、バイトが送受信されるたびにリセットされません。ソケットのタイムアウトは、最大 <em>len</em> バイトを読むのにかかる最大合計時間になりました。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.6 で非推奨: </span><a class="reference internal" href="#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> の代わりに <code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code> を使用してください。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.write">
<code class="descclassname">SSLSocket.</code><code class="descname">write</code><span class="sig-paren">(</span><em>buf</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.write" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>buf</em> を SSL ソケットに書き込み、書き込んだバイト数を返します。 <em>buf</em> 引数はバッファインターフェイスをサポートするオブジェクトでなければなりません。</p>
<p>ソケットが <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">non-blocking</span></a> で書き込みがブロックすると、 <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> もしくは <a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> が送出されます。</p>
<p>再ネゴシエーションがいつでも可能なので、 <a class="reference internal" href="#ssl.SSLSocket.write" title="ssl.SSLSocket.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a>  の呼び出しは読み出し操作も引き起こしえます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>ソケットのタイムアウトは、バイトが送受信されるたびにリセットされません。ソケットのタイムアウトは、<em>buf</em> を書き込むのにかかる最大合計時間になりました。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.6 で非推奨: </span><a class="reference internal" href="#ssl.SSLSocket.write" title="ssl.SSLSocket.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> の代わりに <code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code> を使用してください。</p>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p><a class="reference internal" href="#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>, <a class="reference internal" href="#ssl.SSLSocket.write" title="ssl.SSLSocket.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> メソッドは下位レベルのメソッドであり、暗号化されていないアプリケーションレベルのデータを読み書きし、それを復号/暗号化して暗号化された書き込みレベルのデータにします。これらのメソッドはアクティブな SSL 接続つまり、ハンドシェイクが完了していて、 <a class="reference internal" href="#ssl.SSLSocket.unwrap" title="ssl.SSLSocket.unwrap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.unwrap()</span></code></a> が呼ばれていないことを必要とします。</p>
<p class="last">通常はこれらのメソッドの代わりに <a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a> や <a class="reference internal" href="socket.html#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> のようなソケット API メソッドを使うべきです。</p>
</div>
<dl class="method">
<dt id="ssl.SSLSocket.do_handshake">
<code class="descclassname">SSLSocket.</code><code class="descname">do_handshake</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.do_handshake" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL セットアップのハンドシェイクを実行します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>ソケットの <a class="reference internal" href="#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal notranslate"><span class="pre">context</span></code></a> の属性 <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> が真の場合に、ハンドシェイクメソッドが <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code></a> を実行するようになりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>ソケットのタイムアウトは、バイトが送受信されるたびにリセットされません。ソケットのタイムアウトは、ハンドシェイクにかかる最大合計時間になりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.7 で変更: </span>Hostname or IP address is matched by OpenSSL during handshake. The
function <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code></a> is no longer used. In case OpenSSL
refuses a hostname or IP address, the handshake is aborted early and
a TLS alert message is send to the peer.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.getpeercert">
<code class="descclassname">SSLSocket.</code><code class="descname">getpeercert</code><span class="sig-paren">(</span><em>binary_form=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.getpeercert" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>接続先に証明書が無い場合、 <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。SSL ハンドシェイクがまだ行われていない場合は、 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> が送出されます。</p>
<p><code class="docutils literal notranslate"><span class="pre">binary_form</span></code> が <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> で接続先から証明書を取得した場合、このメソッドは <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> のインスタンスを返します。証明書が認証されていない場合、辞書は空です。証明書が認証されていた場合いくつかのキーを持った辞書を返し、 <code class="docutils literal notranslate"><span class="pre">subject</span></code> (証明書が発行された principal), <code class="docutils literal notranslate"><span class="pre">issuer</span></code> (証明書を発行した principal) を含みます。証明書が <em>Subject Alternative Name</em> 拡張(<span class="target" id="index-43"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3280.html"><strong>RFC 3280</strong></a> を参照)のインスタンスを格納していた場合、 <code class="docutils literal notranslate"><span class="pre">subjectAltName</span></code> キーも辞書に含まれます。</p>
<p><code class="docutils literal notranslate"><span class="pre">subject</span></code>, <code class="docutils literal notranslate"><span class="pre">issuer</span></code> フィールドは、証明書のそれぞれのフィールドについてのデータ構造で与えられる RDN (relative distinguishued name) のシーケンスを格納したタプルで、各 RDN は name-value ペアのシーケンスです。現実世界での例をお見せします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;issuer&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s1">&#39;countryName&#39;</span><span class="p">,</span> <span class="s1">&#39;IL&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s1">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s1">&#39;StartCom Ltd.&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s1">&#39;organizationalUnitName&#39;</span><span class="p">,</span>
              <span class="s1">&#39;Secure Digital Certificate Signing&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s1">&#39;commonName&#39;</span><span class="p">,</span>
              <span class="s1">&#39;StartCom Class 2 Primary Intermediate Server CA&#39;</span><span class="p">),)),</span>
 <span class="s1">&#39;notAfter&#39;</span><span class="p">:</span> <span class="s1">&#39;Nov 22 08:15:19 2013 GMT&#39;</span><span class="p">,</span>
 <span class="s1">&#39;notBefore&#39;</span><span class="p">:</span> <span class="s1">&#39;Nov 21 03:09:52 2011 GMT&#39;</span><span class="p">,</span>
 <span class="s1">&#39;serialNumber&#39;</span><span class="p">:</span> <span class="s1">&#39;95F0&#39;</span><span class="p">,</span>
 <span class="s1">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s1">&#39;description&#39;</span><span class="p">,</span> <span class="s1">&#39;571208-SLe257oHY9fVQ07Z&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;countryName&#39;</span><span class="p">,</span> <span class="s1">&#39;US&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;stateOrProvinceName&#39;</span><span class="p">,</span> <span class="s1">&#39;California&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;localityName&#39;</span><span class="p">,</span> <span class="s1">&#39;San Francisco&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s1">&#39;Electronic Frontier Foundation, Inc.&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;commonName&#39;</span><span class="p">,</span> <span class="s1">&#39;*.eff.org&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;emailAddress&#39;</span><span class="p">,</span> <span class="s1">&#39;hostmaster@eff.org&#39;</span><span class="p">),)),</span>
 <span class="s1">&#39;subjectAltName&#39;</span><span class="p">:</span> <span class="p">((</span><span class="s1">&#39;DNS&#39;</span><span class="p">,</span> <span class="s1">&#39;*.eff.org&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;DNS&#39;</span><span class="p">,</span> <span class="s1">&#39;eff.org&#39;</span><span class="p">)),</span>
 <span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">特定のサービスのために証明書の検証がしたければ、 <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code></a> 関数を使うことができます。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">binary_form</span></code> 引数が <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> だった場合、証明書が渡されていればこのメソッドはDERエンコードされた証明書全体をバイト列として返し、接続先が証明書を提示しなかった場合は <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> を返します。接続先が証明書を提供するかどうかは SSL ソケットの役割に依存します:</p>
<ul class="simple">
<li>クライアント SSL ソケットでは、認証が要求されているかどうかに関わらず、サーバは常に証明書を提供します。</li>
<li>サーバ SSL ソケットでは、クライアントはサーバによって認証が要求されている場合にのみ証明書を提供します。したがって、 (<a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a> や <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> ではなく) <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a> を使用した場合 <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeercert()</span></code></a> は <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> を返します。</li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>返される辞書に <code class="docutils literal notranslate"><span class="pre">issuer</span></code>, <code class="docutils literal notranslate"><span class="pre">notBefore</span></code> のような追加アイテムを含むようになりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>ハンドシェイクが済んでいなければ <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> を投げるようになりました。返される辞書に <code class="docutils literal notranslate"><span class="pre">crlDistributionPoints</span></code>, <code class="docutils literal notranslate"><span class="pre">caIssuers</span></code>, <code class="docutils literal notranslate"><span class="pre">OCSP</span></code> URI のような X509v3 拡張アイテムを含むようになりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.8.1 で変更: </span>IPv6 address strings no longer have a trailing new line.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.cipher">
<code class="descclassname">SSLSocket.</code><code class="descname">cipher</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.cipher" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>利用されている暗号の名前、その暗号の利用を定義しているSSLプロトコルのバージョン、利用されている鍵のbit長の3つの値を含むタプルを返します。もし接続が確立されていない場合、 <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.shared_ciphers">
<code class="descclassname">SSLSocket.</code><code class="descname">shared_ciphers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.shared_ciphers" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ハンドシェイク中にクライアントにより共有される暗号方式のリストを返します。返されるリストの各要素は 3つの値を含むタプルで、その値はそれぞれ、暗号方式の名前、その暗号の利用を定義している SSL プロトコルのバージョン、暗号で使用される秘密鍵のビット長です。接続が確立されていないか、ソケットがクライアントソケットである場合、meth:<cite>~SSLSocket.shared_ciphers</cite> は <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.compression">
<code class="descclassname">SSLSocket.</code><code class="descname">compression</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.compression" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>使われている圧縮アルゴリズムを文字列で返します。接続が圧縮されていなければ <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。</p>
<p>上位レベルのプロトコルが自身で圧縮メカニズムをサポートする場合、SSL レベルでの圧縮を <a class="reference internal" href="#ssl.OP_NO_COMPRESSION" title="ssl.OP_NO_COMPRESSION"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_COMPRESSION</span></code></a> を使って無効にできます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.get_channel_binding">
<code class="descclassname">SSLSocket.</code><code class="descname">get_channel_binding</code><span class="sig-paren">(</span><em>cb_type=&quot;tls-unique&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.get_channel_binding" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在の接続におけるチャネルバインディングのデータを取得します。未接続あるいはハンドシェイクが完了していなければ <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。</p>
<p><em>cb_type</em> パラメータにより、望みのチャネルバインディングのタイプを選択できます。チャネルバインディングのタイプの妥当なものは <a class="reference internal" href="#ssl.CHANNEL_BINDING_TYPES" title="ssl.CHANNEL_BINDING_TYPES"><code class="xref py py-data docutils literal notranslate"><span class="pre">CHANNEL_BINDING_TYPES</span></code></a> でリストされています。現在のところは <span class="target" id="index-44"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5929.html"><strong>RFC 5929</strong></a> で定義されている 'tls-unique' のみがサポートされています。未サポートのチャネルバインディングのタイプが要求された場合、 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> を送出します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.selected_alpn_protocol">
<code class="descclassname">SSLSocket.</code><code class="descname">selected_alpn_protocol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.selected_alpn_protocol" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>TLS ハンドシェイクで選択されたプロトコルを返します。 <a class="reference internal" href="#ssl.SSLContext.set_alpn_protocols" title="ssl.SSLContext.set_alpn_protocols"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_alpn_protocols()</span></code></a> が呼ばれていない場合、相手側が ALPN をサポートしていない場合、クライアントが提案したプロトコルのどれもソケットがサポートしない場合、あるいはハンドシェイクがまだ行われていない場合には、 <code class="docutils literal notranslate"><span class="pre">None</span></code> が返されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.selected_npn_protocol">
<code class="descclassname">SSLSocket.</code><code class="descname">selected_npn_protocol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.selected_npn_protocol" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>TLS/SSL ハンドシェイクで選択された上位レベルのプロトコルを返します。 <a class="reference internal" href="#ssl.SSLContext.set_npn_protocols" title="ssl.SSLContext.set_npn_protocols"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_npn_protocols()</span></code></a> が呼ばれていない場合、相手側が NPN をサポートしていない場合、あるいはハンドシェイクがまだ行われていない場合には、 <code class="docutils literal notranslate"><span class="pre">None</span></code> が返されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.unwrap">
<code class="descclassname">SSLSocket.</code><code class="descname">unwrap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.unwrap" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSLシャットダウンハンドシェイクを実行します。これは下位レイヤーのソケットからTLSレイヤーを取り除き、下位レイヤーのソケットオブジェクトを返します。これは暗号化されたオペレーションから暗号化されていない接続に移行するときに利用されます。以降の通信には、オリジナルのソケットではなくこのメソッドが返したソケットのみを利用するべきです。</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.verify_client_post_handshake">
<code class="descclassname">SSLSocket.</code><code class="descname">verify_client_post_handshake</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.verify_client_post_handshake" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA
can only be initiated for a TLS 1.3 connection from a server-side socket,
after the initial TLS handshake and with PHA enabled on both sides, see
<a class="reference internal" href="#ssl.SSLContext.post_handshake_auth" title="ssl.SSLContext.post_handshake_auth"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.post_handshake_auth</span></code></a>.</p>
<p>The method does not perform a cert exchange immediately. The server-side
sends a CertificateRequest during the next write event and expects the
client to respond with a certificate on the next read event.</p>
<p>If any precondition isn't met (e.g. not TLS 1.3, PHA not enabled), an
<a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> is raised.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3
support, the method raises <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.8 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.version">
<code class="descclassname">SSLSocket.</code><code class="descname">version</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.version" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コネクションによって実際にネゴシエイトされた SSL プロトコルバージョンを文字列で、または、セキュアなコネクションが確立していなければ <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。これを書いている時点では、 <code class="docutils literal notranslate"><span class="pre">&quot;SSLv2&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;SSLv3&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;TLSv1&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;TLSv1.1&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;TLSv1.2&quot;</span></code> などが返ります。最新の OpenSSL はもっと色々な値を定義しているかもしれません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.pending">
<code class="descclassname">SSLSocket.</code><code class="descname">pending</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.pending" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>接続において既に復号済みで読み出し可能で保留になっているバイト列の数を返します。</p>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSocket.context">
<code class="descclassname">SSLSocket.</code><code class="descname">context</code><a class="headerlink" href="#ssl.SSLSocket.context" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> object this SSL socket is tied to.  If the SSL
socket was created using the deprecated <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> function
(rather than <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>), this is a custom context
object created for this SSL socket.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSocket.server_side">
<code class="descclassname">SSLSocket.</code><code class="descname">server_side</code><a class="headerlink" href="#ssl.SSLSocket.server_side" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバサイドのソケットに対して <code class="docutils literal notranslate"><span class="pre">True</span></code> 、クライアントサイドのソケットに対して <code class="docutils literal notranslate"><span class="pre">False</span></code> となる真偽値です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSocket.server_hostname">
<code class="descclassname">SSLSocket.</code><code class="descname">server_hostname</code><a class="headerlink" href="#ssl.SSLSocket.server_hostname" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サーバのホスト名: <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 型、またはサーバサイドのソケットの場合とコンストラクタで hostname が指定されなかった場合は <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.7 で変更: </span>The attribute is now always ASCII text. When <code class="docutils literal notranslate"><span class="pre">server_hostname</span></code> is
an internationalized domain name (IDN), this attribute now stores the
A-label form (<code class="docutils literal notranslate"><span class="pre">&quot;xn--pythn-mua.org&quot;</span></code>), rather than the U-label form
(<code class="docutils literal notranslate"><span class="pre">&quot;pythön.org&quot;</span></code>).</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSocket.session">
<code class="descclassname">SSLSocket.</code><code class="descname">session</code><a class="headerlink" href="#ssl.SSLSocket.session" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この SSL 接続に対する <a class="reference internal" href="#ssl.SSLSession" title="ssl.SSLSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSession</span></code></a> です。このセッションは、TLS ハンドシェイクの実行後、クライアントサイドとサーバサイドのソケットで使用できます。クライアントソケットでは、このセッションを <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_handshake()</span></code></a> が呼ばれる前に設定して、セッションを再利用できます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSocket.session_reused">
<code class="descclassname">SSLSocket.</code><code class="descname">session_reused</code><a class="headerlink" href="#ssl.SSLSocket.session_reused" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="ssl-contexts">
<h2>SSL コンテキスト<a class="headerlink" href="#ssl-contexts" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
<p>SSL コンテキストは、SSL 構成オプション、証明書(群)や秘密鍵(群)などのような、一回の SSL 接続よりも長生きするさまざまなデータを保持します。これはサーバサイドソケットの SSL セッションのキャッシュも管理し、同じクライアントからの繰り返しの接続時の速度向上に一役買います。</p>
<dl class="class">
<dt id="ssl.SSLContext">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">SSLContext</code><span class="sig-paren">(</span><em>protocol=PROTOCOL_TLS</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Create a new SSL context.  You may pass <em>protocol</em> which must be one
of the <code class="docutils literal notranslate"><span class="pre">PROTOCOL_*</span></code> constants defined in this module.  The parameter
specifies which version of the SSL protocol to use.  Typically, the
server chooses a particular protocol version, and the client must adapt
to the server's choice.  Most of the versions are not interoperable
with the other versions.  If not specified, the default is
<a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>; it provides the most compatibility with other
versions.</p>
<p>次のテーブルは、どのクライアントのバージョンがどのサーバのバージョンに接続できるかを示しています:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="13%" />
<col width="13%" />
<col width="14%" />
<col width="10%" />
<col width="12%" />
<col width="12%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><em>client</em> / <strong>server</strong></td>
<td><strong>SSLv2</strong></td>
<td><strong>SSLv3</strong></td>
<td><strong>TLS</strong> <a class="footnote-reference" href="#id9" id="id1">[3]</a></td>
<td><strong>TLSv1</strong></td>
<td><strong>TLSv1.1</strong></td>
<td><strong>TLSv1.2</strong></td>
</tr>
<tr class="row-even"><td><em>SSLv2</em></td>
<td>yes</td>
<td>no</td>
<td>no <a class="footnote-reference" href="#id7" id="id2">[1]</a></td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
<tr class="row-odd"><td><em>SSLv3</em></td>
<td>no</td>
<td>yes</td>
<td>no <a class="footnote-reference" href="#id8" id="id3">[2]</a></td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
<tr class="row-even"><td><em>TLS</em> (<em>SSLv23</em>) <a class="footnote-reference" href="#id9" id="id4">[3]</a></td>
<td>no <a class="footnote-reference" href="#id7" id="id5">[1]</a></td>
<td>no <a class="footnote-reference" href="#id8" id="id6">[2]</a></td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr class="row-odd"><td><em>TLSv1</em></td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr class="row-even"><td><em>TLSv1.1</em></td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr class="row-odd"><td><em>TLSv1.2</em></td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> では、デフォルトで <a class="reference internal" href="#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv2</span></code></a> によりSSLv2 が無効になっています。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> では、デフォルトで <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a> により SSLv3 が無効になっています。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> TLS 1.3 protocol will be available with <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> in
OpenSSL &gt;= 1.1.1. There is no dedicated PROTOCOL constant for just
TLS 1.3.</td></tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> は <a class="reference internal" href="#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> モジュールに、目的に合ったセキュリティ設定を選ばせます。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>このコンテキストは、安全性の高いデフォルト値で作成されます。デフォルト設定されるオプションは、 <a class="reference internal" href="#ssl.OP_NO_COMPRESSION" title="ssl.OP_NO_COMPRESSION"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_COMPRESSION</span></code></a>, <a class="reference internal" href="#ssl.OP_CIPHER_SERVER_PREFERENCE" title="ssl.OP_CIPHER_SERVER_PREFERENCE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_CIPHER_SERVER_PREFERENCE</span></code></a>, <a class="reference internal" href="#ssl.OP_SINGLE_DH_USE" title="ssl.OP_SINGLE_DH_USE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_SINGLE_DH_USE</span></code></a>, <a class="reference internal" href="#ssl.OP_SINGLE_ECDH_USE" title="ssl.OP_SINGLE_ECDH_USE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_SINGLE_ECDH_USE</span></code></a>, <a class="reference internal" href="#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv2</span></code></a> (<a class="reference internal" href="#ssl.PROTOCOL_SSLv2" title="ssl.PROTOCOL_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_SSLv2</span></code></a> 以外), <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a> (<a class="reference internal" href="#ssl.PROTOCOL_SSLv3" title="ssl.PROTOCOL_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_SSLv3</span></code></a> 以外) です。初期の暗号方式スイートリストには <code class="docutils literal notranslate"><span class="pre">HIGH</span></code> 暗号のみが含まれており、 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 暗号および <code class="docutils literal notranslate"><span class="pre">MD5</span></code> 暗号は含まれません (<a class="reference internal" href="#ssl.PROTOCOL_SSLv2" title="ssl.PROTOCOL_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_SSLv2</span></code></a> 以外)。</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> オブジェクトは以下のメソッドと属性を持っています:</p>
<dl class="method">
<dt id="ssl.SSLContext.cert_store_stats">
<code class="descclassname">SSLContext.</code><code class="descname">cert_store_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.cert_store_stats" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ロードされた X.509 証明書の数、CA 証明書で活性の X.509 証明書の数、証明書失効リストの数、についての統計情報を辞書として取得します。</p>
<p>一つの CA と他の一つの証明書を持ったコンテキストでの例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">cert_store_stats</span><span class="p">()</span>
<span class="go">{&#39;crl&#39;: 0, &#39;x509_ca&#39;: 1, &#39;x509&#39;: 2}</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.load_cert_chain">
<code class="descclassname">SSLContext.</code><code class="descname">load_cert_chain</code><span class="sig-paren">(</span><em>certfile</em>, <em>keyfile=None</em>, <em>password=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_cert_chain" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>秘密鍵と対応する証明書をロードします。 <em>certfile</em> は、証明書と、証明書認証で必要とされる任意の数の CA 証明書を含む、PEM フォーマットの単一ファイルへのパスでなければなりません。 <em>keyfile</em> 文字列を指定する場合、秘密鍵が含まれるファイルを指すものでなければなりません。指定しない場合、秘密鍵も <em>certfile</em> から取得されます。 <em>certfile</em> への証明書の格納についての詳細は、 <a class="reference internal" href="#ssl-certificates"><span class="std std-ref">証明書</span></a> の議論を参照してください。</p>
<p><em>password</em> 引数に、秘密鍵を復号するためのパスワードを返す関数を与えることができます。その関数は秘密鍵が暗号化されていて、なおかつパスワードが必要な場合にのみ呼び出されます。その関数は引数なしで呼び出され、string, bytes, または bytearray を返さなければなりません。戻り値が string の場合は鍵を復号化するのに使う前に UTF-8 でエンコードされます。string の代わりに bytes や bytearray を返した場合は <em>password</em> 引数に直接供給されます。秘密鍵が暗号化されていなかったりパスワードを必要としない場合は、指定は無視されます。</p>
<p><em>password</em> が与えられず、そしてパスワードが必要な場合には、OpenSSL 組み込みのパスワード問い合わせメカニズムが、ユーザに対話的にパスワードを問い合わせます。</p>
<p>秘密鍵が証明書に合致しなければ、 <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a> が送出されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>新しいオプション引数 <em>password</em>。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.load_default_certs">
<code class="descclassname">SSLContext.</code><code class="descname">load_default_certs</code><span class="sig-paren">(</span><em>purpose=Purpose.SERVER_AUTH</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_default_certs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デフォルトの場所から &quot;認証局&quot; (CA=certification authority) 証明書ファイル一式をロードします。Windows では、CA 証明書はシステム記憶域の <code class="docutils literal notranslate"><span class="pre">CA</span></code> と <code class="docutils literal notranslate"><span class="pre">ROOT</span></code> からロードします。それ以外のシステムでは、この関数は <a class="reference internal" href="#ssl.SSLContext.set_default_verify_paths" title="ssl.SSLContext.set_default_verify_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_default_verify_paths()</span></code></a> を呼び出します。将来的にはこのメソッドは、他の場所からも CA 証明書をロードするかもしれません。</p>
<p><em>purpose</em> フラグでどの種類の CA 証明書をロードするかを指定します。デフォルトの <a class="reference internal" href="#ssl.Purpose.SERVER_AUTH" title="ssl.Purpose.SERVER_AUTH"><code class="xref py py-data docutils literal notranslate"><span class="pre">Purpose.SERVER_AUTH</span></code></a> は TLS web サーバの認証のために活性かつ信頼された証明書をロードします(クライアントサイドのソケット)。 <a class="reference internal" href="#ssl.Purpose.CLIENT_AUTH" title="ssl.Purpose.CLIENT_AUTH"><code class="xref py py-data docutils literal notranslate"><span class="pre">Purpose.CLIENT_AUTH</span></code></a> はクライアント証明書の正当性検証をサーバサイドで行うための CA 証明書をロードします。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.load_verify_locations">
<code class="descclassname">SSLContext.</code><code class="descname">load_verify_locations</code><span class="sig-paren">(</span><em>cafile=None</em>, <em>capath=None</em>, <em>cadata=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_verify_locations" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-data docutils literal notranslate"><span class="pre">verify_mode</span></code></a> が <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a> でない場合に接続先の証明書ファイルの正当性検証に使われる &quot;認証局&quot; (CA=certification authority) 証明書ファイル一式をロードします。少なくとも <em>cafile</em> か <em>capath</em> のどちらかは指定しなければなりません。</p>
<p>このメソッドは PEM または DER フォーマットの証明書失効リスト (CRLs=certification revocation lists)もロードできます。CRLs のために使うには、 <a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> を適切に設定しなければなりません。</p>
<p><em>cafile</em> を指定する場合は、PEM フォーマットで CA 証明書が結合されたファイルへのパスを指定してください。このファイル内で証明書をどのように編成すれば良いのかについての詳しい情報については、 <a class="reference internal" href="#ssl-certificates"><span class="std std-ref">証明書</span></a> の議論を参照してください。</p>
<p>The <em>capath</em> string, if present, is
the path to a directory containing several CA certificates in PEM format,
following an <a class="reference external" href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations.html">OpenSSL specific layout</a>.</p>
<p><em>cadata</em> オブジェクトを指定する場合は、PEM エンコードの証明書一つ以上の ASCII 文字列か、DER エンコードの証明書の <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> オブジェクトのどちらかを指定してください。PEM エンコードの証明書の周囲の余分な行は無視されますが、少なくとも一つの証明書が含まれている必要があります。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>新しいオプション引数 <em>cadata</em> 。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.get_ca_certs">
<code class="descclassname">SSLContext.</code><code class="descname">get_ca_certs</code><span class="sig-paren">(</span><em>binary_form=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.get_ca_certs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ロードされた &quot;認証局&quot; (CA=certification authority) 証明書のリストを取得します。 <code class="docutils literal notranslate"><span class="pre">binary_form</span></code> 引数が <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> である場合、リストのそれぞれのエントリは <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a> が出力するような辞書になります。True である場合、このメソッドは、DER エンコード形式の証明書のリストを返します。返却されるリストには、 SSL 接続によって証明書がリクエストおよびロードされない限り、 <em>capath</em> からの証明書は含まれません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">capath ディレクトリ内の証明書は一度でも使われない限りはロードされません。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.get_ciphers">
<code class="descclassname">SSLContext.</code><code class="descname">get_ciphers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.get_ciphers" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>有効な暗号化のリストを取得します。リストは暗号化優先度順に並びます。<a class="reference internal" href="#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_ciphers()</span></code></a> を参照してください。</p>
<p>以下はプログラム例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_SSLv23</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">set_ciphers</span><span class="p">(</span><span class="s1">&#39;ECDHE+AESGCM:!ECDSA&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">get_ciphers</span><span class="p">()</span>  <span class="c1"># OpenSSL 1.0.x</span>
<span class="go">[{&#39;alg_bits&#39;: 256,</span>
<span class="go">  &#39;description&#39;: &#39;ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  &#39;</span>
<span class="go">                 &#39;Enc=AESGCM(256) Mac=AEAD&#39;,</span>
<span class="go">  &#39;id&#39;: 50380848,</span>
<span class="go">  &#39;name&#39;: &#39;ECDHE-RSA-AES256-GCM-SHA384&#39;,</span>
<span class="go">  &#39;protocol&#39;: &#39;TLSv1/SSLv3&#39;,</span>
<span class="go">  &#39;strength_bits&#39;: 256},</span>
<span class="go"> {&#39;alg_bits&#39;: 128,</span>
<span class="go">  &#39;description&#39;: &#39;ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  &#39;</span>
<span class="go">                 &#39;Enc=AESGCM(128) Mac=AEAD&#39;,</span>
<span class="go">  &#39;id&#39;: 50380847,</span>
<span class="go">  &#39;name&#39;: &#39;ECDHE-RSA-AES128-GCM-SHA256&#39;,</span>
<span class="go">  &#39;protocol&#39;: &#39;TLSv1/SSLv3&#39;,</span>
<span class="go">  &#39;strength_bits&#39;: 128}]</span>
</pre></div>
</div>
<p>OpenSSL 1.1 以降では、暗号化辞書に以下のフィールドが追加されました。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">get_ciphers</span><span class="p">()</span>  <span class="c1"># OpenSSL 1.1+</span>
<span class="go">[{&#39;aead&#39;: True,</span>
<span class="go">  &#39;alg_bits&#39;: 256,</span>
<span class="go">  &#39;auth&#39;: &#39;auth-rsa&#39;,</span>
<span class="go">  &#39;description&#39;: &#39;ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  &#39;</span>
<span class="go">                 &#39;Enc=AESGCM(256) Mac=AEAD&#39;,</span>
<span class="go">  &#39;digest&#39;: None,</span>
<span class="go">  &#39;id&#39;: 50380848,</span>
<span class="go">  &#39;kea&#39;: &#39;kx-ecdhe&#39;,</span>
<span class="go">  &#39;name&#39;: &#39;ECDHE-RSA-AES256-GCM-SHA384&#39;,</span>
<span class="go">  &#39;protocol&#39;: &#39;TLSv1.2&#39;,</span>
<span class="go">  &#39;strength_bits&#39;: 256,</span>
<span class="go">  &#39;symmetric&#39;: &#39;aes-256-gcm&#39;},</span>
<span class="go"> {&#39;aead&#39;: True,</span>
<span class="go">  &#39;alg_bits&#39;: 128,</span>
<span class="go">  &#39;auth&#39;: &#39;auth-rsa&#39;,</span>
<span class="go">  &#39;description&#39;: &#39;ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  &#39;</span>
<span class="go">                 &#39;Enc=AESGCM(128) Mac=AEAD&#39;,</span>
<span class="go">  &#39;digest&#39;: None,</span>
<span class="go">  &#39;id&#39;: 50380847,</span>
<span class="go">  &#39;kea&#39;: &#39;kx-ecdhe&#39;,</span>
<span class="go">  &#39;name&#39;: &#39;ECDHE-RSA-AES128-GCM-SHA256&#39;,</span>
<span class="go">  &#39;protocol&#39;: &#39;TLSv1.2&#39;,</span>
<span class="go">  &#39;strength_bits&#39;: 128,</span>
<span class="go">  &#39;symmetric&#39;: &#39;aes-128-gcm&#39;}]</span>
</pre></div>
</div>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: OpenSSL 1.0.2+.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_default_verify_paths">
<code class="descclassname">SSLContext.</code><code class="descname">set_default_verify_paths</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_default_verify_paths" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デフォルトの &quot;認証局&quot; (CA=certification authority) 証明書を、OpenSSL ライブラリがビルドされた際に定義されたファイルシステム上のパスからロードします。残念ながらこのメソッドが成功したかどうかを知るための簡単な方法はありません: 証明書が見つからなくてもエラーは返りません。OpenSSL ライブラリがオペレーティングシステムの一部として提供されている際にはどうやら適切に構成できるようですが。</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_ciphers">
<code class="descclassname">SSLContext.</code><code class="descname">set_ciphers</code><span class="sig-paren">(</span><em>ciphers</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_ciphers" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Set the available ciphers for sockets created with this context.
It should be a string in the <a class="reference external" href="https://www.openssl.org/docs/manmaster/man1/ciphers.html">OpenSSL cipher list format</a>.
If no cipher can be selected (because compile-time options or other
configuration forbids use of all the specified ciphers), an
<a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a> will be raised.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>接続時に SSL ソケットの <a class="reference internal" href="#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.cipher()</span></code></a> メソッドが、現在選択されているその暗号を使います。</p>
<p class="last">OpenSSL 1.1.1 has TLS 1.3 cipher suites enabled by default. The suites
cannot be disabled with <a class="reference internal" href="#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_ciphers()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_alpn_protocols">
<code class="descclassname">SSLContext.</code><code class="descname">set_alpn_protocols</code><span class="sig-paren">(</span><em>protocols</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_alpn_protocols" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSL/TLS ハンドシェイク時にソケットが提示すべきプロトコルを指定します。 <code class="docutils literal notranslate"><span class="pre">['http/1.1',</span> <span class="pre">'spdy/2']</span></code> のような推奨順に並べた ASCII 文字列のリストでなければなりません。プロトコルの選択は <span class="target" id="index-45"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7301.html"><strong>RFC 7301</strong></a> に従いハンドシェイク中に行われます。ハンドシェイクが正常に終了した後、 <a class="reference internal" href="#ssl.SSLSocket.selected_alpn_protocol" title="ssl.SSLSocket.selected_alpn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.selected_alpn_protocol()</span></code></a> メソッドは合意されたプロトコルを返します。</p>
<p>This method will raise <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> if <a class="reference internal" href="#ssl.HAS_ALPN" title="ssl.HAS_ALPN"><code class="xref py py-data docutils literal notranslate"><span class="pre">HAS_ALPN</span></code></a> is
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>OpenSSL 1.1.0 to 1.1.0e will abort the handshake and raise <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a>
when both sides support ALPN but cannot agree on a protocol. 1.1.0f+
behaves like 1.0.2, <a class="reference internal" href="#ssl.SSLSocket.selected_alpn_protocol" title="ssl.SSLSocket.selected_alpn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.selected_alpn_protocol()</span></code></a> returns None.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_npn_protocols">
<code class="descclassname">SSLContext.</code><code class="descname">set_npn_protocols</code><span class="sig-paren">(</span><em>protocols</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_npn_protocols" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Specify which protocols the socket should advertise during the SSL/TLS
handshake. It should be a list of strings, like <code class="docutils literal notranslate"><span class="pre">['http/1.1',</span> <span class="pre">'spdy/2']</span></code>,
ordered by preference. The selection of a protocol will happen during the
handshake, and will play out according to the <a class="reference external" href="https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation">Application Layer Protocol Negotiation</a>. After a
successful handshake, the <a class="reference internal" href="#ssl.SSLSocket.selected_npn_protocol" title="ssl.SSLSocket.selected_npn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.selected_npn_protocol()</span></code></a> method will
return the agreed-upon protocol.</p>
<p>This method will raise <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> if <a class="reference internal" href="#ssl.HAS_NPN" title="ssl.HAS_NPN"><code class="xref py py-data docutils literal notranslate"><span class="pre">HAS_NPN</span></code></a> is
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.sni_callback">
<code class="descclassname">SSLContext.</code><code class="descname">sni_callback</code><a class="headerlink" href="#ssl.SSLContext.sni_callback" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>TLS クライアントがサーバ名表示を指定した際の、SSL/TLS サーバによって TLS Client Hello ハンドシェイクメッセージが受け取られたあとで呼び出されるコールバック関数を登録します。サーバ名表示メカニズムは <span class="target" id="index-46"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6066.html"><strong>RFC 6066</strong></a> セクション 3 - Server Name Indication で述べられています。</p>
<p>Only one callback can be set per <code class="docutils literal notranslate"><span class="pre">SSLContext</span></code>.  If <em>sni_callback</em>
is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> then the callback is disabled. Calling this function a
subsequent time will disable the previously registered callback.</p>
<p>The callback function will be called with three
arguments; the first being the <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a>, the second is a string
that represents the server name that the client is intending to communicate
(or <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> if the TLS Client Hello does not contain a server name)
and the third argument is the original <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>. The server name
argument is text. For internationalized domain name, the server
name is an IDN A-label (<code class="docutils literal notranslate"><span class="pre">&quot;xn--pythn-mua.org&quot;</span></code>).</p>
<p>このコールバックの典型的な利用方法は、 <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> の <a class="reference internal" href="#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLSocket.context</span></code></a> 属性を、サーバ名に合致する証明書チェインを持つ新しい <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> オブジェクトに変更することです。</p>
<p>TLS 接続の初期ネゴシエーションのフェーズなので、 <a class="reference internal" href="#ssl.SSLSocket.selected_alpn_protocol" title="ssl.SSLSocket.selected_alpn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.selected_alpn_protocol()</span></code></a>, <a class="reference internal" href="#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLSocket.context</span></code></a> のような限られたメソッドと属性のみ使えます。 <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a>, <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a>, <a class="reference internal" href="#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.cipher()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.compress()</span></code> メソッドは TLS 接続が TLS Client Hello よりも先に進行していることを必要としますから、これらは意味のある値を返しませんし、安全に呼び出すこともできません。</p>
<p>The <em>sni_callback</em> function must return <code class="docutils literal notranslate"><span class="pre">None</span></code> to allow the
TLS negotiation to continue.  If a TLS failure is required, a constant
<a class="reference internal" href="#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ALERT_DESCRIPTION_*</span></code></a> can be
returned.  Other return values will result in a TLS fatal error with
<a class="reference internal" href="#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ALERT_DESCRIPTION_INTERNAL_ERROR</span></code></a>.</p>
<p>If an exception is raised from the <em>sni_callback</em> function the TLS
connection will terminate with a fatal TLS alert message
<a class="reference internal" href="#ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE" title="ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE"><code class="xref py py-const docutils literal notranslate"><span class="pre">ALERT_DESCRIPTION_HANDSHAKE_FAILURE</span></code></a>.</p>
<p>このメソッドは OpenSSL ライブラリが OPENSSL_NO_TLSEXT を定義してビルドされている場合、 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> を送出します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.set_servername_callback">
<code class="descclassname">SSLContext.</code><code class="descname">set_servername_callback</code><span class="sig-paren">(</span><em>server_name_callback</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_servername_callback" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This is a legacy API retained for backwards compatibility. When possible,
you should use <a class="reference internal" href="#ssl.SSLContext.sni_callback" title="ssl.SSLContext.sni_callback"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sni_callback</span></code></a> instead. The given <em>server_name_callback</em>
is similar to <em>sni_callback</em>, except that when the server hostname is an
IDN-encoded internationalized domain name, the <em>server_name_callback</em>
receives a decoded U-label (<code class="docutils literal notranslate"><span class="pre">&quot;pythön.org&quot;</span></code>).</p>
<p>If there is an decoding error on the server name, the TLS connection will
terminate with an <a class="reference internal" href="#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ALERT_DESCRIPTION_INTERNAL_ERROR</span></code></a> fatal TLS
alert message to the client.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.load_dh_params">
<code class="descclassname">SSLContext.</code><code class="descname">load_dh_params</code><span class="sig-paren">(</span><em>dhfile</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_dh_params" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Load the key generation parameters for Diffie-Hellman (DH) key exchange.
Using DH key exchange improves forward secrecy at the expense of
computational resources (both on the server and on the client).
The <em>dhfile</em> parameter should be the path to a file containing DH
parameters in PEM format.</p>
<p>この設定はクライアントソケットには適用されません。さらにセキュリティを改善するのに <a class="reference internal" href="#ssl.OP_SINGLE_DH_USE" title="ssl.OP_SINGLE_DH_USE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_SINGLE_DH_USE</span></code></a> オプションも利用できます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_ecdh_curve">
<code class="descclassname">SSLContext.</code><code class="descname">set_ecdh_curve</code><span class="sig-paren">(</span><em>curve_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_ecdh_curve" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>楕円曲線ディフィー・ヘルマン(ECDH)鍵交換の曲線名を指定します。ECDH はもとの DH に較べて、ほぼ間違いなく同程度に安全である一方で、顕著に高速です。 <em>curve_name</em> パラメータは既知の楕円曲線を表す文字列でなければなりません。例えば <code class="docutils literal notranslate"><span class="pre">prime256v1</span></code> が広くサポートされている曲線です。</p>
<p>この設定はクライアントソケットには適用されません。さらにセキュリティを改善するのに <a class="reference internal" href="#ssl.OP_SINGLE_ECDH_USE" title="ssl.OP_SINGLE_ECDH_USE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_SINGLE_ECDH_USE</span></code></a> オプションも利用できます。</p>
<p>このメソッドは <a class="reference internal" href="#ssl.HAS_ECDH" title="ssl.HAS_ECDH"><code class="xref py py-data docutils literal notranslate"><span class="pre">HAS_ECDH</span></code></a> が <code class="docutils literal notranslate"><span class="pre">False</span></code> の場合は利用できません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference external" href="https://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy">SSL/TLS &amp; Perfect Forward Secrecy</a></dt>
<dd>Vincent Bernat.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.wrap_socket">
<code class="descclassname">SSLContext.</code><code class="descname">wrap_socket</code><span class="sig-paren">(</span><em>sock</em>, <em>server_side=False</em>, <em>do_handshake_on_connect=True</em>, <em>suppress_ragged_eofs=True</em>, <em>server_hostname=None</em>, <em>session=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.wrap_socket" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Wrap an existing Python socket <em>sock</em> and return an instance of
<a class="reference internal" href="#ssl.SSLContext.sslsocket_class" title="ssl.SSLContext.sslsocket_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.sslsocket_class</span></code></a> (default <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>). The
returned SSL socket is tied to the context, its settings and certificates.
<em>sock</em> must be a <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a> socket; other
socket types are unsupported.</p>
<p><code class="docutils literal notranslate"><span class="pre">server_side</span></code> 引数は真偽値で、このソケットがサーバサイドとクライアントサイドのどちらの動作をするのかを指定します。</p>
<p>For client-side sockets, the context construction is lazy; if the
underlying socket isn't connected yet, the context construction will be
performed after <code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code> is called on the socket.  For
server-side sockets, if the socket has no remote peer, it is assumed
to be a listening socket, and the server-side SSL wrapping is
automatically performed on client connections accepted via the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code> method. The method may raise <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a>.</p>
<p>クライアントからの接続では、 <em>server_hostname</em> で接続先サービスのホスト名を指定できます。これは HTTP バーチャルホストにかなり似て、シングルサーバで複数の SSL ベースのサービスを別々の証明書でホストしているようなサーバに対して使えます。 <em>server_side</em> が True の場合に <em>server_hostname</em> を指定すると <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> を送出します。</p>
<p><code class="docutils literal notranslate"><span class="pre">do_handshake_on_connect</span></code> 引数は、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect()</span></code> の後に自動的に SSLハンドシェイクを行うか、それともアプリケーションが明示的に <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a> メソッドを実行するかを指定します。 <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a> を明示的に呼びだすことで、ハンドシェイクによるソケットI/Oのブロッキング動作を制御できます。</p>
<p><code class="docutils literal notranslate"><span class="pre">suppress_ragged_eofs</span></code> 引数は、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.recv()</span></code> メソッドが、接続先から予期しないEOF を受け取った時に通知する方法を指定します。 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> (デフォルト) の場合、下位のソケットレイヤーから予期せぬEOFエラーが来た場合、通常のEOF (空のバイト列オブジェクト)を返します。 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> の場合、呼び出し元に例外を投げて通知します。</p>
<p><em>session</em>, <a class="reference internal" href="#ssl.SSLSocket.session" title="ssl.SSLSocket.session"><code class="xref py py-attr docutils literal notranslate"><span class="pre">session</span></code></a> を参照してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>OpenSSL が SNI をサポートしなくても server_hostname を許容するようになりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span><em>session</em> 引数が追加されました。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.7 で変更: </span>The method returns on instance of <a class="reference internal" href="#ssl.SSLContext.sslsocket_class" title="ssl.SSLContext.sslsocket_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.sslsocket_class</span></code></a>
instead of hard-coded <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>.</p>
</div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.sslsocket_class">
<code class="descclassname">SSLContext.</code><code class="descname">sslsocket_class</code><a class="headerlink" href="#ssl.SSLContext.sslsocket_class" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The return type of <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>, defaults to
<a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>. The attribute can be overridden on instance of class
in order to return a custom subclass of <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.wrap_bio">
<code class="descclassname">SSLContext.</code><code class="descname">wrap_bio</code><span class="sig-paren">(</span><em>incoming</em>, <em>outgoing</em>, <em>server_side=False</em>, <em>server_hostname=None</em>, <em>session=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.wrap_bio" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Wrap the BIO objects <em>incoming</em> and <em>outgoing</em> and return an instance of
<a class="reference internal" href="#ssl.SSLContext.sslobject_class" title="ssl.SSLContext.sslobject_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.sslobject_class</span></code></a> (default <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>). The SSL
routines will read input data from the incoming BIO and write data to the
outgoing BIO.</p>
<p><em>server_side</em>、 <em>server_hostname</em> 、 <em>session</em> 引数は、 <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> での意味と同じ意味を持ちます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span><em>session</em> 引数が追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.7 で変更: </span>The method returns on instance of <a class="reference internal" href="#ssl.SSLContext.sslobject_class" title="ssl.SSLContext.sslobject_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.sslobject_class</span></code></a>
instead of hard-coded <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.sslobject_class">
<code class="descclassname">SSLContext.</code><code class="descname">sslobject_class</code><a class="headerlink" href="#ssl.SSLContext.sslobject_class" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The return type of <a class="reference internal" href="#ssl.SSLContext.wrap_bio" title="ssl.SSLContext.wrap_bio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_bio()</span></code></a>, defaults to
<a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>. The attribute can be overridden on instance of class
in order to return a custom subclass of <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.session_stats">
<code class="descclassname">SSLContext.</code><code class="descname">session_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.session_stats" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Get statistics about the SSL sessions created or managed by this context.
A dictionary is returned which maps the names of each <a class="reference external" href="https://www.openssl.org/docs/man1.1.0/ssl/SSL_CTX_sess_number.html">piece of information</a> to their
numeric values.  For example, here is the total number of hits and misses
in the session cache since the context was created:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">session_stats</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;hits&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;misses&#39;</span><span class="p">]</span>
<span class="go">(0, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.check_hostname">
<code class="descclassname">SSLContext.</code><code class="descname">check_hostname</code><a class="headerlink" href="#ssl.SSLContext.check_hostname" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Whether to match the peer cert's hostname with <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code></a> in
<a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a>. The context's
<a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a> must be set to <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a> or
<a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>, and you must pass <em>server_hostname</em> to
<a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> in order to match the hostname.  Enabling
hostname checking automatically sets <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a> from
<a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a> to <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>.  It cannot be set back to
<a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a> as long as hostname checking is enabled. The
<a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> protocol enables hostname checking by default.
With other protocols, hostname checking must be enabled explicitly.</p>
<p>以下はプログラム例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLSv1_2</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">verify_mode</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span>
<span class="n">context</span><span class="o">.</span><span class="n">check_hostname</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_default_certs</span><span class="p">()</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">ssl_sock</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">server_hostname</span><span class="o">=</span><span class="s1">&#39;www.verisign.com&#39;</span><span class="p">)</span>
<span class="n">ssl_sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;www.verisign.com&#39;</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.7 で変更: </span><a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a> is now automatically changed
to <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>  when hostname checking is enabled and
<a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a> is <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a>. Previously
the same operation would have failed with a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">この機能にはOpenSSL0.9.8f以降が必要です。</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.keylog_filename">
<code class="descclassname">SSLContext.</code><code class="descname">keylog_filename</code><a class="headerlink" href="#ssl.SSLContext.keylog_filename" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Write TLS keys to a keylog file, whenever key material is generated or
received. The keylog file is designed for debugging purposes only. The
file format is specified by NSS and used by many traffic analyzers such
as Wireshark. The log file is opened in append-only mode. Writes are
synchronized between threads, but not between processes.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.8 で追加.</span></p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">This features requires OpenSSL 1.1.1 or newer.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.maximum_version">
<code class="descclassname">SSLContext.</code><code class="descname">maximum_version</code><a class="headerlink" href="#ssl.SSLContext.maximum_version" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A <a class="reference internal" href="#ssl.TLSVersion" title="ssl.TLSVersion"><code class="xref py py-class docutils literal notranslate"><span class="pre">TLSVersion</span></code></a> enum member representing the highest supported
TLS version. The value defaults to <a class="reference internal" href="#ssl.TLSVersion.MAXIMUM_SUPPORTED" title="ssl.TLSVersion.MAXIMUM_SUPPORTED"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TLSVersion.MAXIMUM_SUPPORTED</span></code></a>.
The attribute is read-only for protocols other than <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-attr docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>,
<a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-attr docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a>, and <a class="reference internal" href="#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-attr docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a>.</p>
<p>The attributes <a class="reference internal" href="#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">maximum_version</span></code></a>,
<a class="reference internal" href="#ssl.SSLContext.minimum_version" title="ssl.SSLContext.minimum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">minimum_version</span></code></a> and
<a class="reference internal" href="#ssl.SSLContext.options" title="ssl.SSLContext.options"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.options</span></code></a> all affect the supported SSL
and TLS versions of the context. The implementation does not prevent
invalid combination. For example a context with
<a class="reference internal" href="#ssl.OP_NO_TLSv1_2" title="ssl.OP_NO_TLSv1_2"><code class="xref py py-attr docutils literal notranslate"><span class="pre">OP_NO_TLSv1_2</span></code></a> in <a class="reference internal" href="#ssl.SSLContext.options" title="ssl.SSLContext.options"><code class="xref py py-attr docutils literal notranslate"><span class="pre">options</span></code></a> and
<a class="reference internal" href="#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">maximum_version</span></code></a> set to <a class="reference internal" href="#ssl.TLSVersion.TLSv1_2" title="ssl.TLSVersion.TLSv1_2"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TLSVersion.TLSv1_2</span></code></a>
will not be able to establish a TLS 1.2 connection.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">This attribute is not available unless the ssl module is compiled
with OpenSSL 1.1.0g or newer.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.minimum_version">
<code class="descclassname">SSLContext.</code><code class="descname">minimum_version</code><a class="headerlink" href="#ssl.SSLContext.minimum_version" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.maximum_version</span></code></a> except it is the lowest
supported version or <a class="reference internal" href="#ssl.TLSVersion.MINIMUM_SUPPORTED" title="ssl.TLSVersion.MINIMUM_SUPPORTED"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TLSVersion.MINIMUM_SUPPORTED</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">This attribute is not available unless the ssl module is compiled
with OpenSSL 1.1.0g or newer.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.num_tickets">
<code class="descclassname">SSLContext.</code><code class="descname">num_tickets</code><a class="headerlink" href="#ssl.SSLContext.num_tickets" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Control the number of TLS 1.3 session tickets of a
<code class="xref py py-attr docutils literal notranslate"><span class="pre">TLS_PROTOCOL_SERVER</span></code> context. The setting has no impact on TLS
1.0 to 1.2 connections.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">This attribute is not available unless the ssl module is compiled
with OpenSSL 1.1.1 or newer.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.8 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.options">
<code class="descclassname">SSLContext.</code><code class="descname">options</code><a class="headerlink" href="#ssl.SSLContext.options" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このコンテキストで有効になっている SSL オプションを表す整数。デフォルトの値は <a class="reference internal" href="#ssl.OP_ALL" title="ssl.OP_ALL"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_ALL</span></code></a> ですが、 <a class="reference internal" href="#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv2</span></code></a> のような他の値をビット OR 演算で指定できます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">With versions of OpenSSL older than 0.9.8m, it is only possible
to set options, not to clear them.  Attempting to clear an option
(by resetting the corresponding bits) will raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span><a class="reference internal" href="#ssl.SSLContext.options" title="ssl.SSLContext.options"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.options</span></code></a> は次のように <a class="reference internal" href="#ssl.Options" title="ssl.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">Options</span></code></a> のフラグを返します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span><span class="o">.</span><span class="n">options</span>  <span class="c1"># doctest: +SKIP</span>
<span class="go">&lt;Options.OP_ALL|OP_NO_SSLv3|OP_NO_SSLv2|OP_NO_COMPRESSION: 2197947391&gt;</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.post_handshake_auth">
<code class="descclassname">SSLContext.</code><code class="descname">post_handshake_auth</code><a class="headerlink" href="#ssl.SSLContext.post_handshake_auth" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Enable TLS 1.3 post-handshake client authentication. Post-handshake auth
is disabled by default and a server can only request a TLS client
certificate during the initial handshake. When enabled, a server may
request a TLS client certificate at any time after the handshake.</p>
<p>When enabled on client-side sockets, the client signals the server that
it supports post-handshake authentication.</p>
<p>When enabled on server-side sockets, <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a> must
be set to <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a> or <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>, too. The
actual client cert exchange is delayed until
<a class="reference internal" href="#ssl.SSLSocket.verify_client_post_handshake" title="ssl.SSLSocket.verify_client_post_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.verify_client_post_handshake()</span></code></a> is called and some I/O is
performed.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3
support, the property value is None and can't be modified</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.8 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.protocol">
<code class="descclassname">SSLContext.</code><code class="descname">protocol</code><a class="headerlink" href="#ssl.SSLContext.protocol" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンテキストの構築時に選択されたプロトコルバージョン。この属性は読み出し専用です。</p>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.hostname_checks_common_name">
<code class="descclassname">SSLContext.</code><code class="descname">hostname_checks_common_name</code><a class="headerlink" href="#ssl.SSLContext.hostname_checks_common_name" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Whether <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> falls back to verify the cert's
subject common name in the absence of a subject alternative name
extension (default: true).</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Only writeable with OpenSSL 1.1.0 or higher.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.verify_flags">
<code class="descclassname">SSLContext.</code><code class="descname">verify_flags</code><a class="headerlink" href="#ssl.SSLContext.verify_flags" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>証明書の検証操作のためのフラグです。 <a class="reference internal" href="#ssl.VERIFY_CRL_CHECK_LEAF" title="ssl.VERIFY_CRL_CHECK_LEAF"><code class="xref py py-data docutils literal notranslate"><span class="pre">VERIFY_CRL_CHECK_LEAF</span></code></a> などのフラグをビット OR 演算でセットできます。デフォルトでは OpenSSL は証明書失効リスト (CRLs) を必要としませんし検証にも使いません。openssl version 0.9.8+ でのみ利用可能です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span><a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> は次のように <a class="reference internal" href="#ssl.VerifyFlags" title="ssl.VerifyFlags"><code class="xref py py-class docutils literal notranslate"><span class="pre">VerifyFlags</span></code></a> のフラグを返します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span><span class="o">.</span><span class="n">verify_flags</span>  <span class="c1"># doctest: +SKIP</span>
<span class="go">&lt;VerifyFlags.VERIFY_X509_TRUSTED_FIRST: 32768&gt;</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.verify_mode">
<code class="descclassname">SSLContext.</code><code class="descname">verify_mode</code><a class="headerlink" href="#ssl.SSLContext.verify_mode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>接続先の証明書の検証を試みるかどうか、また、検証が失敗した場合にどのように振舞うべきかを制御します。この属性は <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a>, <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a>, <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> のうちどれか一つでなければなりません。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span><a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a> は次のように <a class="reference internal" href="#ssl.VerifyMode" title="ssl.VerifyMode"><code class="xref py py-class docutils literal notranslate"><span class="pre">VerifyMode</span></code></a> enum (列挙) を返します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span><span class="o">.</span><span class="n">verify_mode</span>
<span class="go">&lt;VerifyMode.CERT_REQUIRED: 2&gt;</span>
</pre></div>
</div>
</div>
</dd></dl>

<span class="target" id="index-17"></span></div>
<div class="section" id="certificates">
<span id="ssl-certificates"></span><span id="index-18"></span><h2>証明書<a class="headerlink" href="#certificates" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>証明書を大まかに説明すると、公開鍵/秘密鍵システムの一種です。このシステムでは、各 <em>principal</em> (これはマシン、人、組織などです) は、ユニークな2つの暗号鍵を割り当てられます。1つは公開され、 <em>公開鍵(public key)</em> と呼ばれます。もう一方は秘密にされ、 <em>秘密鍵(private key)</em> と呼ばれます。 2つの鍵は関連しており、片方の鍵で暗号化したメッセージは、もう片方の鍵 <strong>のみ</strong> で復号できます。</p>
<p>A certificate contains information about two principals.  It contains the name
of a <em>subject</em>, and the subject's public key.  It also contains a statement by a
second principal, the <em>issuer</em>, that the subject is who they claim to be, and
that this is indeed the subject's public key.  The issuer's statement is signed
with the issuer's private key, which only the issuer knows.  However, anyone can
verify the issuer's statement by finding the issuer's public key, decrypting the
statement with it, and comparing it to the other information in the certificate.
The certificate also contains information about the time period over which it is
valid.  This is expressed as two fields, called &quot;notBefore&quot; and &quot;notAfter&quot;.</p>
<p>Python において証明書を利用する場合、クライアントもサーバーも自分を証明するために証明書を利用することができます。ネットワーク接続の相手側に証明書の提示を要求する事ができ、そのクライアントやサーバーが認証を必要とするならその証明書を認証することができます。認証が失敗した場合、接続は例外を発生させます。認証は下位層のOpenSSLフレームワークが自動的に行います。アプリケーションは認証機構について意識する必要はありません。しかし、アプリケーションは認証プロセスのために幾つかの証明書を提供する必要があるかもしれません。</p>
<p>Python は証明書を格納したファイルを利用します。そのファイルは &quot;PEM&quot; (<span class="target" id="index-47"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1422.html"><strong>RFC 1422</strong></a> 参照) フォーマットという、ヘッダー行とフッター行の間にbase-64エンコードされた形をとっている必要があります。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">PEM</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
<div class="section" id="certificate-chains">
<h3>証明書チェイン<a class="headerlink" href="#certificate-chains" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Pythonが利用する証明書を格納したファイルは、ときには <em>証明書チェイン(certificate chain)</em> と呼ばれる証明書のシーケンスを格納します。このチェインの先頭には、まずクライアントやサーバーである principal の証明書を置き、それ以降には、その証明書の発行者(issuer)の証明書などを続け、最後に証明対象(subject)と発行者が同じ <em>自己署名(self-signed)</em> 証明書で終わります。この最後の証明書は <em>ルート証明書(root certificate</em> と呼ばれます。これらの証明書チェインは単純に1つの証明書ファイルに結合してください。例えば、3つの証明書からなる証明書チェインがある場合、私たちのサーバーの証明書から、私たちのサーバーに署名した認証局の証明書、そして認証局の証明書を発行した機関のルート証明書と続きます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="k">for</span> <span class="n">your</span> <span class="n">server</span><span class="p">)</span><span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">the</span> <span class="n">certificate</span> <span class="k">for</span> <span class="n">the</span> <span class="n">CA</span><span class="p">)</span><span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">the</span> <span class="n">root</span> <span class="n">certificate</span> <span class="k">for</span> <span class="n">the</span> <span class="n">CA</span><span class="s1">&#39;s issuer)...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
</div>
<div class="section" id="ca-certificates">
<h3>CA 証明書<a class="headerlink" href="#ca-certificates" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>もし相手から送られてきた証明書の認証をしたい場合、信頼している各発行者の証明書チェインが入った &quot;CA certs&quot; ファイルを提供する必要があります。繰り返しますが、このファイルは単純に、各チェインを結合しただけのものです。認証のために、Pythonはそのファイルの中の最初にマッチしたチェインを利用します。<a class="reference internal" href="#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_default_certs()</span></code></a> を呼び出すことでプラットフォームの証明書ファイルも使われますが、これは <a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> によって自動的に行われます。</p>
</div>
<div class="section" id="combined-key-and-certificate">
<h3>秘密鍵と証明書の組み合わせ<a class="headerlink" href="#combined-key-and-certificate" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>多くの場合、証明書と同じファイルに秘密鍵も格納されています。この場合、 <a class="reference internal" href="#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_cert_chain()</span></code></a>, <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> には <code class="docutils literal notranslate"><span class="pre">certfile</span></code> 引数だけが必要とされます。秘密鍵が証明書ファイルに格納されている場合、秘密鍵は証明書チェインの最初の証明書よりも先にないといけません。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">private</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">PEM</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
</div>
<div class="section" id="self-signed-certificates">
<h3>自己署名証明書<a class="headerlink" href="#self-signed-certificates" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>SSL暗号化接続サービスを提供するサーバーを建てる場合、適切な証明書を取得するには、認証局から買うなどの幾つかの方法があります。また、自己署名証明書を作るケースもあります。 OpenSSLを使って自己署名証明書を作るには、次のようにします。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">openssl</span> <span class="n">req</span> <span class="o">-</span><span class="n">new</span> <span class="o">-</span><span class="n">x509</span> <span class="o">-</span><span class="n">days</span> <span class="mi">365</span> <span class="o">-</span><span class="n">nodes</span> <span class="o">-</span><span class="n">out</span> <span class="n">cert</span><span class="o">.</span><span class="n">pem</span> <span class="o">-</span><span class="n">keyout</span> <span class="n">cert</span><span class="o">.</span><span class="n">pem</span>
<span class="n">Generating</span> <span class="n">a</span> <span class="mi">1024</span> <span class="n">bit</span> <span class="n">RSA</span> <span class="n">private</span> <span class="n">key</span>
<span class="o">.......++++++</span>
<span class="o">.............................++++++</span>
<span class="n">writing</span> <span class="n">new</span> <span class="n">private</span> <span class="n">key</span> <span class="n">to</span> <span class="s1">&#39;cert.pem&#39;</span>
<span class="o">-----</span>
<span class="n">You</span> <span class="n">are</span> <span class="n">about</span> <span class="n">to</span> <span class="n">be</span> <span class="n">asked</span> <span class="n">to</span> <span class="n">enter</span> <span class="n">information</span> <span class="n">that</span> <span class="n">will</span> <span class="n">be</span> <span class="n">incorporated</span>
<span class="n">into</span> <span class="n">your</span> <span class="n">certificate</span> <span class="n">request</span><span class="o">.</span>
<span class="n">What</span> <span class="n">you</span> <span class="n">are</span> <span class="n">about</span> <span class="n">to</span> <span class="n">enter</span> <span class="ow">is</span> <span class="n">what</span> <span class="ow">is</span> <span class="n">called</span> <span class="n">a</span> <span class="n">Distinguished</span> <span class="n">Name</span> <span class="ow">or</span> <span class="n">a</span> <span class="n">DN</span><span class="o">.</span>
<span class="n">There</span> <span class="n">are</span> <span class="n">quite</span> <span class="n">a</span> <span class="n">few</span> <span class="n">fields</span> <span class="n">but</span> <span class="n">you</span> <span class="n">can</span> <span class="n">leave</span> <span class="n">some</span> <span class="n">blank</span>
<span class="n">For</span> <span class="n">some</span> <span class="n">fields</span> <span class="n">there</span> <span class="n">will</span> <span class="n">be</span> <span class="n">a</span> <span class="n">default</span> <span class="n">value</span><span class="p">,</span>
<span class="n">If</span> <span class="n">you</span> <span class="n">enter</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">the</span> <span class="n">field</span> <span class="n">will</span> <span class="n">be</span> <span class="n">left</span> <span class="n">blank</span><span class="o">.</span>
<span class="o">-----</span>
<span class="n">Country</span> <span class="n">Name</span> <span class="p">(</span><span class="mi">2</span> <span class="n">letter</span> <span class="n">code</span><span class="p">)</span> <span class="p">[</span><span class="n">AU</span><span class="p">]:</span><span class="n">US</span>
<span class="n">State</span> <span class="ow">or</span> <span class="n">Province</span> <span class="n">Name</span> <span class="p">(</span><span class="n">full</span> <span class="n">name</span><span class="p">)</span> <span class="p">[</span><span class="n">Some</span><span class="o">-</span><span class="n">State</span><span class="p">]:</span><span class="n">MyState</span>
<span class="n">Locality</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">city</span><span class="p">)</span> <span class="p">[]:</span><span class="n">Some</span> <span class="n">City</span>
<span class="n">Organization</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">company</span><span class="p">)</span> <span class="p">[</span><span class="n">Internet</span> <span class="n">Widgits</span> <span class="n">Pty</span> <span class="n">Ltd</span><span class="p">]:</span><span class="n">My</span> <span class="n">Organization</span><span class="p">,</span> <span class="n">Inc</span><span class="o">.</span>
<span class="n">Organizational</span> <span class="n">Unit</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">section</span><span class="p">)</span> <span class="p">[]:</span><span class="n">My</span> <span class="n">Group</span>
<span class="n">Common</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">YOUR</span> <span class="n">name</span><span class="p">)</span> <span class="p">[]:</span><span class="n">myserver</span><span class="o">.</span><span class="n">mygroup</span><span class="o">.</span><span class="n">myorganization</span><span class="o">.</span><span class="n">com</span>
<span class="n">Email</span> <span class="n">Address</span> <span class="p">[]:</span><span class="n">ops</span><span class="nd">@myserver</span><span class="o">.</span><span class="n">mygroup</span><span class="o">.</span><span class="n">myorganization</span><span class="o">.</span><span class="n">com</span>
<span class="o">%</span>
</pre></div>
</div>
<p>自己署名証明書の欠点は、それ自身がルート証明書であり、他の人はその証明書を持っていない (そして信頼しない)ことです。</p>
</div>
</div>
<div class="section" id="examples">
<h2>使用例<a class="headerlink" href="#examples" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="testing-for-ssl-support">
<h3>SSLサポートをテストする<a class="headerlink" href="#testing-for-ssl-support" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>インストールされているPythonがSSLをサポートしているかどうかをテストするために、ユーザーコードは次のイディオムを利用することができます。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">ssl</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="k">else</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># do something that requires SSL support</span>
</pre></div>
</div>
</div>
<div class="section" id="client-side-operation">
<h3>クライアントサイドの処理<a class="headerlink" href="#client-side-operation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この例では、自動的に証明書の検証を行うことを含む望ましいセキュリティ設定でクライアントソケットの SSL コンテキストを作ります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span>
</pre></div>
</div>
<p>自分自身でセキュリティ設定を調整したい場合、コンテキストを一から作ることはできます (ただし、正しくない設定をしてしまいがちなことに注意してください):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLS_CLIENT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">load_verify_locations</span><span class="p">(</span><span class="s2">&quot;/etc/ssl/certs/ca-bundle.crt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>(このスニペットはすべての CA 証明書が <code class="docutils literal notranslate"><span class="pre">/etc/ssl/certs/ca-bundle.crt</span></code> にバンドルされていることを仮定しています; もし違っていればエラーになりますので、適宜修正してください)</p>
<p>The <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> protocol configures the context for cert
validation and hostname verification. <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a> is
set to <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> and <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> is set
to <code class="docutils literal notranslate"><span class="pre">True</span></code>. All other protocols create SSL contexts with insecure defaults.</p>
<p>When you use the context to connect to a server, <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>
and <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> validate the server certificate: it
ensures that the server certificate was signed with one of the CA
certificates, checks the signature for correctness, and verifies other
properties like validity and identity of the hostname:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">),</span>
<span class="gp">... </span>                           <span class="n">server_hostname</span><span class="o">=</span><span class="s2">&quot;www.python.org&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s2">&quot;www.python.org&quot;</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span>
</pre></div>
</div>
<p>そして証明書を持ってくることができます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cert</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">getpeercert</span><span class="p">()</span>
</pre></div>
</div>
<p>証明書が、期待しているサービス (つまり、 HTTPS ホスト <code class="docutils literal notranslate"><span class="pre">www.python.org</span></code>) の身元を特定していることを視覚的に点検してみましょう:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">cert</span><span class="p">)</span>
<span class="go">{&#39;OCSP&#39;: (&#39;http://ocsp.digicert.com&#39;,),</span>
<span class="go"> &#39;caIssuers&#39;: (&#39;http://cacerts.digicert.com/DigiCertSHA2ExtendedValidationServerCA.crt&#39;,),</span>
<span class="go"> &#39;crlDistributionPoints&#39;: (&#39;http://crl3.digicert.com/sha2-ev-server-g1.crl&#39;,</span>
<span class="go">                           &#39;http://crl4.digicert.com/sha2-ev-server-g1.crl&#39;),</span>
<span class="go"> &#39;issuer&#39;: (((&#39;countryName&#39;, &#39;US&#39;),),</span>
<span class="go">            ((&#39;organizationName&#39;, &#39;DigiCert Inc&#39;),),</span>
<span class="go">            ((&#39;organizationalUnitName&#39;, &#39;www.digicert.com&#39;),),</span>
<span class="go">            ((&#39;commonName&#39;, &#39;DigiCert SHA2 Extended Validation Server CA&#39;),)),</span>
<span class="go"> &#39;notAfter&#39;: &#39;Sep  9 12:00:00 2016 GMT&#39;,</span>
<span class="go"> &#39;notBefore&#39;: &#39;Sep  5 00:00:00 2014 GMT&#39;,</span>
<span class="go"> &#39;serialNumber&#39;: &#39;01BB6F00122B177F36CAB49CEA8B6B26&#39;,</span>
<span class="go"> &#39;subject&#39;: (((&#39;businessCategory&#39;, &#39;Private Organization&#39;),),</span>
<span class="go">             ((&#39;1.3.6.1.4.1.311.60.2.1.3&#39;, &#39;US&#39;),),</span>
<span class="go">             ((&#39;1.3.6.1.4.1.311.60.2.1.2&#39;, &#39;Delaware&#39;),),</span>
<span class="go">             ((&#39;serialNumber&#39;, &#39;3359300&#39;),),</span>
<span class="go">             ((&#39;streetAddress&#39;, &#39;16 Allen Rd&#39;),),</span>
<span class="go">             ((&#39;postalCode&#39;, &#39;03894-4801&#39;),),</span>
<span class="go">             ((&#39;countryName&#39;, &#39;US&#39;),),</span>
<span class="go">             ((&#39;stateOrProvinceName&#39;, &#39;NH&#39;),),</span>
<span class="go">             ((&#39;localityName&#39;, &#39;Wolfeboro&#39;),),</span>
<span class="go">             ((&#39;organizationName&#39;, &#39;Python Software Foundation&#39;),),</span>
<span class="go">             ((&#39;commonName&#39;, &#39;www.python.org&#39;),)),</span>
<span class="go"> &#39;subjectAltName&#39;: ((&#39;DNS&#39;, &#39;www.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;pypi.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;docs.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;testpypi.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;bugs.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;wiki.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;hg.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;mail.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;packaging.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;pythonhosted.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;www.pythonhosted.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;test.pythonhosted.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;us.pycon.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;id.python.org&#39;)),</span>
<span class="go"> &#39;version&#39;: 3}</span>
</pre></div>
</div>
<p>SSL チャネルは今や確立されて証明書が検証されているので、サーバとのお喋りを続けることができます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;HEAD / HTTP/1.0</span><span class="se">\r\n</span><span class="s2">Host: linuxfr.org</span><span class="se">\r\n\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">))</span>
<span class="go">[b&#39;HTTP/1.1 200 OK&#39;,</span>
<span class="go"> b&#39;Date: Sat, 18 Oct 2014 18:27:20 GMT&#39;,</span>
<span class="go"> b&#39;Server: nginx&#39;,</span>
<span class="go"> b&#39;Content-Type: text/html; charset=utf-8&#39;,</span>
<span class="go"> b&#39;X-Frame-Options: SAMEORIGIN&#39;,</span>
<span class="go"> b&#39;Content-Length: 45679&#39;,</span>
<span class="go"> b&#39;Accept-Ranges: bytes&#39;,</span>
<span class="go"> b&#39;Via: 1.1 varnish&#39;,</span>
<span class="go"> b&#39;Age: 2188&#39;,</span>
<span class="go"> b&#39;X-Served-By: cache-lcy1134-LCY&#39;,</span>
<span class="go"> b&#39;X-Cache: HIT&#39;,</span>
<span class="go"> b&#39;X-Cache-Hits: 11&#39;,</span>
<span class="go"> b&#39;Vary: Cookie&#39;,</span>
<span class="go"> b&#39;Strict-Transport-Security: max-age=63072000; includeSubDomains&#39;,</span>
<span class="go"> b&#39;Connection: close&#39;,</span>
<span class="go"> b&#39;&#39;,</span>
<span class="go"> b&#39;&#39;]</span>
</pre></div>
</div>
<p>このドキュメントの下の方の、 <a class="reference internal" href="#ssl-security"><span class="std std-ref">セキュリティで考慮すべき点</span></a> に関する議論を参照してください。</p>
</div>
<div class="section" id="server-side-operation">
<h3>サーバサイドの処理<a class="headerlink" href="#server-side-operation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>サーバサイドの処理では、通常、サーバー証明書と秘密鍵がそれぞれファイルに格納された形で必要です。最初に秘密鍵と証明書が保持されたコンテキストを作成し、クライアントがあなたの信憑性をチェックできるようにします。そののちにソケットを開き、ポートにバインドし、そのソケットの <code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code> を呼び、クライアントからの接続を待ちます。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">Purpose</span><span class="o">.</span><span class="n">CLIENT_AUTH</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_cert_chain</span><span class="p">(</span><span class="n">certfile</span><span class="o">=</span><span class="s2">&quot;mycertfile&quot;</span><span class="p">,</span> <span class="n">keyfile</span><span class="o">=</span><span class="s2">&quot;mykeyfile&quot;</span><span class="p">)</span>

<span class="n">bindsocket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;myaddr.mydomain.com&#39;</span><span class="p">,</span> <span class="mi">10023</span><span class="p">))</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>クライアントが接続してきた場合、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code> を呼んで新しいソケットを作成し、接続のためにサーバサイドの SSL ソケットを、コンテキストの <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> メソッドで作ります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">newsocket</span><span class="p">,</span> <span class="n">fromaddr</span> <span class="o">=</span> <span class="n">bindsocket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
    <span class="n">connstream</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">newsocket</span><span class="p">,</span> <span class="n">server_side</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">connstream</span><span class="o">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SHUT_RDWR</span><span class="p">)</span>
        <span class="n">connstream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>そして、 <code class="docutils literal notranslate"><span class="pre">connstream</span></code> からデータを読み、クライアントと切断する(あるいはクライアントが切断してくる)まで何か処理をします。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="c1"># empty data means the client is finished with us</span>
    <span class="k">while</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">do_something</span><span class="p">(</span><span class="n">connstream</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
            <span class="c1"># we&#39;ll assume do_something returns False</span>
            <span class="c1"># when we&#39;re finished with client</span>
            <span class="k">break</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="c1"># finished with client</span>
</pre></div>
</div>
<p>そして新しいクライアント接続のために listen に戻ります。 (もちろん現実のサーバは、おそらく個々のクライアント接続ごとに別のスレッドで処理するか、ソケットを <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">ノンブロッキングモード</span></a> にし、イベントループを使うでしょう。)</p>
</div>
</div>
<div class="section" id="notes-on-non-blocking-sockets">
<span id="ssl-nonblocking"></span><h2>ノンブロッキングソケットについての注意事項<a class="headerlink" href="#notes-on-non-blocking-sockets" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SSL ソケットはノンブロッキングモードにおいては、普通のソケットとは少し違った振る舞いをします。ですのでノンブロッキングソケットとともに使う場合、いくつか気をつけなければならない事項があります:</p>
<ul>
<li><p class="first">ほとんどの <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> のメソッドは I/O 操作がブロックすると <a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BlockingIOError</span></code></a> ではなく <a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> か <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> のどちらかを送出します。 <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> は下層のソケットで読み出しが必要な場合に送出され、 <a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> は下層のソケットで書き込みが必要な場合に送出されます。SSL ソケットに対して <em>書き込み</em> を試みると下層のソケットから最初に <em>読み出す</em> 必要があるかもしれず、SSL ソケットに対して <em>読み出し</em> を試みると下層のソケットに先に <em>書き込む</em> 必要があるかもしれないことに注意してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>以前の Python バージョンでは、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.send()</span></code> メソッドは <a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> または <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> を送出するのではなく、ゼロを返していました。</p>
</div>
</li>
<li><p class="first"><a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 呼び出しは OS レベルでのソケットが読み出し可能(または書き込み可能)になったことを教えてくれますが、上位の SSL レイヤーでの十分なデータがあることを意味するわけではありません。例えば、SSL フレームの一部が届いただけかもしれません。ですから、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.recv()</span></code> と <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.send()</span></code> の失敗を処理することに備え、ほかの <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 呼び出し後にリトライしなければなりません。</p>
</li>
<li><p class="first">反対に、SSL レイヤーは独自の枠組みを持っているため、<a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> が気付かない読み出し可能なデータを SSL ソケットが持っている場合があります。したがって、入手可能な可能性のあるデータをすべて引き出すために最初に <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.recv()</span></code> を呼び出し、次にそれでもまだ必要な場合にだけ <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 呼び出しでブロックすべきです。</p>
<p>(当然のことながら、ほかのプリミティブ、例えば <a class="reference internal" href="select.html#select.poll" title="select.poll"><code class="xref py py-func docutils literal notranslate"><span class="pre">poll()</span></code></a> や <a class="reference internal" href="selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal notranslate"><span class="pre">selectors</span></code></a> モジュール内のものを使う際にも似た但し書きが付きます)</p>
</li>
<li><p class="first">SSL ハンドシェイクそのものがノンブロッキングになります: <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a> メソッドは成功するまでリトライしなければなりません。 <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> を用いてソケットの準備が整うのを待つためには、およそ以下のようにします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">do_handshake</span><span class="p">()</span>
        <span class="k">break</span>
    <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLWantReadError</span><span class="p">:</span>
        <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">sock</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[])</span>
    <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLWantWriteError</span><span class="p">:</span>
        <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([],</span> <span class="p">[</span><span class="n">sock</span><span class="p">],</span> <span class="p">[])</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> モジュールは <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">ノンブロッキング SSL ソケット</span></a> をサポートし、より高いレベルの API を提供しています。 <a class="reference internal" href="selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal notranslate"><span class="pre">selectors</span></code></a> モジュールを使ってイベントを poll し、 <a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a>, <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a>, <a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BlockingIOError</span></code></a> 例外を処理します。SSL ハンドシェイクも非同期に実行します。</p>
</div>
</div>
<div class="section" id="memory-bio-support">
<h2>メモリ BIO サポート<a class="headerlink" href="#memory-bio-support" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
<p>Python 2.6 で SSL モジュールが導入されて以降、<a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> クラスは、以下の互いに関連するが別々の機能を提供してきました。</p>
<ul class="simple">
<li>SSL プロトコル処理</li>
<li>ネットワーク IO</li>
</ul>
<p>ネットワーク IO API は、<a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> が提供するものと同じです。<a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>&nbsp;も、そのクラスから継承しています。これにより、SSL ソケットは標準のソケットをそっくりそのまま置き換えるものとして使用できるため、既存のアプリケーションを SSL に対応させるのが非常に簡単になります。</p>
<p>SSL プロトコルの処理とネットワーク IO を組み合わせた場合、通常は問題なく動作しますが、問題が発生する場合があります。一例を挙げると、非同期 IO フレームワークが別の多重化モデルを使用する場合、これは <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> と内部 OpenSSL ソケット IO ルーティンが想定する「ファイル記述子上の select/poll」モデル（準備状態ベース）とは異なります。これは、このモデルが非効率的になる Windows などのプラットフォームに主に該当します。そのため、スコープを限定した <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> の変種、 <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> が提供されています。</p>
<dl class="class">
<dt id="ssl.SSLObject">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">SSLObject</code><a class="headerlink" href="#ssl.SSLObject" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ネットワーク IO メソッドを含まない SSL プロトコルインスタンスを表す、スコープを限定した <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> の変種です。一般的にこ、のクラスを使用するのは、メモリバッファを通じて SSL のための非同期 IO を実装するフレームワーク作成者です。</p>
<p>このクラスは、OpenSSL が実装する低水準 SSL オブジェクトの上にインターフェイスを実装します。このオブジェクトは SSL 接続の状態をキャプチャしますが、ネットワーク IO 自体は提供しません。IO は、OpenSSL の IO 抽象レイヤである別の「BIO」オブジェクトを通じて実行する必要があります。</p>
<p>This class has no public constructor.  An <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> instance
must be created using the <a class="reference internal" href="#ssl.SSLContext.wrap_bio" title="ssl.SSLContext.wrap_bio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_bio()</span></code></a> method. This
method will create the <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> instance and bind it to a
pair of BIOs. The <em>incoming</em> BIO is used to pass data from Python to the
SSL protocol instance, while the <em>outgoing</em> BIO is used to pass data the
other way around.</p>
<p>次のメソッドがサポートされています:</p>
<ul class="simple">
<li><a class="reference internal" href="#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal notranslate"><span class="pre">context</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.server_side" title="ssl.SSLSocket.server_side"><code class="xref py py-attr docutils literal notranslate"><span class="pre">server_side</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.server_hostname" title="ssl.SSLSocket.server_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">server_hostname</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.session" title="ssl.SSLSocket.session"><code class="xref py py-attr docutils literal notranslate"><span class="pre">session</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.session_reused" title="ssl.SSLSocket.session_reused"><code class="xref py py-attr docutils literal notranslate"><span class="pre">session_reused</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.write" title="ssl.SSLSocket.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeercert()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.selected_npn_protocol" title="ssl.SSLSocket.selected_npn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">selected_npn_protocol()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cipher()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.shared_ciphers" title="ssl.SSLSocket.shared_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shared_ciphers()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.compression" title="ssl.SSLSocket.compression"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compression()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.pending" title="ssl.SSLSocket.pending"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pending()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_handshake()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.unwrap" title="ssl.SSLSocket.unwrap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unwrap()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.get_channel_binding" title="ssl.SSLSocket.get_channel_binding"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_channel_binding()</span></code></a></li>
</ul>
<p><a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> と比較すると、このオブジェクトでは以下の機能が不足しています。</p>
<ul class="simple">
<li>Any form of network IO; <code class="docutils literal notranslate"><span class="pre">recv()</span></code> and <code class="docutils literal notranslate"><span class="pre">send()</span></code> read and write only to
the underlying <a class="reference internal" href="#ssl.MemoryBIO" title="ssl.MemoryBIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryBIO</span></code></a> buffers.</li>
<li><em>do_handshake_on_connect</em> 機構はありません。必ず手動で <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_handshake()</span></code></a> を呼んで、ハンドシェイクを開始する必要があります。</li>
<li><em>suppress_ragged_eofs</em> は処理されません。プロトコルに違反するファイル末尾状態は、 <a class="reference internal" href="#ssl.SSLEOFError" title="ssl.SSLEOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLEOFError</span></code></a> 例外を通じて報告されます。</li>
<li><a class="reference internal" href="#ssl.SSLSocket.unwrap" title="ssl.SSLSocket.unwrap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unwrap()</span></code></a> メソッドの呼び出しは、下層のソケットを返す SSL ソケットとは異なり、何も返しません。</li>
<li><a class="reference internal" href="#ssl.SSLContext.set_servername_callback" title="ssl.SSLContext.set_servername_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_servername_callback()</span></code></a> に渡される <em>server_name_callback</em> コールバックは、1 つ目の引数として <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> インスタンスではなく <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> インスタンスを受け取ります。</li>
</ul>
<p><a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> の使用に関する注意:</p>
<ul class="simple">
<li><a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> 上のすべての IO は <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">non-blocking</span></a> です。例えば、<a class="reference internal" href="#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> は入力 BIO が持つデータよりも多くのデータを必要とする場合、<a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> を送出します。</li>
<li><a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> に対して存在するような、モジュールレベルの <code class="docutils literal notranslate"><span class="pre">wrap_bio()</span></code> 呼び出しは存在しません。<a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> は、常に <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> を経由して作成されます。</li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.7 で変更: </span><a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> instances must to created with
<a class="reference internal" href="#ssl.SSLContext.wrap_bio" title="ssl.SSLContext.wrap_bio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_bio()</span></code></a>. In earlier versions, it was possible to
create instances directly. This was never documented or officially
supported.</p>
</div>
</dd></dl>

<p>SSLObject は、メモリバッファを使用して外界と通信します。<a class="reference internal" href="#ssl.MemoryBIO" title="ssl.MemoryBIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryBIO</span></code></a>&nbsp;クラスは、以下のように OpenSSL メモリ BIO (Basic IO) オブジェクトをラップし、この目的に使用できるメモリバッファを提供します。</p>
<dl class="class">
<dt id="ssl.MemoryBIO">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">MemoryBIO</code><a class="headerlink" href="#ssl.MemoryBIO" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Python と SSL プロトコルインスタンス間でデータをやり取りするために使用できるメモリバッファ。</p>
<dl class="attribute">
<dt id="ssl.MemoryBIO.pending">
<code class="descname">pending</code><a class="headerlink" href="#ssl.MemoryBIO.pending" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在メモリバッファ中にあるバイト数を返します。</p>
</dd></dl>

<dl class="attribute">
<dt id="ssl.MemoryBIO.eof">
<code class="descname">eof</code><a class="headerlink" href="#ssl.MemoryBIO.eof" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリ BIOが現在ファイルの末尾にあるかを表す真偽値です。</p>
</dd></dl>

<dl class="method">
<dt id="ssl.MemoryBIO.read">
<code class="descname">read</code><span class="sig-paren">(</span><em>n=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.MemoryBIO.read" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリバッファから最大 <em>n</em> 読み取ります。<em>n</em>&nbsp;が指定されていないか、負値の場合、すべてのバイトが返されます。</p>
</dd></dl>

<dl class="method">
<dt id="ssl.MemoryBIO.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>buf</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.MemoryBIO.write" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>buf</em> からメモリ BIO にバイトを書き込みます。<em>buf</em> 引数は、バッファプロトコルをサポートするオブジェクトでなければなりません。</p>
<p>戻り値は、書き込まれるバイト数であり、常に <em>buf</em> の長さと等しくなります。</p>
</dd></dl>

<dl class="method">
<dt id="ssl.MemoryBIO.write_eof">
<code class="descname">write_eof</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.MemoryBIO.write_eof" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>EOF マーカーをメモリ BIO に書き込みます。このメソッドが呼び出された後に <a class="reference internal" href="#ssl.MemoryBIO.write" title="ssl.MemoryBIO.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> を呼ぶことはできません。<a class="reference internal" href="#ssl.MemoryBIO.eof" title="ssl.MemoryBIO.eof"><code class="xref py py-attr docutils literal notranslate"><span class="pre">eof</span></code></a> 属性は、バッファ内のすべてのデータが読み出された後に True になります。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="ssl-session">
<h2>SSL セッション<a class="headerlink" href="#ssl-session" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
<dl class="class">
<dt id="ssl.SSLSession">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">SSLSession</code><a class="headerlink" href="#ssl.SSLSession" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLSocket.session" title="ssl.SSLSocket.session"><code class="xref py py-attr docutils literal notranslate"><span class="pre">session</span></code></a> が使用するセッションオブジェクトです。</p>
<dl class="attribute">
<dt id="ssl.SSLSession.id">
<code class="descname">id</code><a class="headerlink" href="#ssl.SSLSession.id" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSession.time">
<code class="descname">time</code><a class="headerlink" href="#ssl.SSLSession.time" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSession.timeout">
<code class="descname">timeout</code><a class="headerlink" href="#ssl.SSLSession.timeout" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSession.ticket_lifetime_hint">
<code class="descname">ticket_lifetime_hint</code><a class="headerlink" href="#ssl.SSLSession.ticket_lifetime_hint" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSession.has_ticket">
<code class="descname">has_ticket</code><a class="headerlink" href="#ssl.SSLSession.has_ticket" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="security-considerations">
<span id="ssl-security"></span><h2>セキュリティで考慮すべき点<a class="headerlink" href="#security-considerations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="best-defaults">
<h3>最善のデフォルト値<a class="headerlink" href="#best-defaults" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><strong>クライアントでの使用</strong> では、セキュリティポリシーによる特殊な要件がない限りは、 <a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> 関数を使用して SSL コンテキストを作成することを強くお勧めします。この関数は、システムの信頼済み CA 証明書をロードし、証明書の検証とホスト名のチェックを有効化し、十分にセキュアなプロトコルと暗号を選択しようとします。</p>
<p>例として、 <a class="reference internal" href="smtplib.html#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">smtplib.SMTP</span></code></a> クラスを使用して SMTP サーバーに対して信頼できるセキュアな接続を行う方法を以下に示します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ssl</span><span class="o">,</span> <span class="nn">smtplib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smtp</span> <span class="o">=</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="s2">&quot;mail.python.org&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">587</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smtp</span><span class="o">.</span><span class="n">starttls</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
<span class="go">(220, b&#39;2.0.0 Ready to start TLS&#39;)</span>
</pre></div>
</div>
<p>接続にクライアントの証明書が必要な場合、 <a class="reference internal" href="#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_cert_chain()</span></code></a> によって追加できます。</p>
<p>対照的に、自分自身で <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> クラスのコンストラクタを呼び出すことによって SSL コンテキストを作ると、デフォルトでは証明書検証もホスト名チェックも有効になりません。自分で設定を行う場合は、十分なセキュリティレベルを達成するために、以下のパラグラフをお読みください。</p>
</div>
<div class="section" id="manual-settings">
<h3>手動での設定<a class="headerlink" href="#manual-settings" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="verifying-certificates">
<h4>証明書の検証<a class="headerlink" href="#verifying-certificates" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> のコンストラクタを直接呼び出した場合、 <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a> がデフォルトとして使われます。これは接続先の身元特定をしないので安全ではありませんし、特にクライアントモードでは大抵相手となるサーバの信憑性を保障したいでしょう。ですから、クライアントモードでは <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> を強くお勧めします。ですが、それだけでは不十分です; <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a> を呼び出してサーバ証明書が望んだサービスと合致するかのチェックもしなければなりません。多くのプロトコルとアプリケーションにとって、サービスはホスト名で特定されます; この場合、 <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code></a> が使えます。これらの共通的なチェックは <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.check_hostname</span></code></a> が有効な場合、自動的に行われます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.7 で変更: </span>Hostname matchings is now performed by OpenSSL. Python no longer uses
<a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code></a>.</p>
</div>
<p>サーバモードにおいて、(より上位のレベルでの認証メカニズムではなく) SSL レイヤーを使ってあなたのクライアントを認証したいならば、 <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> を指定して同じようにクライアントの証明書を検証すべきでしょう。</p>
</div>
<div class="section" id="protocol-versions">
<h4>プロトコルのバージョン<a class="headerlink" href="#protocol-versions" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>SSL バージョン 2 と 3 は安全性に欠けると考えられており、使用するのは危険です。クライアントとサーバ間の互換性を最大限に確保したい場合、プロトコルバージョンとして <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> または <a class="reference internal" href="#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a> を使用してください。 SSLv2 と SSLv3 はデフォルトで無効になっています。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client_context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLS_CLIENT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client_context</span><span class="o">.</span><span class="n">options</span> <span class="o">|=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">OP_NO_TLSv1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client_context</span><span class="o">.</span><span class="n">options</span> <span class="o">|=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">OP_NO_TLSv1_1</span>
</pre></div>
</div>
<p>上記で作成した SSL コンテキストは、TLSv1.2 以降 (システムでサポートされている場合) でのサーバへの接続のみを許可します。<a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> は、デフォルトで証明書の検証とホスト名のチェックを意味します。コンテキスト中に証明書をロードする必要があります。</p>
</div>
<div class="section" id="cipher-selection">
<h4>暗号の選択<a class="headerlink" href="#cipher-selection" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>If you have advanced security requirements, fine-tuning of the ciphers
enabled when negotiating a SSL session is possible through the
<a class="reference internal" href="#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_ciphers()</span></code></a> method.  Starting from Python 3.2.3, the
ssl module disables certain weak ciphers by default, but you may want
to further restrict the cipher choice. Be sure to read OpenSSL's documentation
about the <a class="reference external" href="https://www.openssl.org/docs/manmaster/man1/ciphers.html#CIPHER-LIST-FORMAT">cipher list format</a>.
If you want to check which ciphers are enabled by a given cipher list, use
<a class="reference internal" href="#ssl.SSLContext.get_ciphers" title="ssl.SSLContext.get_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.get_ciphers()</span></code></a> or the <code class="docutils literal notranslate"><span class="pre">openssl</span> <span class="pre">ciphers</span></code> command on your
system.</p>
</div>
</div>
<div class="section" id="multi-processing">
<h3>マルチプロセス化<a class="headerlink" href="#multi-processing" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>(例えば <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> や <a class="reference internal" href="concurrent.futures.html#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code class="xref py py-mod docutils literal notranslate"><span class="pre">concurrent.futures</span></code></a> を使って、)マルチプロセスアプリケーションの一部としてこのモジュールを使う場合、OpenSSL の内部の乱数発生器は fork したプロセスを適切に処理しないことに気を付けて下さい。SSL の機能を <a class="reference internal" href="os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a> とともに使う場合、アプリケーションは親プロセスの PRNG 状態を変更しなければなりません。 <a class="reference internal" href="#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_add()</span></code></a>, <a class="reference internal" href="#ssl.RAND_bytes" title="ssl.RAND_bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_bytes()</span></code></a>, <a class="reference internal" href="#ssl.RAND_pseudo_bytes" title="ssl.RAND_pseudo_bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_pseudo_bytes()</span></code></a> のいずれかの呼び出し成功があれば十分です。</p>
</div>
</div>
<div class="section" id="tls-1-3">
<span id="ssl-tlsv1-3"></span><h2>TLS 1.3<a class="headerlink" href="#tls-1-3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.7 で追加.</span></p>
</div>
<p>Python has provisional and experimental support for TLS 1.3 with OpenSSL
1.1.1.  The new protocol behaves slightly differently than previous version
of TLS/SSL.  Some new TLS 1.3 features are not yet available.</p>
<ul class="simple">
<li>TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and
ChaCha20 cipher suites are enabled by default.  The method
<a class="reference internal" href="#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_ciphers()</span></code></a> cannot enable or disable any TLS 1.3
ciphers yet, but <a class="reference internal" href="#ssl.SSLContext.get_ciphers" title="ssl.SSLContext.get_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.get_ciphers()</span></code></a> returns them.</li>
<li>Session tickets are no longer sent as part of the initial handshake and
are handled differently.  <a class="reference internal" href="#ssl.SSLSocket.session" title="ssl.SSLSocket.session"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLSocket.session</span></code></a> and <a class="reference internal" href="#ssl.SSLSession" title="ssl.SSLSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSession</span></code></a>
are not compatible with TLS 1.3.</li>
<li>Client-side certificates are also no longer verified during the initial
handshake.  A server can request a certificate at any time.  Clients
process certificate requests while they send or receive application data
from the server.</li>
<li>TLS 1.3 features like early data, deferred TLS client cert request,
signature algorithm configuration, and rekeying are not supported yet.</li>
</ul>
</div>
<div class="section" id="libressl-support">
<span id="ssl-libressl"></span><h2>LibreSSL support<a class="headerlink" href="#libressl-support" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>LibreSSL is a fork of OpenSSL 1.0.1. The ssl module has limited support for
LibreSSL. Some features are not available when the ssl module is compiled
with LibreSSL.</p>
<ul class="simple">
<li>LibreSSL &gt;= 2.6.1 no longer supports NPN. The methods
<a class="reference internal" href="#ssl.SSLContext.set_npn_protocols" title="ssl.SSLContext.set_npn_protocols"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_npn_protocols()</span></code></a> and
<a class="reference internal" href="#ssl.SSLSocket.selected_npn_protocol" title="ssl.SSLSocket.selected_npn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.selected_npn_protocol()</span></code></a> are not available.</li>
<li><a class="reference internal" href="#ssl.SSLContext.set_default_verify_paths" title="ssl.SSLContext.set_default_verify_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_default_verify_paths()</span></code></a> ignores the env vars
<span class="target" id="index-20"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">SSL_CERT_FILE</span></code> and <span class="target" id="index-21"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">SSL_CERT_PATH</span></code> although
<a class="reference internal" href="#ssl.get_default_verify_paths" title="ssl.get_default_verify_paths"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_default_verify_paths()</span></code></a> still reports them.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> クラス</dt>
<dd>下位レイヤーの <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> クラスのドキュメント</dd>
<dt><a class="reference external" href="https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html">SSL/TLS Strong Encryption: An Introduction</a></dt>
<dd>Intro from the Apache HTTP Server documentation</dd>
<dt><span class="target" id="index-22"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1422.html"><strong>RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: Certificate-Based Key Management</strong></a></dt>
<dd>Steve Kent</dd>
<dt><span class="target" id="index-23"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc4086.html"><strong>RFC 4086: Randomness Requirements for Security</strong></a></dt>
<dd>Donald E., Jeffrey I. Schiller</dd>
<dt><span class="target" id="index-24"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5280.html"><strong>RFC 5280: Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</strong></a></dt>
<dd>D. Cooper</dd>
<dt><span class="target" id="index-25"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5246.html"><strong>RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2</strong></a></dt>
<dd>T. Dierks et. al.</dd>
<dt><span class="target" id="index-26"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6066.html"><strong>RFC 6066: Transport Layer Security (TLS) Extensions</strong></a></dt>
<dd>D. Eastlake</dd>
<dt><a class="reference external" href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xml">IANA TLS: Transport Layer Security (TLS) Parameters</a></dt>
<dd>IANA</dd>
<dt><span class="target" id="index-27"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7525.html"><strong>RFC 7525: Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</strong></a></dt>
<dd>IETF</dd>
<dt><a class="reference external" href="https://wiki.mozilla.org/Security/Server_Side_TLS">Mozilla's Server Side TLS recommendations</a></dt>
<dd>Mozilla</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">ssl</span></code> --- ソケットオブジェクトに対する TLS/SSL ラッパー</a><ul>
<li><a class="reference internal" href="#functions-constants-and-exceptions">関数、定数、例外</a><ul>
<li><a class="reference internal" href="#socket-creation">ソケットの作成</a></li>
<li><a class="reference internal" href="#context-creation">コンテキストの作成</a></li>
<li><a class="reference internal" href="#exceptions">例外</a></li>
<li><a class="reference internal" href="#random-generation">乱数生成</a></li>
<li><a class="reference internal" href="#certificate-handling">証明書の取り扱い</a></li>
<li><a class="reference internal" href="#constants">定数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ssl-sockets">SSL ソケット</a></li>
<li><a class="reference internal" href="#ssl-contexts">SSL コンテキスト</a></li>
<li><a class="reference internal" href="#certificates">証明書</a><ul>
<li><a class="reference internal" href="#certificate-chains">証明書チェイン</a></li>
<li><a class="reference internal" href="#ca-certificates">CA 証明書</a></li>
<li><a class="reference internal" href="#combined-key-and-certificate">秘密鍵と証明書の組み合わせ</a></li>
<li><a class="reference internal" href="#self-signed-certificates">自己署名証明書</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">使用例</a><ul>
<li><a class="reference internal" href="#testing-for-ssl-support">SSLサポートをテストする</a></li>
<li><a class="reference internal" href="#client-side-operation">クライアントサイドの処理</a></li>
<li><a class="reference internal" href="#server-side-operation">サーバサイドの処理</a></li>
</ul>
</li>
<li><a class="reference internal" href="#notes-on-non-blocking-sockets">ノンブロッキングソケットについての注意事項</a></li>
<li><a class="reference internal" href="#memory-bio-support">メモリ BIO サポート</a></li>
<li><a class="reference internal" href="#ssl-session">SSL セッション</a></li>
<li><a class="reference internal" href="#security-considerations">セキュリティで考慮すべき点</a><ul>
<li><a class="reference internal" href="#best-defaults">最善のデフォルト値</a></li>
<li><a class="reference internal" href="#manual-settings">手動での設定</a><ul>
<li><a class="reference internal" href="#verifying-certificates">証明書の検証</a></li>
<li><a class="reference internal" href="#protocol-versions">プロトコルのバージョン</a></li>
<li><a class="reference internal" href="#cipher-selection">暗号の選択</a></li>
</ul>
</li>
<li><a class="reference internal" href="#multi-processing">マルチプロセス化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tls-1-3">TLS 1.3</a></li>
<li><a class="reference internal" href="#libressl-support">LibreSSL support</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="socket.html"
                        title="前の章へ"><code class="docutils literal notranslate"><span class="pre">socket</span></code> --- 低水準ネットワークインターフェイス</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="select.html"
                        title="次の章へ"><code class="docutils literal notranslate"><span class="pre">select</span></code> --- I/O 処理の完了を待機する</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/library/ssl.rst"
            rel="nofollow">ソースコードを表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="select.html" title="select --- I/O 処理の完了を待機する"
             >次へ</a> |</li>
        <li class="right" >
          <a href="socket.html" title="socket --- 低水準ネットワークインターフェイス"
             >前へ</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >ネットワーク通信とプロセス間通信</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" type="text" name="q" />
          <input type="submit" value="検索" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">著作権</a> 2001-2020, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最終更新: 5月 16, 2020
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>

  </body>
</html>